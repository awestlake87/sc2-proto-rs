// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `s2clientprotocol/ui.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct ObservationUI {
    // message fields
    pub groups: ::protobuf::RepeatedField<ControlGroup>,
    // message oneof groups
    pub panel: ::std::option::Option<ObservationUI_oneof_panel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObservationUI {
    fn default() -> &'a ObservationUI {
        <ObservationUI as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ObservationUI_oneof_panel {
    single(SinglePanel),
    multi(MultiPanel),
    cargo(CargoPanel),
    production(ProductionPanel),
}

impl ObservationUI {
    pub fn new() -> ObservationUI {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.ControlGroup groups = 1;


    pub fn get_groups(&self) -> &[ControlGroup] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<ControlGroup>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<ControlGroup> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<ControlGroup> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    // optional .SC2APIProtocol.SinglePanel single = 2;


    pub fn get_single(&self) -> &SinglePanel {
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::single(ref v)) => v,
            _ => <SinglePanel as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_single(&mut self) {
        self.panel = ::std::option::Option::None;
    }

    pub fn has_single(&self) -> bool {
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::single(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single(&mut self, v: SinglePanel) {
        self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::single(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single(&mut self) -> &mut SinglePanel {
        if let ::std::option::Option::Some(ObservationUI_oneof_panel::single(_)) = self.panel {
        } else {
            self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::single(SinglePanel::new()));
        }
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::single(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single(&mut self) -> SinglePanel {
        if self.has_single() {
            match self.panel.take() {
                ::std::option::Option::Some(ObservationUI_oneof_panel::single(v)) => v,
                _ => panic!(),
            }
        } else {
            SinglePanel::new()
        }
    }

    // optional .SC2APIProtocol.MultiPanel multi = 3;


    pub fn get_multi(&self) -> &MultiPanel {
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::multi(ref v)) => v,
            _ => <MultiPanel as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_multi(&mut self) {
        self.panel = ::std::option::Option::None;
    }

    pub fn has_multi(&self) -> bool {
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::multi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi(&mut self, v: MultiPanel) {
        self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::multi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi(&mut self) -> &mut MultiPanel {
        if let ::std::option::Option::Some(ObservationUI_oneof_panel::multi(_)) = self.panel {
        } else {
            self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::multi(MultiPanel::new()));
        }
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::multi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi(&mut self) -> MultiPanel {
        if self.has_multi() {
            match self.panel.take() {
                ::std::option::Option::Some(ObservationUI_oneof_panel::multi(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiPanel::new()
        }
    }

    // optional .SC2APIProtocol.CargoPanel cargo = 4;


    pub fn get_cargo(&self) -> &CargoPanel {
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::cargo(ref v)) => v,
            _ => <CargoPanel as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cargo(&mut self) {
        self.panel = ::std::option::Option::None;
    }

    pub fn has_cargo(&self) -> bool {
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::cargo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cargo(&mut self, v: CargoPanel) {
        self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::cargo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cargo(&mut self) -> &mut CargoPanel {
        if let ::std::option::Option::Some(ObservationUI_oneof_panel::cargo(_)) = self.panel {
        } else {
            self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::cargo(CargoPanel::new()));
        }
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::cargo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cargo(&mut self) -> CargoPanel {
        if self.has_cargo() {
            match self.panel.take() {
                ::std::option::Option::Some(ObservationUI_oneof_panel::cargo(v)) => v,
                _ => panic!(),
            }
        } else {
            CargoPanel::new()
        }
    }

    // optional .SC2APIProtocol.ProductionPanel production = 5;


    pub fn get_production(&self) -> &ProductionPanel {
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::production(ref v)) => v,
            _ => <ProductionPanel as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_production(&mut self) {
        self.panel = ::std::option::Option::None;
    }

    pub fn has_production(&self) -> bool {
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::production(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_production(&mut self, v: ProductionPanel) {
        self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::production(v))
    }

    // Mutable pointer to the field.
    pub fn mut_production(&mut self) -> &mut ProductionPanel {
        if let ::std::option::Option::Some(ObservationUI_oneof_panel::production(_)) = self.panel {
        } else {
            self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::production(ProductionPanel::new()));
        }
        match self.panel {
            ::std::option::Option::Some(ObservationUI_oneof_panel::production(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_production(&mut self) -> ProductionPanel {
        if self.has_production() {
            match self.panel.take() {
                ::std::option::Option::Some(ObservationUI_oneof_panel::production(v)) => v,
                _ => panic!(),
            }
        } else {
            ProductionPanel::new()
        }
    }
}

impl ::protobuf::Message for ObservationUI {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(ObservationUI_oneof_panel::single(ref v)) = self.panel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ObservationUI_oneof_panel::multi(ref v)) = self.panel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ObservationUI_oneof_panel::cargo(ref v)) = self.panel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ObservationUI_oneof_panel::production(ref v)) = self.panel {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::single(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::multi(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::cargo(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.panel = ::std::option::Option::Some(ObservationUI_oneof_panel::production(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.panel {
            match v {
                &ObservationUI_oneof_panel::single(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ObservationUI_oneof_panel::multi(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ObservationUI_oneof_panel::cargo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ObservationUI_oneof_panel::production(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.panel {
            match v {
                &ObservationUI_oneof_panel::single(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ObservationUI_oneof_panel::multi(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ObservationUI_oneof_panel::cargo(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ObservationUI_oneof_panel::production(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationUI {
        ObservationUI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlGroup>>(
                "groups",
                |m: &ObservationUI| { &m.groups },
                |m: &mut ObservationUI| { &mut m.groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SinglePanel>(
                "single",
                ObservationUI::has_single,
                ObservationUI::get_single,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MultiPanel>(
                "multi",
                ObservationUI::has_multi,
                ObservationUI::get_multi,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CargoPanel>(
                "cargo",
                ObservationUI::has_cargo,
                ObservationUI::get_cargo,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProductionPanel>(
                "production",
                ObservationUI::has_production,
                ObservationUI::get_production,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObservationUI>(
                "ObservationUI",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObservationUI {
        static instance: ::protobuf::rt::LazyV2<ObservationUI> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObservationUI::new)
    }
}

impl ::protobuf::Clear for ObservationUI {
    fn clear(&mut self) {
        self.groups.clear();
        self.panel = ::std::option::Option::None;
        self.panel = ::std::option::Option::None;
        self.panel = ::std::option::Option::None;
        self.panel = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationUI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationUI {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ControlGroup {
    // message fields
    pub control_group_index: ::std::option::Option<u32>,
    pub leader_unit_type: ::std::option::Option<u32>,
    pub count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlGroup {
    fn default() -> &'a ControlGroup {
        <ControlGroup as ::protobuf::Message>::default_instance()
    }
}

impl ControlGroup {
    pub fn new() -> ControlGroup {
        ::std::default::Default::default()
    }

    // optional uint32 control_group_index = 1;


    pub fn get_control_group_index(&self) -> u32 {
        self.control_group_index.unwrap_or(0)
    }
    pub fn clear_control_group_index(&mut self) {
        self.control_group_index = ::std::option::Option::None;
    }

    pub fn has_control_group_index(&self) -> bool {
        self.control_group_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_group_index(&mut self, v: u32) {
        self.control_group_index = ::std::option::Option::Some(v);
    }

    // optional uint32 leader_unit_type = 2;


    pub fn get_leader_unit_type(&self) -> u32 {
        self.leader_unit_type.unwrap_or(0)
    }
    pub fn clear_leader_unit_type(&mut self) {
        self.leader_unit_type = ::std::option::Option::None;
    }

    pub fn has_leader_unit_type(&self) -> bool {
        self.leader_unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_unit_type(&mut self, v: u32) {
        self.leader_unit_type = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ControlGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.control_group_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leader_unit_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.control_group_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leader_unit_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.control_group_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leader_unit_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlGroup {
        ControlGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "control_group_index",
                |m: &ControlGroup| { &m.control_group_index },
                |m: &mut ControlGroup| { &mut m.control_group_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "leader_unit_type",
                |m: &ControlGroup| { &m.leader_unit_type },
                |m: &mut ControlGroup| { &mut m.leader_unit_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &ControlGroup| { &m.count },
                |m: &mut ControlGroup| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlGroup>(
                "ControlGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlGroup {
        static instance: ::protobuf::rt::LazyV2<ControlGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlGroup::new)
    }
}

impl ::protobuf::Clear for ControlGroup {
    fn clear(&mut self) {
        self.control_group_index = ::std::option::Option::None;
        self.leader_unit_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitInfo {
    // message fields
    pub unit_type: ::std::option::Option<u32>,
    pub player_relative: ::std::option::Option<u32>,
    pub health: ::std::option::Option<i32>,
    pub shields: ::std::option::Option<i32>,
    pub energy: ::std::option::Option<i32>,
    pub transport_slots_taken: ::std::option::Option<i32>,
    pub build_progress: ::std::option::Option<f32>,
    pub add_on: ::protobuf::SingularPtrField<UnitInfo>,
    pub max_health: ::std::option::Option<i32>,
    pub max_shields: ::std::option::Option<i32>,
    pub max_energy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitInfo {
    fn default() -> &'a UnitInfo {
        <UnitInfo as ::protobuf::Message>::default_instance()
    }
}

impl UnitInfo {
    pub fn new() -> UnitInfo {
        ::std::default::Default::default()
    }

    // optional uint32 unit_type = 1;


    pub fn get_unit_type(&self) -> u32 {
        self.unit_type.unwrap_or(0)
    }
    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: u32) {
        self.unit_type = ::std::option::Option::Some(v);
    }

    // optional uint32 player_relative = 2;


    pub fn get_player_relative(&self) -> u32 {
        self.player_relative.unwrap_or(0)
    }
    pub fn clear_player_relative(&mut self) {
        self.player_relative = ::std::option::Option::None;
    }

    pub fn has_player_relative(&self) -> bool {
        self.player_relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_relative(&mut self, v: u32) {
        self.player_relative = ::std::option::Option::Some(v);
    }

    // optional int32 health = 3;


    pub fn get_health(&self) -> i32 {
        self.health.unwrap_or(0)
    }
    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional int32 shields = 4;


    pub fn get_shields(&self) -> i32 {
        self.shields.unwrap_or(0)
    }
    pub fn clear_shields(&mut self) {
        self.shields = ::std::option::Option::None;
    }

    pub fn has_shields(&self) -> bool {
        self.shields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shields(&mut self, v: i32) {
        self.shields = ::std::option::Option::Some(v);
    }

    // optional int32 energy = 5;


    pub fn get_energy(&self) -> i32 {
        self.energy.unwrap_or(0)
    }
    pub fn clear_energy(&mut self) {
        self.energy = ::std::option::Option::None;
    }

    pub fn has_energy(&self) -> bool {
        self.energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy(&mut self, v: i32) {
        self.energy = ::std::option::Option::Some(v);
    }

    // optional int32 transport_slots_taken = 6;


    pub fn get_transport_slots_taken(&self) -> i32 {
        self.transport_slots_taken.unwrap_or(0)
    }
    pub fn clear_transport_slots_taken(&mut self) {
        self.transport_slots_taken = ::std::option::Option::None;
    }

    pub fn has_transport_slots_taken(&self) -> bool {
        self.transport_slots_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_slots_taken(&mut self, v: i32) {
        self.transport_slots_taken = ::std::option::Option::Some(v);
    }

    // optional float build_progress = 7;


    pub fn get_build_progress(&self) -> f32 {
        self.build_progress.unwrap_or(0.)
    }
    pub fn clear_build_progress(&mut self) {
        self.build_progress = ::std::option::Option::None;
    }

    pub fn has_build_progress(&self) -> bool {
        self.build_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_progress(&mut self, v: f32) {
        self.build_progress = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.UnitInfo add_on = 8;


    pub fn get_add_on(&self) -> &UnitInfo {
        self.add_on.as_ref().unwrap_or_else(|| <UnitInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_add_on(&mut self) {
        self.add_on.clear();
    }

    pub fn has_add_on(&self) -> bool {
        self.add_on.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_on(&mut self, v: UnitInfo) {
        self.add_on = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_add_on(&mut self) -> &mut UnitInfo {
        if self.add_on.is_none() {
            self.add_on.set_default();
        }
        self.add_on.as_mut().unwrap()
    }

    // Take field
    pub fn take_add_on(&mut self) -> UnitInfo {
        self.add_on.take().unwrap_or_else(|| UnitInfo::new())
    }

    // optional int32 max_health = 9;


    pub fn get_max_health(&self) -> i32 {
        self.max_health.unwrap_or(0)
    }
    pub fn clear_max_health(&mut self) {
        self.max_health = ::std::option::Option::None;
    }

    pub fn has_max_health(&self) -> bool {
        self.max_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_health(&mut self, v: i32) {
        self.max_health = ::std::option::Option::Some(v);
    }

    // optional int32 max_shields = 10;


    pub fn get_max_shields(&self) -> i32 {
        self.max_shields.unwrap_or(0)
    }
    pub fn clear_max_shields(&mut self) {
        self.max_shields = ::std::option::Option::None;
    }

    pub fn has_max_shields(&self) -> bool {
        self.max_shields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_shields(&mut self, v: i32) {
        self.max_shields = ::std::option::Option::Some(v);
    }

    // optional int32 max_energy = 11;


    pub fn get_max_energy(&self) -> i32 {
        self.max_energy.unwrap_or(0)
    }
    pub fn clear_max_energy(&mut self) {
        self.max_energy = ::std::option::Option::None;
    }

    pub fn has_max_energy(&self) -> bool {
        self.max_energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_energy(&mut self, v: i32) {
        self.max_energy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnitInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.add_on {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unit_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_relative = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.health = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shields = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.energy = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.transport_slots_taken = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.build_progress = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.add_on)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_health = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_shields = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_energy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_relative {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.health {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shields {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.energy {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.transport_slots_taken {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.build_progress {
            my_size += 5;
        }
        if let Some(ref v) = self.add_on.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.max_health {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_shields {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_energy {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_relative {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.health {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.shields {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.energy {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.transport_slots_taken {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.build_progress {
            os.write_float(7, v)?;
        }
        if let Some(ref v) = self.add_on.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.max_health {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.max_shields {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.max_energy {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitInfo {
        UnitInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unit_type",
                |m: &UnitInfo| { &m.unit_type },
                |m: &mut UnitInfo| { &mut m.unit_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_relative",
                |m: &UnitInfo| { &m.player_relative },
                |m: &mut UnitInfo| { &mut m.player_relative },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "health",
                |m: &UnitInfo| { &m.health },
                |m: &mut UnitInfo| { &mut m.health },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "shields",
                |m: &UnitInfo| { &m.shields },
                |m: &mut UnitInfo| { &mut m.shields },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "energy",
                |m: &UnitInfo| { &m.energy },
                |m: &mut UnitInfo| { &mut m.energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "transport_slots_taken",
                |m: &UnitInfo| { &m.transport_slots_taken },
                |m: &mut UnitInfo| { &mut m.transport_slots_taken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "build_progress",
                |m: &UnitInfo| { &m.build_progress },
                |m: &mut UnitInfo| { &mut m.build_progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitInfo>>(
                "add_on",
                |m: &UnitInfo| { &m.add_on },
                |m: &mut UnitInfo| { &mut m.add_on },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_health",
                |m: &UnitInfo| { &m.max_health },
                |m: &mut UnitInfo| { &mut m.max_health },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_shields",
                |m: &UnitInfo| { &m.max_shields },
                |m: &mut UnitInfo| { &mut m.max_shields },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_energy",
                |m: &UnitInfo| { &m.max_energy },
                |m: &mut UnitInfo| { &mut m.max_energy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitInfo>(
                "UnitInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitInfo {
        static instance: ::protobuf::rt::LazyV2<UnitInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitInfo::new)
    }
}

impl ::protobuf::Clear for UnitInfo {
    fn clear(&mut self) {
        self.unit_type = ::std::option::Option::None;
        self.player_relative = ::std::option::Option::None;
        self.health = ::std::option::Option::None;
        self.shields = ::std::option::Option::None;
        self.energy = ::std::option::Option::None;
        self.transport_slots_taken = ::std::option::Option::None;
        self.build_progress = ::std::option::Option::None;
        self.add_on.clear();
        self.max_health = ::std::option::Option::None;
        self.max_shields = ::std::option::Option::None;
        self.max_energy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SinglePanel {
    // message fields
    pub unit: ::protobuf::SingularPtrField<UnitInfo>,
    pub attack_upgrade_level: ::std::option::Option<i32>,
    pub armor_upgrade_level: ::std::option::Option<i32>,
    pub shield_upgrade_level: ::std::option::Option<i32>,
    pub buffs: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SinglePanel {
    fn default() -> &'a SinglePanel {
        <SinglePanel as ::protobuf::Message>::default_instance()
    }
}

impl SinglePanel {
    pub fn new() -> SinglePanel {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.UnitInfo unit = 1;


    pub fn get_unit(&self) -> &UnitInfo {
        self.unit.as_ref().unwrap_or_else(|| <UnitInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: UnitInfo) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut UnitInfo {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> UnitInfo {
        self.unit.take().unwrap_or_else(|| UnitInfo::new())
    }

    // optional int32 attack_upgrade_level = 2;


    pub fn get_attack_upgrade_level(&self) -> i32 {
        self.attack_upgrade_level.unwrap_or(0)
    }
    pub fn clear_attack_upgrade_level(&mut self) {
        self.attack_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_attack_upgrade_level(&self) -> bool {
        self.attack_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_upgrade_level(&mut self, v: i32) {
        self.attack_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional int32 armor_upgrade_level = 3;


    pub fn get_armor_upgrade_level(&self) -> i32 {
        self.armor_upgrade_level.unwrap_or(0)
    }
    pub fn clear_armor_upgrade_level(&mut self) {
        self.armor_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_armor_upgrade_level(&self) -> bool {
        self.armor_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor_upgrade_level(&mut self, v: i32) {
        self.armor_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional int32 shield_upgrade_level = 4;


    pub fn get_shield_upgrade_level(&self) -> i32 {
        self.shield_upgrade_level.unwrap_or(0)
    }
    pub fn clear_shield_upgrade_level(&mut self) {
        self.shield_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_shield_upgrade_level(&self) -> bool {
        self.shield_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_upgrade_level(&mut self, v: i32) {
        self.shield_upgrade_level = ::std::option::Option::Some(v);
    }

    // repeated int32 buffs = 5;


    pub fn get_buffs(&self) -> &[i32] {
        &self.buffs
    }
    pub fn clear_buffs(&mut self) {
        self.buffs.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffs(&mut self, v: ::std::vec::Vec<i32>) {
        self.buffs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buffs(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.buffs
    }

    // Take field
    pub fn take_buffs(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.buffs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SinglePanel {
    fn is_initialized(&self) -> bool {
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attack_upgrade_level = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.armor_upgrade_level = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shield_upgrade_level = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.buffs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.attack_upgrade_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.armor_upgrade_level {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shield_upgrade_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.buffs {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.attack_upgrade_level {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.armor_upgrade_level {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.shield_upgrade_level {
            os.write_int32(4, v)?;
        }
        for v in &self.buffs {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SinglePanel {
        SinglePanel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitInfo>>(
                "unit",
                |m: &SinglePanel| { &m.unit },
                |m: &mut SinglePanel| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "attack_upgrade_level",
                |m: &SinglePanel| { &m.attack_upgrade_level },
                |m: &mut SinglePanel| { &mut m.attack_upgrade_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "armor_upgrade_level",
                |m: &SinglePanel| { &m.armor_upgrade_level },
                |m: &mut SinglePanel| { &mut m.armor_upgrade_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "shield_upgrade_level",
                |m: &SinglePanel| { &m.shield_upgrade_level },
                |m: &mut SinglePanel| { &mut m.shield_upgrade_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "buffs",
                |m: &SinglePanel| { &m.buffs },
                |m: &mut SinglePanel| { &mut m.buffs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SinglePanel>(
                "SinglePanel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SinglePanel {
        static instance: ::protobuf::rt::LazyV2<SinglePanel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SinglePanel::new)
    }
}

impl ::protobuf::Clear for SinglePanel {
    fn clear(&mut self) {
        self.unit.clear();
        self.attack_upgrade_level = ::std::option::Option::None;
        self.armor_upgrade_level = ::std::option::Option::None;
        self.shield_upgrade_level = ::std::option::Option::None;
        self.buffs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SinglePanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinglePanel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiPanel {
    // message fields
    pub units: ::protobuf::RepeatedField<UnitInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiPanel {
    fn default() -> &'a MultiPanel {
        <MultiPanel as ::protobuf::Message>::default_instance()
    }
}

impl MultiPanel {
    pub fn new() -> MultiPanel {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.UnitInfo units = 1;


    pub fn get_units(&self) -> &[UnitInfo] {
        &self.units
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: ::protobuf::RepeatedField<UnitInfo>) {
        self.units = v;
    }

    // Mutable pointer to the field.
    pub fn mut_units(&mut self) -> &mut ::protobuf::RepeatedField<UnitInfo> {
        &mut self.units
    }

    // Take field
    pub fn take_units(&mut self) -> ::protobuf::RepeatedField<UnitInfo> {
        ::std::mem::replace(&mut self.units, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiPanel {
    fn is_initialized(&self) -> bool {
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.units {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.units {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiPanel {
        MultiPanel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitInfo>>(
                "units",
                |m: &MultiPanel| { &m.units },
                |m: &mut MultiPanel| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiPanel>(
                "MultiPanel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiPanel {
        static instance: ::protobuf::rt::LazyV2<MultiPanel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiPanel::new)
    }
}

impl ::protobuf::Clear for MultiPanel {
    fn clear(&mut self) {
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiPanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiPanel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CargoPanel {
    // message fields
    pub unit: ::protobuf::SingularPtrField<UnitInfo>,
    pub passengers: ::protobuf::RepeatedField<UnitInfo>,
    pub slots_available: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CargoPanel {
    fn default() -> &'a CargoPanel {
        <CargoPanel as ::protobuf::Message>::default_instance()
    }
}

impl CargoPanel {
    pub fn new() -> CargoPanel {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.UnitInfo unit = 1;


    pub fn get_unit(&self) -> &UnitInfo {
        self.unit.as_ref().unwrap_or_else(|| <UnitInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: UnitInfo) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut UnitInfo {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> UnitInfo {
        self.unit.take().unwrap_or_else(|| UnitInfo::new())
    }

    // repeated .SC2APIProtocol.UnitInfo passengers = 2;


    pub fn get_passengers(&self) -> &[UnitInfo] {
        &self.passengers
    }
    pub fn clear_passengers(&mut self) {
        self.passengers.clear();
    }

    // Param is passed by value, moved
    pub fn set_passengers(&mut self, v: ::protobuf::RepeatedField<UnitInfo>) {
        self.passengers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_passengers(&mut self) -> &mut ::protobuf::RepeatedField<UnitInfo> {
        &mut self.passengers
    }

    // Take field
    pub fn take_passengers(&mut self) -> ::protobuf::RepeatedField<UnitInfo> {
        ::std::mem::replace(&mut self.passengers, ::protobuf::RepeatedField::new())
    }

    // optional int32 slots_available = 3;


    pub fn get_slots_available(&self) -> i32 {
        self.slots_available.unwrap_or(0)
    }
    pub fn clear_slots_available(&mut self) {
        self.slots_available = ::std::option::Option::None;
    }

    pub fn has_slots_available(&self) -> bool {
        self.slots_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots_available(&mut self, v: i32) {
        self.slots_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CargoPanel {
    fn is_initialized(&self) -> bool {
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.passengers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.passengers)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slots_available = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.passengers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.slots_available {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.passengers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.slots_available {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CargoPanel {
        CargoPanel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitInfo>>(
                "unit",
                |m: &CargoPanel| { &m.unit },
                |m: &mut CargoPanel| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitInfo>>(
                "passengers",
                |m: &CargoPanel| { &m.passengers },
                |m: &mut CargoPanel| { &mut m.passengers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "slots_available",
                |m: &CargoPanel| { &m.slots_available },
                |m: &mut CargoPanel| { &mut m.slots_available },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CargoPanel>(
                "CargoPanel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CargoPanel {
        static instance: ::protobuf::rt::LazyV2<CargoPanel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CargoPanel::new)
    }
}

impl ::protobuf::Clear for CargoPanel {
    fn clear(&mut self) {
        self.unit.clear();
        self.passengers.clear();
        self.slots_available = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CargoPanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CargoPanel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildItem {
    // message fields
    pub ability_id: ::std::option::Option<u32>,
    pub build_progress: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildItem {
    fn default() -> &'a BuildItem {
        <BuildItem as ::protobuf::Message>::default_instance()
    }
}

impl BuildItem {
    pub fn new() -> BuildItem {
        ::std::default::Default::default()
    }

    // optional uint32 ability_id = 1;


    pub fn get_ability_id(&self) -> u32 {
        self.ability_id.unwrap_or(0)
    }
    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional float build_progress = 2;


    pub fn get_build_progress(&self) -> f32 {
        self.build_progress.unwrap_or(0.)
    }
    pub fn clear_build_progress(&mut self) {
        self.build_progress = ::std::option::Option::None;
    }

    pub fn has_build_progress(&self) -> bool {
        self.build_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_progress(&mut self, v: f32) {
        self.build_progress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BuildItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.build_progress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.build_progress {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.build_progress {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildItem {
        BuildItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ability_id",
                |m: &BuildItem| { &m.ability_id },
                |m: &mut BuildItem| { &mut m.ability_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "build_progress",
                |m: &BuildItem| { &m.build_progress },
                |m: &mut BuildItem| { &mut m.build_progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildItem>(
                "BuildItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildItem {
        static instance: ::protobuf::rt::LazyV2<BuildItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildItem::new)
    }
}

impl ::protobuf::Clear for BuildItem {
    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.build_progress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProductionPanel {
    // message fields
    pub unit: ::protobuf::SingularPtrField<UnitInfo>,
    pub build_queue: ::protobuf::RepeatedField<UnitInfo>,
    pub production_queue: ::protobuf::RepeatedField<BuildItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProductionPanel {
    fn default() -> &'a ProductionPanel {
        <ProductionPanel as ::protobuf::Message>::default_instance()
    }
}

impl ProductionPanel {
    pub fn new() -> ProductionPanel {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.UnitInfo unit = 1;


    pub fn get_unit(&self) -> &UnitInfo {
        self.unit.as_ref().unwrap_or_else(|| <UnitInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: UnitInfo) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut UnitInfo {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> UnitInfo {
        self.unit.take().unwrap_or_else(|| UnitInfo::new())
    }

    // repeated .SC2APIProtocol.UnitInfo build_queue = 2;


    pub fn get_build_queue(&self) -> &[UnitInfo] {
        &self.build_queue
    }
    pub fn clear_build_queue(&mut self) {
        self.build_queue.clear();
    }

    // Param is passed by value, moved
    pub fn set_build_queue(&mut self, v: ::protobuf::RepeatedField<UnitInfo>) {
        self.build_queue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_build_queue(&mut self) -> &mut ::protobuf::RepeatedField<UnitInfo> {
        &mut self.build_queue
    }

    // Take field
    pub fn take_build_queue(&mut self) -> ::protobuf::RepeatedField<UnitInfo> {
        ::std::mem::replace(&mut self.build_queue, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.BuildItem production_queue = 3;


    pub fn get_production_queue(&self) -> &[BuildItem] {
        &self.production_queue
    }
    pub fn clear_production_queue(&mut self) {
        self.production_queue.clear();
    }

    // Param is passed by value, moved
    pub fn set_production_queue(&mut self, v: ::protobuf::RepeatedField<BuildItem>) {
        self.production_queue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_production_queue(&mut self) -> &mut ::protobuf::RepeatedField<BuildItem> {
        &mut self.production_queue
    }

    // Take field
    pub fn take_production_queue(&mut self) -> ::protobuf::RepeatedField<BuildItem> {
        ::std::mem::replace(&mut self.production_queue, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProductionPanel {
    fn is_initialized(&self) -> bool {
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.build_queue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.production_queue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.build_queue)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.production_queue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.build_queue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.production_queue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.build_queue {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.production_queue {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductionPanel {
        ProductionPanel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitInfo>>(
                "unit",
                |m: &ProductionPanel| { &m.unit },
                |m: &mut ProductionPanel| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitInfo>>(
                "build_queue",
                |m: &ProductionPanel| { &m.build_queue },
                |m: &mut ProductionPanel| { &mut m.build_queue },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildItem>>(
                "production_queue",
                |m: &ProductionPanel| { &m.production_queue },
                |m: &mut ProductionPanel| { &mut m.production_queue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProductionPanel>(
                "ProductionPanel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductionPanel {
        static instance: ::protobuf::rt::LazyV2<ProductionPanel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProductionPanel::new)
    }
}

impl ::protobuf::Clear for ProductionPanel {
    fn clear(&mut self) {
        self.unit.clear();
        self.build_queue.clear();
        self.production_queue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductionPanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductionPanel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionUI {
    // message oneof groups
    pub action: ::std::option::Option<ActionUI_oneof_action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionUI {
    fn default() -> &'a ActionUI {
        <ActionUI as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ActionUI_oneof_action {
    control_group(ActionControlGroup),
    select_army(ActionSelectArmy),
    select_warp_gates(ActionSelectWarpGates),
    select_larva(ActionSelectLarva),
    select_idle_worker(ActionSelectIdleWorker),
    multi_panel(ActionMultiPanel),
    cargo_panel(ActionCargoPanelUnload),
    production_panel(ActionProductionPanelRemoveFromQueue),
    toggle_autocast(ActionToggleAutocast),
}

impl ActionUI {
    pub fn new() -> ActionUI {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionControlGroup control_group = 1;


    pub fn get_control_group(&self) -> &ActionControlGroup {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::control_group(ref v)) => v,
            _ => <ActionControlGroup as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_control_group(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_control_group(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::control_group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_control_group(&mut self, v: ActionControlGroup) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::control_group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_control_group(&mut self) -> &mut ActionControlGroup {
        if let ::std::option::Option::Some(ActionUI_oneof_action::control_group(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::control_group(ActionControlGroup::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::control_group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_control_group(&mut self) -> ActionControlGroup {
        if self.has_control_group() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::control_group(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionControlGroup::new()
        }
    }

    // optional .SC2APIProtocol.ActionSelectArmy select_army = 2;


    pub fn get_select_army(&self) -> &ActionSelectArmy {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_army(ref v)) => v,
            _ => <ActionSelectArmy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_select_army(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_select_army(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_army(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_army(&mut self, v: ActionSelectArmy) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_army(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_army(&mut self) -> &mut ActionSelectArmy {
        if let ::std::option::Option::Some(ActionUI_oneof_action::select_army(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_army(ActionSelectArmy::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_army(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_army(&mut self) -> ActionSelectArmy {
        if self.has_select_army() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::select_army(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSelectArmy::new()
        }
    }

    // optional .SC2APIProtocol.ActionSelectWarpGates select_warp_gates = 3;


    pub fn get_select_warp_gates(&self) -> &ActionSelectWarpGates {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_warp_gates(ref v)) => v,
            _ => <ActionSelectWarpGates as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_select_warp_gates(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_select_warp_gates(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_warp_gates(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_warp_gates(&mut self, v: ActionSelectWarpGates) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_warp_gates(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_warp_gates(&mut self) -> &mut ActionSelectWarpGates {
        if let ::std::option::Option::Some(ActionUI_oneof_action::select_warp_gates(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_warp_gates(ActionSelectWarpGates::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_warp_gates(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_warp_gates(&mut self) -> ActionSelectWarpGates {
        if self.has_select_warp_gates() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::select_warp_gates(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSelectWarpGates::new()
        }
    }

    // optional .SC2APIProtocol.ActionSelectLarva select_larva = 4;


    pub fn get_select_larva(&self) -> &ActionSelectLarva {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_larva(ref v)) => v,
            _ => <ActionSelectLarva as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_select_larva(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_select_larva(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_larva(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_larva(&mut self, v: ActionSelectLarva) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_larva(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_larva(&mut self) -> &mut ActionSelectLarva {
        if let ::std::option::Option::Some(ActionUI_oneof_action::select_larva(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_larva(ActionSelectLarva::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_larva(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_larva(&mut self) -> ActionSelectLarva {
        if self.has_select_larva() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::select_larva(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSelectLarva::new()
        }
    }

    // optional .SC2APIProtocol.ActionSelectIdleWorker select_idle_worker = 5;


    pub fn get_select_idle_worker(&self) -> &ActionSelectIdleWorker {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_idle_worker(ref v)) => v,
            _ => <ActionSelectIdleWorker as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_select_idle_worker(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_select_idle_worker(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_idle_worker(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_idle_worker(&mut self, v: ActionSelectIdleWorker) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_idle_worker(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_idle_worker(&mut self) -> &mut ActionSelectIdleWorker {
        if let ::std::option::Option::Some(ActionUI_oneof_action::select_idle_worker(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_idle_worker(ActionSelectIdleWorker::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::select_idle_worker(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_idle_worker(&mut self) -> ActionSelectIdleWorker {
        if self.has_select_idle_worker() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::select_idle_worker(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSelectIdleWorker::new()
        }
    }

    // optional .SC2APIProtocol.ActionMultiPanel multi_panel = 6;


    pub fn get_multi_panel(&self) -> &ActionMultiPanel {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::multi_panel(ref v)) => v,
            _ => <ActionMultiPanel as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_multi_panel(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_multi_panel(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::multi_panel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_panel(&mut self, v: ActionMultiPanel) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::multi_panel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_panel(&mut self) -> &mut ActionMultiPanel {
        if let ::std::option::Option::Some(ActionUI_oneof_action::multi_panel(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::multi_panel(ActionMultiPanel::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::multi_panel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_panel(&mut self) -> ActionMultiPanel {
        if self.has_multi_panel() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::multi_panel(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMultiPanel::new()
        }
    }

    // optional .SC2APIProtocol.ActionCargoPanelUnload cargo_panel = 7;


    pub fn get_cargo_panel(&self) -> &ActionCargoPanelUnload {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::cargo_panel(ref v)) => v,
            _ => <ActionCargoPanelUnload as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cargo_panel(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_cargo_panel(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::cargo_panel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cargo_panel(&mut self, v: ActionCargoPanelUnload) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::cargo_panel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cargo_panel(&mut self) -> &mut ActionCargoPanelUnload {
        if let ::std::option::Option::Some(ActionUI_oneof_action::cargo_panel(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::cargo_panel(ActionCargoPanelUnload::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::cargo_panel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cargo_panel(&mut self) -> ActionCargoPanelUnload {
        if self.has_cargo_panel() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::cargo_panel(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionCargoPanelUnload::new()
        }
    }

    // optional .SC2APIProtocol.ActionProductionPanelRemoveFromQueue production_panel = 8;


    pub fn get_production_panel(&self) -> &ActionProductionPanelRemoveFromQueue {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::production_panel(ref v)) => v,
            _ => <ActionProductionPanelRemoveFromQueue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_production_panel(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_production_panel(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::production_panel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_production_panel(&mut self, v: ActionProductionPanelRemoveFromQueue) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::production_panel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_production_panel(&mut self) -> &mut ActionProductionPanelRemoveFromQueue {
        if let ::std::option::Option::Some(ActionUI_oneof_action::production_panel(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::production_panel(ActionProductionPanelRemoveFromQueue::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::production_panel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_production_panel(&mut self) -> ActionProductionPanelRemoveFromQueue {
        if self.has_production_panel() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::production_panel(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionProductionPanelRemoveFromQueue::new()
        }
    }

    // optional .SC2APIProtocol.ActionToggleAutocast toggle_autocast = 9;


    pub fn get_toggle_autocast(&self) -> &ActionToggleAutocast {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::toggle_autocast(ref v)) => v,
            _ => <ActionToggleAutocast as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_toggle_autocast(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_toggle_autocast(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::toggle_autocast(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_toggle_autocast(&mut self, v: ActionToggleAutocast) {
        self.action = ::std::option::Option::Some(ActionUI_oneof_action::toggle_autocast(v))
    }

    // Mutable pointer to the field.
    pub fn mut_toggle_autocast(&mut self) -> &mut ActionToggleAutocast {
        if let ::std::option::Option::Some(ActionUI_oneof_action::toggle_autocast(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionUI_oneof_action::toggle_autocast(ActionToggleAutocast::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionUI_oneof_action::toggle_autocast(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_toggle_autocast(&mut self) -> ActionToggleAutocast {
        if self.has_toggle_autocast() {
            match self.action.take() {
                ::std::option::Option::Some(ActionUI_oneof_action::toggle_autocast(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionToggleAutocast::new()
        }
    }
}

impl ::protobuf::Message for ActionUI {
    fn is_initialized(&self) -> bool {
        if let Some(ActionUI_oneof_action::control_group(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionUI_oneof_action::select_army(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionUI_oneof_action::select_warp_gates(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionUI_oneof_action::select_larva(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionUI_oneof_action::select_idle_worker(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionUI_oneof_action::multi_panel(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionUI_oneof_action::cargo_panel(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionUI_oneof_action::production_panel(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionUI_oneof_action::toggle_autocast(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::control_group(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_army(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_warp_gates(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_larva(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::select_idle_worker(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::multi_panel(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::cargo_panel(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::production_panel(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionUI_oneof_action::toggle_autocast(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &ActionUI_oneof_action::control_group(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionUI_oneof_action::select_army(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionUI_oneof_action::select_warp_gates(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionUI_oneof_action::select_larva(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionUI_oneof_action::select_idle_worker(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionUI_oneof_action::multi_panel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionUI_oneof_action::cargo_panel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionUI_oneof_action::production_panel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionUI_oneof_action::toggle_autocast(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &ActionUI_oneof_action::control_group(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionUI_oneof_action::select_army(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionUI_oneof_action::select_warp_gates(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionUI_oneof_action::select_larva(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionUI_oneof_action::select_idle_worker(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionUI_oneof_action::multi_panel(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionUI_oneof_action::cargo_panel(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionUI_oneof_action::production_panel(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionUI_oneof_action::toggle_autocast(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionUI {
        ActionUI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionControlGroup>(
                "control_group",
                ActionUI::has_control_group,
                ActionUI::get_control_group,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionSelectArmy>(
                "select_army",
                ActionUI::has_select_army,
                ActionUI::get_select_army,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionSelectWarpGates>(
                "select_warp_gates",
                ActionUI::has_select_warp_gates,
                ActionUI::get_select_warp_gates,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionSelectLarva>(
                "select_larva",
                ActionUI::has_select_larva,
                ActionUI::get_select_larva,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionSelectIdleWorker>(
                "select_idle_worker",
                ActionUI::has_select_idle_worker,
                ActionUI::get_select_idle_worker,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionMultiPanel>(
                "multi_panel",
                ActionUI::has_multi_panel,
                ActionUI::get_multi_panel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionCargoPanelUnload>(
                "cargo_panel",
                ActionUI::has_cargo_panel,
                ActionUI::get_cargo_panel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionProductionPanelRemoveFromQueue>(
                "production_panel",
                ActionUI::has_production_panel,
                ActionUI::get_production_panel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionToggleAutocast>(
                "toggle_autocast",
                ActionUI::has_toggle_autocast,
                ActionUI::get_toggle_autocast,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionUI>(
                "ActionUI",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionUI {
        static instance: ::protobuf::rt::LazyV2<ActionUI> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionUI::new)
    }
}

impl ::protobuf::Clear for ActionUI {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionUI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionUI {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionControlGroup {
    // message fields
    pub action: ::std::option::Option<ActionControlGroup_ControlGroupAction>,
    pub control_group_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionControlGroup {
    fn default() -> &'a ActionControlGroup {
        <ActionControlGroup as ::protobuf::Message>::default_instance()
    }
}

impl ActionControlGroup {
    pub fn new() -> ActionControlGroup {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionControlGroup.ControlGroupAction action = 1;


    pub fn get_action(&self) -> ActionControlGroup_ControlGroupAction {
        self.action.unwrap_or(ActionControlGroup_ControlGroupAction::Recall)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ActionControlGroup_ControlGroupAction) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional uint32 control_group_index = 2;


    pub fn get_control_group_index(&self) -> u32 {
        self.control_group_index.unwrap_or(0)
    }
    pub fn clear_control_group_index(&mut self) {
        self.control_group_index = ::std::option::Option::None;
    }

    pub fn has_control_group_index(&self) -> bool {
        self.control_group_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_group_index(&mut self, v: u32) {
        self.control_group_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionControlGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.control_group_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.control_group_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.control_group_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionControlGroup {
        ActionControlGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionControlGroup_ControlGroupAction>>(
                "action",
                |m: &ActionControlGroup| { &m.action },
                |m: &mut ActionControlGroup| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "control_group_index",
                |m: &ActionControlGroup| { &m.control_group_index },
                |m: &mut ActionControlGroup| { &mut m.control_group_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionControlGroup>(
                "ActionControlGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionControlGroup {
        static instance: ::protobuf::rt::LazyV2<ActionControlGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionControlGroup::new)
    }
}

impl ::protobuf::Clear for ActionControlGroup {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.control_group_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionControlGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionControlGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionControlGroup_ControlGroupAction {
    Recall = 1,
    Set = 2,
    Append = 3,
    SetAndSteal = 4,
    AppendAndSteal = 5,
}

impl ::protobuf::ProtobufEnum for ActionControlGroup_ControlGroupAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionControlGroup_ControlGroupAction> {
        match value {
            1 => ::std::option::Option::Some(ActionControlGroup_ControlGroupAction::Recall),
            2 => ::std::option::Option::Some(ActionControlGroup_ControlGroupAction::Set),
            3 => ::std::option::Option::Some(ActionControlGroup_ControlGroupAction::Append),
            4 => ::std::option::Option::Some(ActionControlGroup_ControlGroupAction::SetAndSteal),
            5 => ::std::option::Option::Some(ActionControlGroup_ControlGroupAction::AppendAndSteal),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionControlGroup_ControlGroupAction] = &[
            ActionControlGroup_ControlGroupAction::Recall,
            ActionControlGroup_ControlGroupAction::Set,
            ActionControlGroup_ControlGroupAction::Append,
            ActionControlGroup_ControlGroupAction::SetAndSteal,
            ActionControlGroup_ControlGroupAction::AppendAndSteal,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ActionControlGroup_ControlGroupAction>("ActionControlGroup.ControlGroupAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ActionControlGroup_ControlGroupAction {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ActionControlGroup_ControlGroupAction {
    fn default() -> Self {
        ActionControlGroup_ControlGroupAction::Recall
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionControlGroup_ControlGroupAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSelectArmy {
    // message fields
    pub selection_add: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSelectArmy {
    fn default() -> &'a ActionSelectArmy {
        <ActionSelectArmy as ::protobuf::Message>::default_instance()
    }
}

impl ActionSelectArmy {
    pub fn new() -> ActionSelectArmy {
        ::std::default::Default::default()
    }

    // optional bool selection_add = 1;


    pub fn get_selection_add(&self) -> bool {
        self.selection_add.unwrap_or(false)
    }
    pub fn clear_selection_add(&mut self) {
        self.selection_add = ::std::option::Option::None;
    }

    pub fn has_selection_add(&self) -> bool {
        self.selection_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_add(&mut self, v: bool) {
        self.selection_add = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionSelectArmy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selection_add = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selection_add {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selection_add {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSelectArmy {
        ActionSelectArmy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "selection_add",
                |m: &ActionSelectArmy| { &m.selection_add },
                |m: &mut ActionSelectArmy| { &mut m.selection_add },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSelectArmy>(
                "ActionSelectArmy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSelectArmy {
        static instance: ::protobuf::rt::LazyV2<ActionSelectArmy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSelectArmy::new)
    }
}

impl ::protobuf::Clear for ActionSelectArmy {
    fn clear(&mut self) {
        self.selection_add = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSelectArmy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectArmy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSelectWarpGates {
    // message fields
    pub selection_add: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSelectWarpGates {
    fn default() -> &'a ActionSelectWarpGates {
        <ActionSelectWarpGates as ::protobuf::Message>::default_instance()
    }
}

impl ActionSelectWarpGates {
    pub fn new() -> ActionSelectWarpGates {
        ::std::default::Default::default()
    }

    // optional bool selection_add = 1;


    pub fn get_selection_add(&self) -> bool {
        self.selection_add.unwrap_or(false)
    }
    pub fn clear_selection_add(&mut self) {
        self.selection_add = ::std::option::Option::None;
    }

    pub fn has_selection_add(&self) -> bool {
        self.selection_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_add(&mut self, v: bool) {
        self.selection_add = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionSelectWarpGates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selection_add = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selection_add {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selection_add {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSelectWarpGates {
        ActionSelectWarpGates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "selection_add",
                |m: &ActionSelectWarpGates| { &m.selection_add },
                |m: &mut ActionSelectWarpGates| { &mut m.selection_add },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSelectWarpGates>(
                "ActionSelectWarpGates",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSelectWarpGates {
        static instance: ::protobuf::rt::LazyV2<ActionSelectWarpGates> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSelectWarpGates::new)
    }
}

impl ::protobuf::Clear for ActionSelectWarpGates {
    fn clear(&mut self) {
        self.selection_add = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSelectWarpGates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectWarpGates {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSelectLarva {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSelectLarva {
    fn default() -> &'a ActionSelectLarva {
        <ActionSelectLarva as ::protobuf::Message>::default_instance()
    }
}

impl ActionSelectLarva {
    pub fn new() -> ActionSelectLarva {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ActionSelectLarva {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSelectLarva {
        ActionSelectLarva::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSelectLarva>(
                "ActionSelectLarva",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSelectLarva {
        static instance: ::protobuf::rt::LazyV2<ActionSelectLarva> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSelectLarva::new)
    }
}

impl ::protobuf::Clear for ActionSelectLarva {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSelectLarva {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectLarva {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSelectIdleWorker {
    // message fields
    pub field_type: ::std::option::Option<ActionSelectIdleWorker_Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSelectIdleWorker {
    fn default() -> &'a ActionSelectIdleWorker {
        <ActionSelectIdleWorker as ::protobuf::Message>::default_instance()
    }
}

impl ActionSelectIdleWorker {
    pub fn new() -> ActionSelectIdleWorker {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionSelectIdleWorker.Type type = 1;


    pub fn get_field_type(&self) -> ActionSelectIdleWorker_Type {
        self.field_type.unwrap_or(ActionSelectIdleWorker_Type::Set)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ActionSelectIdleWorker_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionSelectIdleWorker {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSelectIdleWorker {
        ActionSelectIdleWorker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionSelectIdleWorker_Type>>(
                "type",
                |m: &ActionSelectIdleWorker| { &m.field_type },
                |m: &mut ActionSelectIdleWorker| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSelectIdleWorker>(
                "ActionSelectIdleWorker",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSelectIdleWorker {
        static instance: ::protobuf::rt::LazyV2<ActionSelectIdleWorker> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSelectIdleWorker::new)
    }
}

impl ::protobuf::Clear for ActionSelectIdleWorker {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSelectIdleWorker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectIdleWorker {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionSelectIdleWorker_Type {
    Set = 1,
    Add = 2,
    All = 3,
    AddAll = 4,
}

impl ::protobuf::ProtobufEnum for ActionSelectIdleWorker_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionSelectIdleWorker_Type> {
        match value {
            1 => ::std::option::Option::Some(ActionSelectIdleWorker_Type::Set),
            2 => ::std::option::Option::Some(ActionSelectIdleWorker_Type::Add),
            3 => ::std::option::Option::Some(ActionSelectIdleWorker_Type::All),
            4 => ::std::option::Option::Some(ActionSelectIdleWorker_Type::AddAll),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionSelectIdleWorker_Type] = &[
            ActionSelectIdleWorker_Type::Set,
            ActionSelectIdleWorker_Type::Add,
            ActionSelectIdleWorker_Type::All,
            ActionSelectIdleWorker_Type::AddAll,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ActionSelectIdleWorker_Type>("ActionSelectIdleWorker.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ActionSelectIdleWorker_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ActionSelectIdleWorker_Type {
    fn default() -> Self {
        ActionSelectIdleWorker_Type::Set
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectIdleWorker_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionMultiPanel {
    // message fields
    pub field_type: ::std::option::Option<ActionMultiPanel_Type>,
    pub unit_index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionMultiPanel {
    fn default() -> &'a ActionMultiPanel {
        <ActionMultiPanel as ::protobuf::Message>::default_instance()
    }
}

impl ActionMultiPanel {
    pub fn new() -> ActionMultiPanel {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionMultiPanel.Type type = 1;


    pub fn get_field_type(&self) -> ActionMultiPanel_Type {
        self.field_type.unwrap_or(ActionMultiPanel_Type::SingleSelect)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ActionMultiPanel_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional int32 unit_index = 2;


    pub fn get_unit_index(&self) -> i32 {
        self.unit_index.unwrap_or(0)
    }
    pub fn clear_unit_index(&mut self) {
        self.unit_index = ::std::option::Option::None;
    }

    pub fn has_unit_index(&self) -> bool {
        self.unit_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_index(&mut self, v: i32) {
        self.unit_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionMultiPanel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unit_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.unit_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.unit_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionMultiPanel {
        ActionMultiPanel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionMultiPanel_Type>>(
                "type",
                |m: &ActionMultiPanel| { &m.field_type },
                |m: &mut ActionMultiPanel| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unit_index",
                |m: &ActionMultiPanel| { &m.unit_index },
                |m: &mut ActionMultiPanel| { &mut m.unit_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionMultiPanel>(
                "ActionMultiPanel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionMultiPanel {
        static instance: ::protobuf::rt::LazyV2<ActionMultiPanel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionMultiPanel::new)
    }
}

impl ::protobuf::Clear for ActionMultiPanel {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unit_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionMultiPanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMultiPanel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionMultiPanel_Type {
    SingleSelect = 1,
    DeselectUnit = 2,
    SelectAllOfType = 3,
    DeselectAllOfType = 4,
}

impl ::protobuf::ProtobufEnum for ActionMultiPanel_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionMultiPanel_Type> {
        match value {
            1 => ::std::option::Option::Some(ActionMultiPanel_Type::SingleSelect),
            2 => ::std::option::Option::Some(ActionMultiPanel_Type::DeselectUnit),
            3 => ::std::option::Option::Some(ActionMultiPanel_Type::SelectAllOfType),
            4 => ::std::option::Option::Some(ActionMultiPanel_Type::DeselectAllOfType),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionMultiPanel_Type] = &[
            ActionMultiPanel_Type::SingleSelect,
            ActionMultiPanel_Type::DeselectUnit,
            ActionMultiPanel_Type::SelectAllOfType,
            ActionMultiPanel_Type::DeselectAllOfType,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ActionMultiPanel_Type>("ActionMultiPanel.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ActionMultiPanel_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ActionMultiPanel_Type {
    fn default() -> Self {
        ActionMultiPanel_Type::SingleSelect
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMultiPanel_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionCargoPanelUnload {
    // message fields
    pub unit_index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionCargoPanelUnload {
    fn default() -> &'a ActionCargoPanelUnload {
        <ActionCargoPanelUnload as ::protobuf::Message>::default_instance()
    }
}

impl ActionCargoPanelUnload {
    pub fn new() -> ActionCargoPanelUnload {
        ::std::default::Default::default()
    }

    // optional int32 unit_index = 1;


    pub fn get_unit_index(&self) -> i32 {
        self.unit_index.unwrap_or(0)
    }
    pub fn clear_unit_index(&mut self) {
        self.unit_index = ::std::option::Option::None;
    }

    pub fn has_unit_index(&self) -> bool {
        self.unit_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_index(&mut self, v: i32) {
        self.unit_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionCargoPanelUnload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unit_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionCargoPanelUnload {
        ActionCargoPanelUnload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unit_index",
                |m: &ActionCargoPanelUnload| { &m.unit_index },
                |m: &mut ActionCargoPanelUnload| { &mut m.unit_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionCargoPanelUnload>(
                "ActionCargoPanelUnload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionCargoPanelUnload {
        static instance: ::protobuf::rt::LazyV2<ActionCargoPanelUnload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionCargoPanelUnload::new)
    }
}

impl ::protobuf::Clear for ActionCargoPanelUnload {
    fn clear(&mut self) {
        self.unit_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionCargoPanelUnload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionCargoPanelUnload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionProductionPanelRemoveFromQueue {
    // message fields
    pub unit_index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionProductionPanelRemoveFromQueue {
    fn default() -> &'a ActionProductionPanelRemoveFromQueue {
        <ActionProductionPanelRemoveFromQueue as ::protobuf::Message>::default_instance()
    }
}

impl ActionProductionPanelRemoveFromQueue {
    pub fn new() -> ActionProductionPanelRemoveFromQueue {
        ::std::default::Default::default()
    }

    // optional int32 unit_index = 1;


    pub fn get_unit_index(&self) -> i32 {
        self.unit_index.unwrap_or(0)
    }
    pub fn clear_unit_index(&mut self) {
        self.unit_index = ::std::option::Option::None;
    }

    pub fn has_unit_index(&self) -> bool {
        self.unit_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_index(&mut self, v: i32) {
        self.unit_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionProductionPanelRemoveFromQueue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unit_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionProductionPanelRemoveFromQueue {
        ActionProductionPanelRemoveFromQueue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unit_index",
                |m: &ActionProductionPanelRemoveFromQueue| { &m.unit_index },
                |m: &mut ActionProductionPanelRemoveFromQueue| { &mut m.unit_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionProductionPanelRemoveFromQueue>(
                "ActionProductionPanelRemoveFromQueue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionProductionPanelRemoveFromQueue {
        static instance: ::protobuf::rt::LazyV2<ActionProductionPanelRemoveFromQueue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionProductionPanelRemoveFromQueue::new)
    }
}

impl ::protobuf::Clear for ActionProductionPanelRemoveFromQueue {
    fn clear(&mut self) {
        self.unit_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionProductionPanelRemoveFromQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionProductionPanelRemoveFromQueue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionToggleAutocast {
    // message fields
    pub ability_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionToggleAutocast {
    fn default() -> &'a ActionToggleAutocast {
        <ActionToggleAutocast as ::protobuf::Message>::default_instance()
    }
}

impl ActionToggleAutocast {
    pub fn new() -> ActionToggleAutocast {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;


    pub fn get_ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }
    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionToggleAutocast {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionToggleAutocast {
        ActionToggleAutocast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ability_id",
                |m: &ActionToggleAutocast| { &m.ability_id },
                |m: &mut ActionToggleAutocast| { &mut m.ability_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionToggleAutocast>(
                "ActionToggleAutocast",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionToggleAutocast {
        static instance: ::protobuf::rt::LazyV2<ActionToggleAutocast> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionToggleAutocast::new)
    }
}

impl ::protobuf::Clear for ActionToggleAutocast {
    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionToggleAutocast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionToggleAutocast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19s2clientprotocol/ui.proto\x12\x0eSC2APIProtocol\"\xb0\x02\n\rObser\
    vationUI\x124\n\x06groups\x18\x01\x20\x03(\x0b2\x1c.SC2APIProtocol.Contr\
    olGroupR\x06groups\x125\n\x06single\x18\x02\x20\x01(\x0b2\x1b.SC2APIProt\
    ocol.SinglePanelH\0R\x06single\x122\n\x05multi\x18\x03\x20\x01(\x0b2\x1a\
    .SC2APIProtocol.MultiPanelH\0R\x05multi\x122\n\x05cargo\x18\x04\x20\x01(\
    \x0b2\x1a.SC2APIProtocol.CargoPanelH\0R\x05cargo\x12A\n\nproduction\x18\
    \x05\x20\x01(\x0b2\x1f.SC2APIProtocol.ProductionPanelH\0R\nproductionB\
    \x07\n\x05panel\"~\n\x0cControlGroup\x12.\n\x13control_group_index\x18\
    \x01\x20\x01(\rR\x11controlGroupIndex\x12(\n\x10leader_unit_type\x18\x02\
    \x20\x01(\rR\x0eleaderUnitType\x12\x14\n\x05count\x18\x03\x20\x01(\rR\
    \x05count\"\x85\x03\n\x08UnitInfo\x12\x1b\n\tunit_type\x18\x01\x20\x01(\
    \rR\x08unitType\x12'\n\x0fplayer_relative\x18\x02\x20\x01(\rR\x0eplayerR\
    elative\x12\x16\n\x06health\x18\x03\x20\x01(\x05R\x06health\x12\x18\n\
    \x07shields\x18\x04\x20\x01(\x05R\x07shields\x12\x16\n\x06energy\x18\x05\
    \x20\x01(\x05R\x06energy\x122\n\x15transport_slots_taken\x18\x06\x20\x01\
    (\x05R\x13transportSlotsTaken\x12%\n\x0ebuild_progress\x18\x07\x20\x01(\
    \x02R\rbuildProgress\x12/\n\x06add_on\x18\x08\x20\x01(\x0b2\x18.SC2APIPr\
    otocol.UnitInfoR\x05addOn\x12\x1d\n\nmax_health\x18\t\x20\x01(\x05R\tmax\
    Health\x12\x1f\n\x0bmax_shields\x18\n\x20\x01(\x05R\nmaxShields\x12\x1d\
    \n\nmax_energy\x18\x0b\x20\x01(\x05R\tmaxEnergy\"\xe5\x01\n\x0bSinglePan\
    el\x12,\n\x04unit\x18\x01\x20\x01(\x0b2\x18.SC2APIProtocol.UnitInfoR\x04\
    unit\x120\n\x14attack_upgrade_level\x18\x02\x20\x01(\x05R\x12attackUpgra\
    deLevel\x12.\n\x13armor_upgrade_level\x18\x03\x20\x01(\x05R\x11armorUpgr\
    adeLevel\x120\n\x14shield_upgrade_level\x18\x04\x20\x01(\x05R\x12shieldU\
    pgradeLevel\x12\x14\n\x05buffs\x18\x05\x20\x03(\x05R\x05buffs\"<\n\nMult\
    iPanel\x12.\n\x05units\x18\x01\x20\x03(\x0b2\x18.SC2APIProtocol.UnitInfo\
    R\x05units\"\x9d\x01\n\nCargoPanel\x12,\n\x04unit\x18\x01\x20\x01(\x0b2\
    \x18.SC2APIProtocol.UnitInfoR\x04unit\x128\n\npassengers\x18\x02\x20\x03\
    (\x0b2\x18.SC2APIProtocol.UnitInfoR\npassengers\x12'\n\x0fslots_availabl\
    e\x18\x03\x20\x01(\x05R\x0eslotsAvailable\"Q\n\tBuildItem\x12\x1d\n\nabi\
    lity_id\x18\x01\x20\x01(\rR\tabilityId\x12%\n\x0ebuild_progress\x18\x02\
    \x20\x01(\x02R\rbuildProgress\"\xc0\x01\n\x0fProductionPanel\x12,\n\x04u\
    nit\x18\x01\x20\x01(\x0b2\x18.SC2APIProtocol.UnitInfoR\x04unit\x129\n\
    \x0bbuild_queue\x18\x02\x20\x03(\x0b2\x18.SC2APIProtocol.UnitInfoR\nbuil\
    dQueue\x12D\n\x10production_queue\x18\x03\x20\x03(\x0b2\x19.SC2APIProtoc\
    ol.BuildItemR\x0fproductionQueue\"\xdd\x05\n\x08ActionUI\x12I\n\rcontrol\
    _group\x18\x01\x20\x01(\x0b2\".SC2APIProtocol.ActionControlGroupH\0R\x0c\
    controlGroup\x12C\n\x0bselect_army\x18\x02\x20\x01(\x0b2\x20.SC2APIProto\
    col.ActionSelectArmyH\0R\nselectArmy\x12S\n\x11select_warp_gates\x18\x03\
    \x20\x01(\x0b2%.SC2APIProtocol.ActionSelectWarpGatesH\0R\x0fselectWarpGa\
    tes\x12F\n\x0cselect_larva\x18\x04\x20\x01(\x0b2!.SC2APIProtocol.ActionS\
    electLarvaH\0R\x0bselectLarva\x12V\n\x12select_idle_worker\x18\x05\x20\
    \x01(\x0b2&.SC2APIProtocol.ActionSelectIdleWorkerH\0R\x10selectIdleWorke\
    r\x12C\n\x0bmulti_panel\x18\x06\x20\x01(\x0b2\x20.SC2APIProtocol.ActionM\
    ultiPanelH\0R\nmultiPanel\x12I\n\x0bcargo_panel\x18\x07\x20\x01(\x0b2&.S\
    C2APIProtocol.ActionCargoPanelUnloadH\0R\ncargoPanel\x12a\n\x10productio\
    n_panel\x18\x08\x20\x01(\x0b24.SC2APIProtocol.ActionProductionPanelRemov\
    eFromQueueH\0R\x0fproductionPanel\x12O\n\x0ftoggle_autocast\x18\t\x20\
    \x01(\x0b2$.SC2APIProtocol.ActionToggleAutocastH\0R\x0etoggleAutocastB\
    \x08\n\x06action\"\xef\x01\n\x12ActionControlGroup\x12M\n\x06action\x18\
    \x01\x20\x01(\x0e25.SC2APIProtocol.ActionControlGroup.ControlGroupAction\
    R\x06action\x12.\n\x13control_group_index\x18\x02\x20\x01(\rR\x11control\
    GroupIndex\"Z\n\x12ControlGroupAction\x12\n\n\x06Recall\x10\x01\x12\x07\
    \n\x03Set\x10\x02\x12\n\n\x06Append\x10\x03\x12\x0f\n\x0bSetAndSteal\x10\
    \x04\x12\x12\n\x0eAppendAndSteal\x10\x05\"7\n\x10ActionSelectArmy\x12#\n\
    \rselection_add\x18\x01\x20\x01(\x08R\x0cselectionAdd\"<\n\x15ActionSele\
    ctWarpGates\x12#\n\rselection_add\x18\x01\x20\x01(\x08R\x0cselectionAdd\
    \"\x13\n\x11ActionSelectLarva\"\x88\x01\n\x16ActionSelectIdleWorker\x12?\
    \n\x04type\x18\x01\x20\x01(\x0e2+.SC2APIProtocol.ActionSelectIdleWorker.\
    TypeR\x04type\"-\n\x04Type\x12\x07\n\x03Set\x10\x01\x12\x07\n\x03Add\x10\
    \x02\x12\x07\n\x03All\x10\x03\x12\n\n\x06AddAll\x10\x04\"\xc4\x01\n\x10A\
    ctionMultiPanel\x129\n\x04type\x18\x01\x20\x01(\x0e2%.SC2APIProtocol.Act\
    ionMultiPanel.TypeR\x04type\x12\x1d\n\nunit_index\x18\x02\x20\x01(\x05R\
    \tunitIndex\"V\n\x04Type\x12\x10\n\x0cSingleSelect\x10\x01\x12\x10\n\x0c\
    DeselectUnit\x10\x02\x12\x13\n\x0fSelectAllOfType\x10\x03\x12\x15\n\x11D\
    eselectAllOfType\x10\x04\"7\n\x16ActionCargoPanelUnload\x12\x1d\n\nunit_\
    index\x18\x01\x20\x01(\x05R\tunitIndex\"E\n$ActionProductionPanelRemoveF\
    romQueue\x12\x1d\n\nunit_index\x18\x01\x20\x01(\x05R\tunitIndex\"5\n\x14\
    ActionToggleAutocast\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabilit\
    yId\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
