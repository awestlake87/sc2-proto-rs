// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `s2clientprotocol/debug.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct DebugCommand {
    // message oneof groups
    pub command: ::std::option::Option<DebugCommand_oneof_command>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugCommand {
    fn default() -> &'a DebugCommand {
        <DebugCommand as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DebugCommand_oneof_command {
    draw(DebugDraw),
    game_state(DebugGameState),
    create_unit(DebugCreateUnit),
    kill_unit(DebugKillUnit),
    test_process(DebugTestProcess),
    score(DebugSetScore),
    end_game(DebugEndGame),
    unit_value(DebugSetUnitValue),
}

impl DebugCommand {
    pub fn new() -> DebugCommand {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DebugDraw draw = 1;


    pub fn get_draw(&self) -> &DebugDraw {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::draw(ref v)) => v,
            _ => <DebugDraw as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_draw(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_draw(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::draw(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_draw(&mut self, v: DebugDraw) {
        self.command = ::std::option::Option::Some(DebugCommand_oneof_command::draw(v))
    }

    // Mutable pointer to the field.
    pub fn mut_draw(&mut self) -> &mut DebugDraw {
        if let ::std::option::Option::Some(DebugCommand_oneof_command::draw(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(DebugCommand_oneof_command::draw(DebugDraw::new()));
        }
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::draw(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_draw(&mut self) -> DebugDraw {
        if self.has_draw() {
            match self.command.take() {
                ::std::option::Option::Some(DebugCommand_oneof_command::draw(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugDraw::new()
        }
    }

    // optional .SC2APIProtocol.DebugGameState game_state = 2;


    pub fn get_game_state(&self) -> DebugGameState {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::game_state(v)) => v,
            _ => DebugGameState::show_map,
        }
    }
    pub fn clear_game_state(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::game_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: DebugGameState) {
        self.command = ::std::option::Option::Some(DebugCommand_oneof_command::game_state(v))
    }

    // optional .SC2APIProtocol.DebugCreateUnit create_unit = 3;


    pub fn get_create_unit(&self) -> &DebugCreateUnit {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::create_unit(ref v)) => v,
            _ => <DebugCreateUnit as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_create_unit(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_create_unit(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::create_unit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_unit(&mut self, v: DebugCreateUnit) {
        self.command = ::std::option::Option::Some(DebugCommand_oneof_command::create_unit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_unit(&mut self) -> &mut DebugCreateUnit {
        if let ::std::option::Option::Some(DebugCommand_oneof_command::create_unit(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(DebugCommand_oneof_command::create_unit(DebugCreateUnit::new()));
        }
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::create_unit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_unit(&mut self) -> DebugCreateUnit {
        if self.has_create_unit() {
            match self.command.take() {
                ::std::option::Option::Some(DebugCommand_oneof_command::create_unit(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugCreateUnit::new()
        }
    }

    // optional .SC2APIProtocol.DebugKillUnit kill_unit = 4;


    pub fn get_kill_unit(&self) -> &DebugKillUnit {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::kill_unit(ref v)) => v,
            _ => <DebugKillUnit as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_kill_unit(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_kill_unit(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::kill_unit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kill_unit(&mut self, v: DebugKillUnit) {
        self.command = ::std::option::Option::Some(DebugCommand_oneof_command::kill_unit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kill_unit(&mut self) -> &mut DebugKillUnit {
        if let ::std::option::Option::Some(DebugCommand_oneof_command::kill_unit(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(DebugCommand_oneof_command::kill_unit(DebugKillUnit::new()));
        }
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::kill_unit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kill_unit(&mut self) -> DebugKillUnit {
        if self.has_kill_unit() {
            match self.command.take() {
                ::std::option::Option::Some(DebugCommand_oneof_command::kill_unit(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugKillUnit::new()
        }
    }

    // optional .SC2APIProtocol.DebugTestProcess test_process = 5;


    pub fn get_test_process(&self) -> &DebugTestProcess {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::test_process(ref v)) => v,
            _ => <DebugTestProcess as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_test_process(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_test_process(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::test_process(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_test_process(&mut self, v: DebugTestProcess) {
        self.command = ::std::option::Option::Some(DebugCommand_oneof_command::test_process(v))
    }

    // Mutable pointer to the field.
    pub fn mut_test_process(&mut self) -> &mut DebugTestProcess {
        if let ::std::option::Option::Some(DebugCommand_oneof_command::test_process(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(DebugCommand_oneof_command::test_process(DebugTestProcess::new()));
        }
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::test_process(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_test_process(&mut self) -> DebugTestProcess {
        if self.has_test_process() {
            match self.command.take() {
                ::std::option::Option::Some(DebugCommand_oneof_command::test_process(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugTestProcess::new()
        }
    }

    // optional .SC2APIProtocol.DebugSetScore score = 6;


    pub fn get_score(&self) -> &DebugSetScore {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::score(ref v)) => v,
            _ => <DebugSetScore as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_score(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::score(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: DebugSetScore) {
        self.command = ::std::option::Option::Some(DebugCommand_oneof_command::score(v))
    }

    // Mutable pointer to the field.
    pub fn mut_score(&mut self) -> &mut DebugSetScore {
        if let ::std::option::Option::Some(DebugCommand_oneof_command::score(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(DebugCommand_oneof_command::score(DebugSetScore::new()));
        }
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::score(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_score(&mut self) -> DebugSetScore {
        if self.has_score() {
            match self.command.take() {
                ::std::option::Option::Some(DebugCommand_oneof_command::score(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugSetScore::new()
        }
    }

    // optional .SC2APIProtocol.DebugEndGame end_game = 7;


    pub fn get_end_game(&self) -> &DebugEndGame {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::end_game(ref v)) => v,
            _ => <DebugEndGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_end_game(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_end_game(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::end_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_game(&mut self, v: DebugEndGame) {
        self.command = ::std::option::Option::Some(DebugCommand_oneof_command::end_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_game(&mut self) -> &mut DebugEndGame {
        if let ::std::option::Option::Some(DebugCommand_oneof_command::end_game(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(DebugCommand_oneof_command::end_game(DebugEndGame::new()));
        }
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::end_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_game(&mut self) -> DebugEndGame {
        if self.has_end_game() {
            match self.command.take() {
                ::std::option::Option::Some(DebugCommand_oneof_command::end_game(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugEndGame::new()
        }
    }

    // optional .SC2APIProtocol.DebugSetUnitValue unit_value = 8;


    pub fn get_unit_value(&self) -> &DebugSetUnitValue {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::unit_value(ref v)) => v,
            _ => <DebugSetUnitValue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_unit_value(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_unit_value(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::unit_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_value(&mut self, v: DebugSetUnitValue) {
        self.command = ::std::option::Option::Some(DebugCommand_oneof_command::unit_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_value(&mut self) -> &mut DebugSetUnitValue {
        if let ::std::option::Option::Some(DebugCommand_oneof_command::unit_value(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(DebugCommand_oneof_command::unit_value(DebugSetUnitValue::new()));
        }
        match self.command {
            ::std::option::Option::Some(DebugCommand_oneof_command::unit_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_value(&mut self) -> DebugSetUnitValue {
        if self.has_unit_value() {
            match self.command.take() {
                ::std::option::Option::Some(DebugCommand_oneof_command::unit_value(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugSetUnitValue::new()
        }
    }
}

impl ::protobuf::Message for DebugCommand {
    fn is_initialized(&self) -> bool {
        if let Some(DebugCommand_oneof_command::draw(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DebugCommand_oneof_command::create_unit(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DebugCommand_oneof_command::kill_unit(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DebugCommand_oneof_command::test_process(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DebugCommand_oneof_command::score(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DebugCommand_oneof_command::end_game(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DebugCommand_oneof_command::unit_value(ref v)) = self.command {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(DebugCommand_oneof_command::draw(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(DebugCommand_oneof_command::game_state(is.read_enum()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(DebugCommand_oneof_command::create_unit(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(DebugCommand_oneof_command::kill_unit(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(DebugCommand_oneof_command::test_process(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(DebugCommand_oneof_command::score(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(DebugCommand_oneof_command::end_game(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.command = ::std::option::Option::Some(DebugCommand_oneof_command::unit_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &DebugCommand_oneof_command::draw(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DebugCommand_oneof_command::game_state(v) => {
                    my_size += ::protobuf::rt::enum_size(2, v);
                },
                &DebugCommand_oneof_command::create_unit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DebugCommand_oneof_command::kill_unit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DebugCommand_oneof_command::test_process(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DebugCommand_oneof_command::score(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DebugCommand_oneof_command::end_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DebugCommand_oneof_command::unit_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &DebugCommand_oneof_command::draw(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DebugCommand_oneof_command::game_state(v) => {
                    os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &DebugCommand_oneof_command::create_unit(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DebugCommand_oneof_command::kill_unit(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DebugCommand_oneof_command::test_process(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DebugCommand_oneof_command::score(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DebugCommand_oneof_command::end_game(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DebugCommand_oneof_command::unit_value(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugCommand {
        DebugCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DebugDraw>(
                "draw",
                DebugCommand::has_draw,
                DebugCommand::get_draw,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, DebugGameState>(
                "game_state",
                DebugCommand::has_game_state,
                DebugCommand::get_game_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DebugCreateUnit>(
                "create_unit",
                DebugCommand::has_create_unit,
                DebugCommand::get_create_unit,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DebugKillUnit>(
                "kill_unit",
                DebugCommand::has_kill_unit,
                DebugCommand::get_kill_unit,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DebugTestProcess>(
                "test_process",
                DebugCommand::has_test_process,
                DebugCommand::get_test_process,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DebugSetScore>(
                "score",
                DebugCommand::has_score,
                DebugCommand::get_score,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DebugEndGame>(
                "end_game",
                DebugCommand::has_end_game,
                DebugCommand::get_end_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DebugSetUnitValue>(
                "unit_value",
                DebugCommand::has_unit_value,
                DebugCommand::get_unit_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugCommand>(
                "DebugCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugCommand {
        static instance: ::protobuf::rt::LazyV2<DebugCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugCommand::new)
    }
}

impl ::protobuf::Clear for DebugCommand {
    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugDraw {
    // message fields
    pub text: ::protobuf::RepeatedField<DebugText>,
    pub lines: ::protobuf::RepeatedField<DebugLine>,
    pub boxes: ::protobuf::RepeatedField<DebugBox>,
    pub spheres: ::protobuf::RepeatedField<DebugSphere>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugDraw {
    fn default() -> &'a DebugDraw {
        <DebugDraw as ::protobuf::Message>::default_instance()
    }
}

impl DebugDraw {
    pub fn new() -> DebugDraw {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.DebugText text = 1;


    pub fn get_text(&self) -> &[DebugText] {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::RepeatedField<DebugText>) {
        self.text = v;
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::protobuf::RepeatedField<DebugText> {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::RepeatedField<DebugText> {
        ::std::mem::replace(&mut self.text, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.DebugLine lines = 2;


    pub fn get_lines(&self) -> &[DebugLine] {
        &self.lines
    }
    pub fn clear_lines(&mut self) {
        self.lines.clear();
    }

    // Param is passed by value, moved
    pub fn set_lines(&mut self, v: ::protobuf::RepeatedField<DebugLine>) {
        self.lines = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lines(&mut self) -> &mut ::protobuf::RepeatedField<DebugLine> {
        &mut self.lines
    }

    // Take field
    pub fn take_lines(&mut self) -> ::protobuf::RepeatedField<DebugLine> {
        ::std::mem::replace(&mut self.lines, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.DebugBox boxes = 3;


    pub fn get_boxes(&self) -> &[DebugBox] {
        &self.boxes
    }
    pub fn clear_boxes(&mut self) {
        self.boxes.clear();
    }

    // Param is passed by value, moved
    pub fn set_boxes(&mut self, v: ::protobuf::RepeatedField<DebugBox>) {
        self.boxes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_boxes(&mut self) -> &mut ::protobuf::RepeatedField<DebugBox> {
        &mut self.boxes
    }

    // Take field
    pub fn take_boxes(&mut self) -> ::protobuf::RepeatedField<DebugBox> {
        ::std::mem::replace(&mut self.boxes, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.DebugSphere spheres = 4;


    pub fn get_spheres(&self) -> &[DebugSphere] {
        &self.spheres
    }
    pub fn clear_spheres(&mut self) {
        self.spheres.clear();
    }

    // Param is passed by value, moved
    pub fn set_spheres(&mut self, v: ::protobuf::RepeatedField<DebugSphere>) {
        self.spheres = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spheres(&mut self) -> &mut ::protobuf::RepeatedField<DebugSphere> {
        &mut self.spheres
    }

    // Take field
    pub fn take_spheres(&mut self) -> ::protobuf::RepeatedField<DebugSphere> {
        ::std::mem::replace(&mut self.spheres, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DebugDraw {
    fn is_initialized(&self) -> bool {
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lines {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.boxes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spheres {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.lines)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.boxes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spheres)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.text {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.lines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.boxes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.spheres {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.text {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.lines {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.boxes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.spheres {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugDraw {
        DebugDraw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugText>>(
                "text",
                |m: &DebugDraw| { &m.text },
                |m: &mut DebugDraw| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugLine>>(
                "lines",
                |m: &DebugDraw| { &m.lines },
                |m: &mut DebugDraw| { &mut m.lines },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugBox>>(
                "boxes",
                |m: &DebugDraw| { &m.boxes },
                |m: &mut DebugDraw| { &mut m.boxes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugSphere>>(
                "spheres",
                |m: &DebugDraw| { &m.spheres },
                |m: &mut DebugDraw| { &mut m.spheres },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugDraw>(
                "DebugDraw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugDraw {
        static instance: ::protobuf::rt::LazyV2<DebugDraw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugDraw::new)
    }
}

impl ::protobuf::Clear for DebugDraw {
    fn clear(&mut self) {
        self.text.clear();
        self.lines.clear();
        self.boxes.clear();
        self.spheres.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugDraw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugDraw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Line {
    // message fields
    pub p0: ::protobuf::SingularPtrField<super::common::Point>,
    pub p1: ::protobuf::SingularPtrField<super::common::Point>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Line {
    fn default() -> &'a Line {
        <Line as ::protobuf::Message>::default_instance()
    }
}

impl Line {
    pub fn new() -> Line {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Point p0 = 1;


    pub fn get_p0(&self) -> &super::common::Point {
        self.p0.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p0(&mut self) {
        self.p0.clear();
    }

    pub fn has_p0(&self) -> bool {
        self.p0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p0(&mut self, v: super::common::Point) {
        self.p0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p0(&mut self) -> &mut super::common::Point {
        if self.p0.is_none() {
            self.p0.set_default();
        }
        self.p0.as_mut().unwrap()
    }

    // Take field
    pub fn take_p0(&mut self) -> super::common::Point {
        self.p0.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional .SC2APIProtocol.Point p1 = 2;


    pub fn get_p1(&self) -> &super::common::Point {
        self.p1.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: super::common::Point) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut super::common::Point {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> super::common::Point {
        self.p1.take().unwrap_or_else(|| super::common::Point::new())
    }
}

impl ::protobuf::Message for Line {
    fn is_initialized(&self) -> bool {
        for v in &self.p0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p0)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p0.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Line {
        Line::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "p0",
                |m: &Line| { &m.p0 },
                |m: &mut Line| { &mut m.p0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "p1",
                |m: &Line| { &m.p1 },
                |m: &mut Line| { &mut m.p1 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Line>(
                "Line",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Line {
        static instance: ::protobuf::rt::LazyV2<Line> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Line::new)
    }
}

impl ::protobuf::Clear for Line {
    fn clear(&mut self) {
        self.p0.clear();
        self.p1.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Line {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Line {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Color {
    // message fields
    pub r: ::std::option::Option<u32>,
    pub g: ::std::option::Option<u32>,
    pub b: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Color {
    fn default() -> &'a Color {
        <Color as ::protobuf::Message>::default_instance()
    }
}

impl Color {
    pub fn new() -> Color {
        ::std::default::Default::default()
    }

    // optional uint32 r = 1;


    pub fn get_r(&self) -> u32 {
        self.r.unwrap_or(0)
    }
    pub fn clear_r(&mut self) {
        self.r = ::std::option::Option::None;
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: u32) {
        self.r = ::std::option::Option::Some(v);
    }

    // optional uint32 g = 2;


    pub fn get_g(&self) -> u32 {
        self.g.unwrap_or(0)
    }
    pub fn clear_g(&mut self) {
        self.g = ::std::option::Option::None;
    }

    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g(&mut self, v: u32) {
        self.g = ::std::option::Option::Some(v);
    }

    // optional uint32 b = 3;


    pub fn get_b(&self) -> u32 {
        self.b.unwrap_or(0)
    }
    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: u32) {
        self.b = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Color {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.r = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.g = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.b = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.r {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.g {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.r {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.g {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.b {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Color {
        Color::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "r",
                |m: &Color| { &m.r },
                |m: &mut Color| { &mut m.r },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "g",
                |m: &Color| { &m.g },
                |m: &mut Color| { &mut m.g },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "b",
                |m: &Color| { &m.b },
                |m: &mut Color| { &mut m.b },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Color>(
                "Color",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Color {
        static instance: ::protobuf::rt::LazyV2<Color> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Color::new)
    }
}

impl ::protobuf::Clear for Color {
    fn clear(&mut self) {
        self.r = ::std::option::Option::None;
        self.g = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Color {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Color {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugText {
    // message fields
    pub color: ::protobuf::SingularPtrField<Color>,
    pub text: ::protobuf::SingularField<::std::string::String>,
    pub virtual_pos: ::protobuf::SingularPtrField<super::common::Point>,
    pub world_pos: ::protobuf::SingularPtrField<super::common::Point>,
    pub size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugText {
    fn default() -> &'a DebugText {
        <DebugText as ::protobuf::Message>::default_instance()
    }
}

impl DebugText {
    pub fn new() -> DebugText {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Color color = 1;


    pub fn get_color(&self) -> &Color {
        self.color.as_ref().unwrap_or_else(|| <Color as ::protobuf::Message>::default_instance())
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: Color) {
        self.color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut Color {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> Color {
        self.color.take().unwrap_or_else(|| Color::new())
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .SC2APIProtocol.Point virtual_pos = 3;


    pub fn get_virtual_pos(&self) -> &super::common::Point {
        self.virtual_pos.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_virtual_pos(&mut self) {
        self.virtual_pos.clear();
    }

    pub fn has_virtual_pos(&self) -> bool {
        self.virtual_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_pos(&mut self, v: super::common::Point) {
        self.virtual_pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtual_pos(&mut self) -> &mut super::common::Point {
        if self.virtual_pos.is_none() {
            self.virtual_pos.set_default();
        }
        self.virtual_pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtual_pos(&mut self) -> super::common::Point {
        self.virtual_pos.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional .SC2APIProtocol.Point world_pos = 4;


    pub fn get_world_pos(&self) -> &super::common::Point {
        self.world_pos.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_world_pos(&mut self) {
        self.world_pos.clear();
    }

    pub fn has_world_pos(&self) -> bool {
        self.world_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_pos(&mut self, v: super::common::Point) {
        self.world_pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_pos(&mut self) -> &mut super::common::Point {
        if self.world_pos.is_none() {
            self.world_pos.set_default();
        }
        self.world_pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_world_pos(&mut self) -> super::common::Point {
        self.world_pos.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional uint32 size = 5;


    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DebugText {
    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtual_pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.world_pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.color)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.virtual_pos)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.world_pos)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.virtual_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.color.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.virtual_pos.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.world_pos.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugText {
        DebugText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Color>>(
                "color",
                |m: &DebugText| { &m.color },
                |m: &mut DebugText| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &DebugText| { &m.text },
                |m: &mut DebugText| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "virtual_pos",
                |m: &DebugText| { &m.virtual_pos },
                |m: &mut DebugText| { &mut m.virtual_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "world_pos",
                |m: &DebugText| { &m.world_pos },
                |m: &mut DebugText| { &mut m.world_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "size",
                |m: &DebugText| { &m.size },
                |m: &mut DebugText| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugText>(
                "DebugText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugText {
        static instance: ::protobuf::rt::LazyV2<DebugText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugText::new)
    }
}

impl ::protobuf::Clear for DebugText {
    fn clear(&mut self) {
        self.color.clear();
        self.text.clear();
        self.virtual_pos.clear();
        self.world_pos.clear();
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugLine {
    // message fields
    pub color: ::protobuf::SingularPtrField<Color>,
    pub line: ::protobuf::SingularPtrField<Line>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugLine {
    fn default() -> &'a DebugLine {
        <DebugLine as ::protobuf::Message>::default_instance()
    }
}

impl DebugLine {
    pub fn new() -> DebugLine {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Color color = 1;


    pub fn get_color(&self) -> &Color {
        self.color.as_ref().unwrap_or_else(|| <Color as ::protobuf::Message>::default_instance())
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: Color) {
        self.color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut Color {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> Color {
        self.color.take().unwrap_or_else(|| Color::new())
    }

    // optional .SC2APIProtocol.Line line = 2;


    pub fn get_line(&self) -> &Line {
        self.line.as_ref().unwrap_or_else(|| <Line as ::protobuf::Message>::default_instance())
    }
    pub fn clear_line(&mut self) {
        self.line.clear();
    }

    pub fn has_line(&self) -> bool {
        self.line.is_some()
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: Line) {
        self.line = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_line(&mut self) -> &mut Line {
        if self.line.is_none() {
            self.line.set_default();
        }
        self.line.as_mut().unwrap()
    }

    // Take field
    pub fn take_line(&mut self) -> Line {
        self.line.take().unwrap_or_else(|| Line::new())
    }
}

impl ::protobuf::Message for DebugLine {
    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.line {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.color)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.line)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.line.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.color.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.line.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugLine {
        DebugLine::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Color>>(
                "color",
                |m: &DebugLine| { &m.color },
                |m: &mut DebugLine| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Line>>(
                "line",
                |m: &DebugLine| { &m.line },
                |m: &mut DebugLine| { &mut m.line },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugLine>(
                "DebugLine",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugLine {
        static instance: ::protobuf::rt::LazyV2<DebugLine> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugLine::new)
    }
}

impl ::protobuf::Clear for DebugLine {
    fn clear(&mut self) {
        self.color.clear();
        self.line.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugLine {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugBox {
    // message fields
    pub color: ::protobuf::SingularPtrField<Color>,
    pub min: ::protobuf::SingularPtrField<super::common::Point>,
    pub max: ::protobuf::SingularPtrField<super::common::Point>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugBox {
    fn default() -> &'a DebugBox {
        <DebugBox as ::protobuf::Message>::default_instance()
    }
}

impl DebugBox {
    pub fn new() -> DebugBox {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Color color = 1;


    pub fn get_color(&self) -> &Color {
        self.color.as_ref().unwrap_or_else(|| <Color as ::protobuf::Message>::default_instance())
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: Color) {
        self.color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut Color {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> Color {
        self.color.take().unwrap_or_else(|| Color::new())
    }

    // optional .SC2APIProtocol.Point min = 2;


    pub fn get_min(&self) -> &super::common::Point {
        self.min.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_min(&mut self) {
        self.min.clear();
    }

    pub fn has_min(&self) -> bool {
        self.min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: super::common::Point) {
        self.min = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min(&mut self) -> &mut super::common::Point {
        if self.min.is_none() {
            self.min.set_default();
        }
        self.min.as_mut().unwrap()
    }

    // Take field
    pub fn take_min(&mut self) -> super::common::Point {
        self.min.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional .SC2APIProtocol.Point max = 3;


    pub fn get_max(&self) -> &super::common::Point {
        self.max.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max(&mut self) {
        self.max.clear();
    }

    pub fn has_max(&self) -> bool {
        self.max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: super::common::Point) {
        self.max = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max(&mut self) -> &mut super::common::Point {
        if self.max.is_none() {
            self.max.set_default();
        }
        self.max.as_mut().unwrap()
    }

    // Take field
    pub fn take_max(&mut self) -> super::common::Point {
        self.max.take().unwrap_or_else(|| super::common::Point::new())
    }
}

impl ::protobuf::Message for DebugBox {
    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.min {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.color)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.min)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.min.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.color.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.min.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugBox {
        DebugBox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Color>>(
                "color",
                |m: &DebugBox| { &m.color },
                |m: &mut DebugBox| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "min",
                |m: &DebugBox| { &m.min },
                |m: &mut DebugBox| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "max",
                |m: &DebugBox| { &m.max },
                |m: &mut DebugBox| { &mut m.max },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugBox>(
                "DebugBox",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugBox {
        static instance: ::protobuf::rt::LazyV2<DebugBox> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugBox::new)
    }
}

impl ::protobuf::Clear for DebugBox {
    fn clear(&mut self) {
        self.color.clear();
        self.min.clear();
        self.max.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugBox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugSphere {
    // message fields
    pub color: ::protobuf::SingularPtrField<Color>,
    pub p: ::protobuf::SingularPtrField<super::common::Point>,
    pub r: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugSphere {
    fn default() -> &'a DebugSphere {
        <DebugSphere as ::protobuf::Message>::default_instance()
    }
}

impl DebugSphere {
    pub fn new() -> DebugSphere {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Color color = 1;


    pub fn get_color(&self) -> &Color {
        self.color.as_ref().unwrap_or_else(|| <Color as ::protobuf::Message>::default_instance())
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: Color) {
        self.color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut Color {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> Color {
        self.color.take().unwrap_or_else(|| Color::new())
    }

    // optional .SC2APIProtocol.Point p = 2;


    pub fn get_p(&self) -> &super::common::Point {
        self.p.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p(&mut self) {
        self.p.clear();
    }

    pub fn has_p(&self) -> bool {
        self.p.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p(&mut self, v: super::common::Point) {
        self.p = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p(&mut self) -> &mut super::common::Point {
        if self.p.is_none() {
            self.p.set_default();
        }
        self.p.as_mut().unwrap()
    }

    // Take field
    pub fn take_p(&mut self) -> super::common::Point {
        self.p.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional float r = 3;


    pub fn get_r(&self) -> f32 {
        self.r.unwrap_or(0.)
    }
    pub fn clear_r(&mut self) {
        self.r = ::std::option::Option::None;
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: f32) {
        self.r = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DebugSphere {
    fn is_initialized(&self) -> bool {
        for v in &self.color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.color)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.r = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.r {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.color.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.r {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugSphere {
        DebugSphere::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Color>>(
                "color",
                |m: &DebugSphere| { &m.color },
                |m: &mut DebugSphere| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "p",
                |m: &DebugSphere| { &m.p },
                |m: &mut DebugSphere| { &mut m.p },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "r",
                |m: &DebugSphere| { &m.r },
                |m: &mut DebugSphere| { &mut m.r },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugSphere>(
                "DebugSphere",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugSphere {
        static instance: ::protobuf::rt::LazyV2<DebugSphere> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugSphere::new)
    }
}

impl ::protobuf::Clear for DebugSphere {
    fn clear(&mut self) {
        self.color.clear();
        self.p.clear();
        self.r = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugSphere {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSphere {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugCreateUnit {
    // message fields
    pub unit_type: ::std::option::Option<u32>,
    pub owner: ::std::option::Option<i32>,
    pub pos: ::protobuf::SingularPtrField<super::common::Point2D>,
    pub quantity: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugCreateUnit {
    fn default() -> &'a DebugCreateUnit {
        <DebugCreateUnit as ::protobuf::Message>::default_instance()
    }
}

impl DebugCreateUnit {
    pub fn new() -> DebugCreateUnit {
        ::std::default::Default::default()
    }

    // optional uint32 unit_type = 1;


    pub fn get_unit_type(&self) -> u32 {
        self.unit_type.unwrap_or(0)
    }
    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: u32) {
        self.unit_type = ::std::option::Option::Some(v);
    }

    // optional int32 owner = 2;


    pub fn get_owner(&self) -> i32 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: i32) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Point2D pos = 3;


    pub fn get_pos(&self) -> &super::common::Point2D {
        self.pos.as_ref().unwrap_or_else(|| <super::common::Point2D as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: super::common::Point2D) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut super::common::Point2D {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> super::common::Point2D {
        self.pos.take().unwrap_or_else(|| super::common::Point2D::new())
    }

    // optional uint32 quantity = 4;


    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DebugCreateUnit {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unit_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugCreateUnit {
        DebugCreateUnit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unit_type",
                |m: &DebugCreateUnit| { &m.unit_type },
                |m: &mut DebugCreateUnit| { &mut m.unit_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "owner",
                |m: &DebugCreateUnit| { &m.owner },
                |m: &mut DebugCreateUnit| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point2D>>(
                "pos",
                |m: &DebugCreateUnit| { &m.pos },
                |m: &mut DebugCreateUnit| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quantity",
                |m: &DebugCreateUnit| { &m.quantity },
                |m: &mut DebugCreateUnit| { &mut m.quantity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugCreateUnit>(
                "DebugCreateUnit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugCreateUnit {
        static instance: ::protobuf::rt::LazyV2<DebugCreateUnit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugCreateUnit::new)
    }
}

impl ::protobuf::Clear for DebugCreateUnit {
    fn clear(&mut self) {
        self.unit_type = ::std::option::Option::None;
        self.owner = ::std::option::Option::None;
        self.pos.clear();
        self.quantity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugCreateUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugCreateUnit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugKillUnit {
    // message fields
    pub tag: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugKillUnit {
    fn default() -> &'a DebugKillUnit {
        <DebugKillUnit as ::protobuf::Message>::default_instance()
    }
}

impl DebugKillUnit {
    pub fn new() -> DebugKillUnit {
        ::std::default::Default::default()
    }

    // repeated uint64 tag = 1;


    pub fn get_tag(&self) -> &[u64] {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::vec::Vec<u64>) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tag(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.tag, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DebugKillUnit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tag {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tag {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugKillUnit {
        DebugKillUnit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tag",
                |m: &DebugKillUnit| { &m.tag },
                |m: &mut DebugKillUnit| { &mut m.tag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugKillUnit>(
                "DebugKillUnit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugKillUnit {
        static instance: ::protobuf::rt::LazyV2<DebugKillUnit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugKillUnit::new)
    }
}

impl ::protobuf::Clear for DebugKillUnit {
    fn clear(&mut self) {
        self.tag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugKillUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugKillUnit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugTestProcess {
    // message fields
    pub test: ::std::option::Option<DebugTestProcess_Test>,
    pub delay_ms: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugTestProcess {
    fn default() -> &'a DebugTestProcess {
        <DebugTestProcess as ::protobuf::Message>::default_instance()
    }
}

impl DebugTestProcess {
    pub fn new() -> DebugTestProcess {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DebugTestProcess.Test test = 1;


    pub fn get_test(&self) -> DebugTestProcess_Test {
        self.test.unwrap_or(DebugTestProcess_Test::hang)
    }
    pub fn clear_test(&mut self) {
        self.test = ::std::option::Option::None;
    }

    pub fn has_test(&self) -> bool {
        self.test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test(&mut self, v: DebugTestProcess_Test) {
        self.test = ::std::option::Option::Some(v);
    }

    // optional int32 delay_ms = 2;


    pub fn get_delay_ms(&self) -> i32 {
        self.delay_ms.unwrap_or(0)
    }
    pub fn clear_delay_ms(&mut self) {
        self.delay_ms = ::std::option::Option::None;
    }

    pub fn has_delay_ms(&self) -> bool {
        self.delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_ms(&mut self, v: i32) {
        self.delay_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DebugTestProcess {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.test, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.delay_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.test {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.delay_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.test {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.delay_ms {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugTestProcess {
        DebugTestProcess::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DebugTestProcess_Test>>(
                "test",
                |m: &DebugTestProcess| { &m.test },
                |m: &mut DebugTestProcess| { &mut m.test },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "delay_ms",
                |m: &DebugTestProcess| { &m.delay_ms },
                |m: &mut DebugTestProcess| { &mut m.delay_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugTestProcess>(
                "DebugTestProcess",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugTestProcess {
        static instance: ::protobuf::rt::LazyV2<DebugTestProcess> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugTestProcess::new)
    }
}

impl ::protobuf::Clear for DebugTestProcess {
    fn clear(&mut self) {
        self.test = ::std::option::Option::None;
        self.delay_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugTestProcess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugTestProcess {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DebugTestProcess_Test {
    hang = 1,
    crash = 2,
    exit = 3,
}

impl ::protobuf::ProtobufEnum for DebugTestProcess_Test {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DebugTestProcess_Test> {
        match value {
            1 => ::std::option::Option::Some(DebugTestProcess_Test::hang),
            2 => ::std::option::Option::Some(DebugTestProcess_Test::crash),
            3 => ::std::option::Option::Some(DebugTestProcess_Test::exit),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DebugTestProcess_Test] = &[
            DebugTestProcess_Test::hang,
            DebugTestProcess_Test::crash,
            DebugTestProcess_Test::exit,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DebugTestProcess_Test>("DebugTestProcess.Test", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DebugTestProcess_Test {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DebugTestProcess_Test {
    fn default() -> Self {
        DebugTestProcess_Test::hang
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugTestProcess_Test {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugSetScore {
    // message fields
    pub score: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugSetScore {
    fn default() -> &'a DebugSetScore {
        <DebugSetScore as ::protobuf::Message>::default_instance()
    }
}

impl DebugSetScore {
    pub fn new() -> DebugSetScore {
        ::std::default::Default::default()
    }

    // optional float score = 1;


    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DebugSetScore {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.score {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugSetScore {
        DebugSetScore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &DebugSetScore| { &m.score },
                |m: &mut DebugSetScore| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugSetScore>(
                "DebugSetScore",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugSetScore {
        static instance: ::protobuf::rt::LazyV2<DebugSetScore> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugSetScore::new)
    }
}

impl ::protobuf::Clear for DebugSetScore {
    fn clear(&mut self) {
        self.score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugSetScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSetScore {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugEndGame {
    // message fields
    pub end_result: ::std::option::Option<DebugEndGame_EndResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugEndGame {
    fn default() -> &'a DebugEndGame {
        <DebugEndGame as ::protobuf::Message>::default_instance()
    }
}

impl DebugEndGame {
    pub fn new() -> DebugEndGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DebugEndGame.EndResult end_result = 1;


    pub fn get_end_result(&self) -> DebugEndGame_EndResult {
        self.end_result.unwrap_or(DebugEndGame_EndResult::Surrender)
    }
    pub fn clear_end_result(&mut self) {
        self.end_result = ::std::option::Option::None;
    }

    pub fn has_end_result(&self) -> bool {
        self.end_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_result(&mut self, v: DebugEndGame_EndResult) {
        self.end_result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DebugEndGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.end_result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.end_result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.end_result {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugEndGame {
        DebugEndGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DebugEndGame_EndResult>>(
                "end_result",
                |m: &DebugEndGame| { &m.end_result },
                |m: &mut DebugEndGame| { &mut m.end_result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugEndGame>(
                "DebugEndGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugEndGame {
        static instance: ::protobuf::rt::LazyV2<DebugEndGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugEndGame::new)
    }
}

impl ::protobuf::Clear for DebugEndGame {
    fn clear(&mut self) {
        self.end_result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugEndGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugEndGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DebugEndGame_EndResult {
    Surrender = 1,
    DeclareVictory = 2,
}

impl ::protobuf::ProtobufEnum for DebugEndGame_EndResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DebugEndGame_EndResult> {
        match value {
            1 => ::std::option::Option::Some(DebugEndGame_EndResult::Surrender),
            2 => ::std::option::Option::Some(DebugEndGame_EndResult::DeclareVictory),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DebugEndGame_EndResult] = &[
            DebugEndGame_EndResult::Surrender,
            DebugEndGame_EndResult::DeclareVictory,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DebugEndGame_EndResult>("DebugEndGame.EndResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DebugEndGame_EndResult {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DebugEndGame_EndResult {
    fn default() -> Self {
        DebugEndGame_EndResult::Surrender
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugEndGame_EndResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugSetUnitValue {
    // message fields
    pub unit_value: ::std::option::Option<DebugSetUnitValue_UnitValue>,
    pub value: ::std::option::Option<f32>,
    pub unit_tag: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugSetUnitValue {
    fn default() -> &'a DebugSetUnitValue {
        <DebugSetUnitValue as ::protobuf::Message>::default_instance()
    }
}

impl DebugSetUnitValue {
    pub fn new() -> DebugSetUnitValue {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DebugSetUnitValue.UnitValue unit_value = 1;


    pub fn get_unit_value(&self) -> DebugSetUnitValue_UnitValue {
        self.unit_value.unwrap_or(DebugSetUnitValue_UnitValue::Energy)
    }
    pub fn clear_unit_value(&mut self) {
        self.unit_value = ::std::option::Option::None;
    }

    pub fn has_unit_value(&self) -> bool {
        self.unit_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_value(&mut self, v: DebugSetUnitValue_UnitValue) {
        self.unit_value = ::std::option::Option::Some(v);
    }

    // optional float value = 2;


    pub fn get_value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint64 unit_tag = 3;


    pub fn get_unit_tag(&self) -> u64 {
        self.unit_tag.unwrap_or(0)
    }
    pub fn clear_unit_tag(&mut self) {
        self.unit_tag = ::std::option::Option::None;
    }

    pub fn has_unit_tag(&self) -> bool {
        self.unit_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_tag(&mut self, v: u64) {
        self.unit_tag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DebugSetUnitValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.unit_value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.unit_tag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit_value {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += 5;
        }
        if let Some(v) = self.unit_tag {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit_value {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.value {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.unit_tag {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugSetUnitValue {
        DebugSetUnitValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DebugSetUnitValue_UnitValue>>(
                "unit_value",
                |m: &DebugSetUnitValue| { &m.unit_value },
                |m: &mut DebugSetUnitValue| { &mut m.unit_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &DebugSetUnitValue| { &m.value },
                |m: &mut DebugSetUnitValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "unit_tag",
                |m: &DebugSetUnitValue| { &m.unit_tag },
                |m: &mut DebugSetUnitValue| { &mut m.unit_tag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugSetUnitValue>(
                "DebugSetUnitValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugSetUnitValue {
        static instance: ::protobuf::rt::LazyV2<DebugSetUnitValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugSetUnitValue::new)
    }
}

impl ::protobuf::Clear for DebugSetUnitValue {
    fn clear(&mut self) {
        self.unit_value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unit_tag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugSetUnitValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSetUnitValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DebugSetUnitValue_UnitValue {
    Energy = 1,
    Life = 2,
    Shields = 3,
}

impl ::protobuf::ProtobufEnum for DebugSetUnitValue_UnitValue {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DebugSetUnitValue_UnitValue> {
        match value {
            1 => ::std::option::Option::Some(DebugSetUnitValue_UnitValue::Energy),
            2 => ::std::option::Option::Some(DebugSetUnitValue_UnitValue::Life),
            3 => ::std::option::Option::Some(DebugSetUnitValue_UnitValue::Shields),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DebugSetUnitValue_UnitValue] = &[
            DebugSetUnitValue_UnitValue::Energy,
            DebugSetUnitValue_UnitValue::Life,
            DebugSetUnitValue_UnitValue::Shields,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DebugSetUnitValue_UnitValue>("DebugSetUnitValue.UnitValue", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DebugSetUnitValue_UnitValue {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DebugSetUnitValue_UnitValue {
    fn default() -> Self {
        DebugSetUnitValue_UnitValue::Energy
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSetUnitValue_UnitValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DebugGameState {
    show_map = 1,
    control_enemy = 2,
    food = 3,
    free = 4,
    all_resources = 5,
    god = 6,
    minerals = 7,
    gas = 8,
    cooldown = 9,
    tech_tree = 10,
    upgrade = 11,
    fast_build = 12,
}

impl ::protobuf::ProtobufEnum for DebugGameState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DebugGameState> {
        match value {
            1 => ::std::option::Option::Some(DebugGameState::show_map),
            2 => ::std::option::Option::Some(DebugGameState::control_enemy),
            3 => ::std::option::Option::Some(DebugGameState::food),
            4 => ::std::option::Option::Some(DebugGameState::free),
            5 => ::std::option::Option::Some(DebugGameState::all_resources),
            6 => ::std::option::Option::Some(DebugGameState::god),
            7 => ::std::option::Option::Some(DebugGameState::minerals),
            8 => ::std::option::Option::Some(DebugGameState::gas),
            9 => ::std::option::Option::Some(DebugGameState::cooldown),
            10 => ::std::option::Option::Some(DebugGameState::tech_tree),
            11 => ::std::option::Option::Some(DebugGameState::upgrade),
            12 => ::std::option::Option::Some(DebugGameState::fast_build),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DebugGameState] = &[
            DebugGameState::show_map,
            DebugGameState::control_enemy,
            DebugGameState::food,
            DebugGameState::free,
            DebugGameState::all_resources,
            DebugGameState::god,
            DebugGameState::minerals,
            DebugGameState::gas,
            DebugGameState::cooldown,
            DebugGameState::tech_tree,
            DebugGameState::upgrade,
            DebugGameState::fast_build,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DebugGameState>("DebugGameState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DebugGameState {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DebugGameState {
    fn default() -> Self {
        DebugGameState::show_map
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugGameState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cs2clientprotocol/debug.proto\x12\x0eSC2APIProtocol\x1a\x1ds2client\
    protocol/common.proto\"\x8a\x04\n\x0cDebugCommand\x12/\n\x04draw\x18\x01\
    \x20\x01(\x0b2\x19.SC2APIProtocol.DebugDrawH\0R\x04draw\x12?\n\ngame_sta\
    te\x18\x02\x20\x01(\x0e2\x1e.SC2APIProtocol.DebugGameStateH\0R\tgameStat\
    e\x12B\n\x0bcreate_unit\x18\x03\x20\x01(\x0b2\x1f.SC2APIProtocol.DebugCr\
    eateUnitH\0R\ncreateUnit\x12<\n\tkill_unit\x18\x04\x20\x01(\x0b2\x1d.SC2\
    APIProtocol.DebugKillUnitH\0R\x08killUnit\x12E\n\x0ctest_process\x18\x05\
    \x20\x01(\x0b2\x20.SC2APIProtocol.DebugTestProcessH\0R\x0btestProcess\
    \x125\n\x05score\x18\x06\x20\x01(\x0b2\x1d.SC2APIProtocol.DebugSetScoreH\
    \0R\x05score\x129\n\x08end_game\x18\x07\x20\x01(\x0b2\x1c.SC2APIProtocol\
    .DebugEndGameH\0R\x07endGame\x12B\n\nunit_value\x18\x08\x20\x01(\x0b2!.S\
    C2APIProtocol.DebugSetUnitValueH\0R\tunitValueB\t\n\x07command\"\xd2\x01\
    \n\tDebugDraw\x12-\n\x04text\x18\x01\x20\x03(\x0b2\x19.SC2APIProtocol.De\
    bugTextR\x04text\x12/\n\x05lines\x18\x02\x20\x03(\x0b2\x19.SC2APIProtoco\
    l.DebugLineR\x05lines\x12.\n\x05boxes\x18\x03\x20\x03(\x0b2\x18.SC2APIPr\
    otocol.DebugBoxR\x05boxes\x125\n\x07spheres\x18\x04\x20\x03(\x0b2\x1b.SC\
    2APIProtocol.DebugSphereR\x07spheres\"T\n\x04Line\x12%\n\x02p0\x18\x01\
    \x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x02p0\x12%\n\x02p1\x18\x02\x20\
    \x01(\x0b2\x15.SC2APIProtocol.PointR\x02p1\"1\n\x05Color\x12\x0c\n\x01r\
    \x18\x01\x20\x01(\rR\x01r\x12\x0c\n\x01g\x18\x02\x20\x01(\rR\x01g\x12\
    \x0c\n\x01b\x18\x03\x20\x01(\rR\x01b\"\xcc\x01\n\tDebugText\x12+\n\x05co\
    lor\x18\x01\x20\x01(\x0b2\x15.SC2APIProtocol.ColorR\x05color\x12\x12\n\
    \x04text\x18\x02\x20\x01(\tR\x04text\x126\n\x0bvirtual_pos\x18\x03\x20\
    \x01(\x0b2\x15.SC2APIProtocol.PointR\nvirtualPos\x122\n\tworld_pos\x18\
    \x04\x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x08worldPos\x12\x12\n\x04si\
    ze\x18\x05\x20\x01(\rR\x04size\"b\n\tDebugLine\x12+\n\x05color\x18\x01\
    \x20\x01(\x0b2\x15.SC2APIProtocol.ColorR\x05color\x12(\n\x04line\x18\x02\
    \x20\x01(\x0b2\x14.SC2APIProtocol.LineR\x04line\"\x89\x01\n\x08DebugBox\
    \x12+\n\x05color\x18\x01\x20\x01(\x0b2\x15.SC2APIProtocol.ColorR\x05colo\
    r\x12'\n\x03min\x18\x02\x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x03min\
    \x12'\n\x03max\x18\x03\x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x03max\"m\
    \n\x0bDebugSphere\x12+\n\x05color\x18\x01\x20\x01(\x0b2\x15.SC2APIProtoc\
    ol.ColorR\x05color\x12#\n\x01p\x18\x02\x20\x01(\x0b2\x15.SC2APIProtocol.\
    PointR\x01p\x12\x0c\n\x01r\x18\x03\x20\x01(\x02R\x01r\"\x8b\x01\n\x0fDeb\
    ugCreateUnit\x12\x1b\n\tunit_type\x18\x01\x20\x01(\rR\x08unitType\x12\
    \x14\n\x05owner\x18\x02\x20\x01(\x05R\x05owner\x12)\n\x03pos\x18\x03\x20\
    \x01(\x0b2\x17.SC2APIProtocol.Point2DR\x03pos\x12\x1a\n\x08quantity\x18\
    \x04\x20\x01(\rR\x08quantity\"!\n\rDebugKillUnit\x12\x10\n\x03tag\x18\
    \x01\x20\x03(\x04R\x03tag\"\x8f\x01\n\x10DebugTestProcess\x129\n\x04test\
    \x18\x01\x20\x01(\x0e2%.SC2APIProtocol.DebugTestProcess.TestR\x04test\
    \x12\x19\n\x08delay_ms\x18\x02\x20\x01(\x05R\x07delayMs\"%\n\x04Test\x12\
    \x08\n\x04hang\x10\x01\x12\t\n\x05crash\x10\x02\x12\x08\n\x04exit\x10\
    \x03\"%\n\rDebugSetScore\x12\x14\n\x05score\x18\x01\x20\x01(\x02R\x05sco\
    re\"\x85\x01\n\x0cDebugEndGame\x12E\n\nend_result\x18\x01\x20\x01(\x0e2&\
    .SC2APIProtocol.DebugEndGame.EndResultR\tendResult\".\n\tEndResult\x12\r\
    \n\tSurrender\x10\x01\x12\x12\n\x0eDeclareVictory\x10\x02\"\xc0\x01\n\
    \x11DebugSetUnitValue\x12J\n\nunit_value\x18\x01\x20\x01(\x0e2+.SC2APIPr\
    otocol.DebugSetUnitValue.UnitValueR\tunitValue\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x02R\x05value\x12\x19\n\x08unit_tag\x18\x03\x20\x01(\x04R\
    \x07unitTag\".\n\tUnitValue\x12\n\n\x06Energy\x10\x01\x12\x08\n\x04Life\
    \x10\x02\x12\x0b\n\x07Shields\x10\x03*\xb2\x01\n\x0eDebugGameState\x12\
    \x0c\n\x08show_map\x10\x01\x12\x11\n\rcontrol_enemy\x10\x02\x12\x08\n\
    \x04food\x10\x03\x12\x08\n\x04free\x10\x04\x12\x11\n\rall_resources\x10\
    \x05\x12\x07\n\x03god\x10\x06\x12\x0c\n\x08minerals\x10\x07\x12\x07\n\
    \x03gas\x10\x08\x12\x0c\n\x08cooldown\x10\t\x12\r\n\ttech_tree\x10\n\x12\
    \x0b\n\x07upgrade\x10\x0b\x12\x0e\n\nfast_build\x10\x0c\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
