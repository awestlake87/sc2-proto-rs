// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `s2clientprotocol/spatial.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct ObservationFeatureLayer {
    // message fields
    pub renders: ::protobuf::SingularPtrField<FeatureLayers>,
    pub minimap_renders: ::protobuf::SingularPtrField<FeatureLayersMinimap>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObservationFeatureLayer {
    fn default() -> &'a ObservationFeatureLayer {
        <ObservationFeatureLayer as ::protobuf::Message>::default_instance()
    }
}

impl ObservationFeatureLayer {
    pub fn new() -> ObservationFeatureLayer {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.FeatureLayers renders = 1;


    pub fn get_renders(&self) -> &FeatureLayers {
        self.renders.as_ref().unwrap_or_else(|| <FeatureLayers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_renders(&mut self) {
        self.renders.clear();
    }

    pub fn has_renders(&self) -> bool {
        self.renders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_renders(&mut self, v: FeatureLayers) {
        self.renders = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_renders(&mut self) -> &mut FeatureLayers {
        if self.renders.is_none() {
            self.renders.set_default();
        }
        self.renders.as_mut().unwrap()
    }

    // Take field
    pub fn take_renders(&mut self) -> FeatureLayers {
        self.renders.take().unwrap_or_else(|| FeatureLayers::new())
    }

    // optional .SC2APIProtocol.FeatureLayersMinimap minimap_renders = 2;


    pub fn get_minimap_renders(&self) -> &FeatureLayersMinimap {
        self.minimap_renders.as_ref().unwrap_or_else(|| <FeatureLayersMinimap as ::protobuf::Message>::default_instance())
    }
    pub fn clear_minimap_renders(&mut self) {
        self.minimap_renders.clear();
    }

    pub fn has_minimap_renders(&self) -> bool {
        self.minimap_renders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimap_renders(&mut self, v: FeatureLayersMinimap) {
        self.minimap_renders = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimap_renders(&mut self) -> &mut FeatureLayersMinimap {
        if self.minimap_renders.is_none() {
            self.minimap_renders.set_default();
        }
        self.minimap_renders.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimap_renders(&mut self) -> FeatureLayersMinimap {
        self.minimap_renders.take().unwrap_or_else(|| FeatureLayersMinimap::new())
    }
}

impl ::protobuf::Message for ObservationFeatureLayer {
    fn is_initialized(&self) -> bool {
        for v in &self.renders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.minimap_renders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.renders)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.minimap_renders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.renders.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.minimap_renders.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.renders.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.minimap_renders.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationFeatureLayer {
        ObservationFeatureLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureLayers>>(
                "renders",
                |m: &ObservationFeatureLayer| { &m.renders },
                |m: &mut ObservationFeatureLayer| { &mut m.renders },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureLayersMinimap>>(
                "minimap_renders",
                |m: &ObservationFeatureLayer| { &m.minimap_renders },
                |m: &mut ObservationFeatureLayer| { &mut m.minimap_renders },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObservationFeatureLayer>(
                "ObservationFeatureLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObservationFeatureLayer {
        static instance: ::protobuf::rt::LazyV2<ObservationFeatureLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObservationFeatureLayer::new)
    }
}

impl ::protobuf::Clear for ObservationFeatureLayer {
    fn clear(&mut self) {
        self.renders.clear();
        self.minimap_renders.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationFeatureLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationFeatureLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureLayers {
    // message fields
    pub height_map: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub visibility_map: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub creep: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub power: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub player_id: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_type: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub selected: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_hit_points: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_hit_points_ratio: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_energy: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_energy_ratio: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_shields: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_shields_ratio: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub player_relative: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_density_aa: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_density: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub effects: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub hallucinations: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub cloaked: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub blip: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub buffs: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub buff_duration: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub active: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub build_progress: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub buildable: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub pathable: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub placeholder: ::protobuf::SingularPtrField<super::common::ImageData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureLayers {
    fn default() -> &'a FeatureLayers {
        <FeatureLayers as ::protobuf::Message>::default_instance()
    }
}

impl FeatureLayers {
    pub fn new() -> FeatureLayers {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ImageData height_map = 1;


    pub fn get_height_map(&self) -> &super::common::ImageData {
        self.height_map.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height_map(&mut self) {
        self.height_map.clear();
    }

    pub fn has_height_map(&self) -> bool {
        self.height_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height_map(&mut self, v: super::common::ImageData) {
        self.height_map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height_map(&mut self) -> &mut super::common::ImageData {
        if self.height_map.is_none() {
            self.height_map.set_default();
        }
        self.height_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_height_map(&mut self) -> super::common::ImageData {
        self.height_map.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData visibility_map = 2;


    pub fn get_visibility_map(&self) -> &super::common::ImageData {
        self.visibility_map.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility_map(&mut self) {
        self.visibility_map.clear();
    }

    pub fn has_visibility_map(&self) -> bool {
        self.visibility_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility_map(&mut self, v: super::common::ImageData) {
        self.visibility_map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility_map(&mut self) -> &mut super::common::ImageData {
        if self.visibility_map.is_none() {
            self.visibility_map.set_default();
        }
        self.visibility_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility_map(&mut self) -> super::common::ImageData {
        self.visibility_map.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData creep = 3;


    pub fn get_creep(&self) -> &super::common::ImageData {
        self.creep.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creep(&mut self) {
        self.creep.clear();
    }

    pub fn has_creep(&self) -> bool {
        self.creep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creep(&mut self, v: super::common::ImageData) {
        self.creep = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creep(&mut self) -> &mut super::common::ImageData {
        if self.creep.is_none() {
            self.creep.set_default();
        }
        self.creep.as_mut().unwrap()
    }

    // Take field
    pub fn take_creep(&mut self) -> super::common::ImageData {
        self.creep.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData power = 4;


    pub fn get_power(&self) -> &super::common::ImageData {
        self.power.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_power(&mut self) {
        self.power.clear();
    }

    pub fn has_power(&self) -> bool {
        self.power.is_some()
    }

    // Param is passed by value, moved
    pub fn set_power(&mut self, v: super::common::ImageData) {
        self.power = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_power(&mut self) -> &mut super::common::ImageData {
        if self.power.is_none() {
            self.power.set_default();
        }
        self.power.as_mut().unwrap()
    }

    // Take field
    pub fn take_power(&mut self) -> super::common::ImageData {
        self.power.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData player_id = 5;


    pub fn get_player_id(&self) -> &super::common::ImageData {
        self.player_id.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_id(&mut self) {
        self.player_id.clear();
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: super::common::ImageData) {
        self.player_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_id(&mut self) -> &mut super::common::ImageData {
        if self.player_id.is_none() {
            self.player_id.set_default();
        }
        self.player_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_id(&mut self) -> super::common::ImageData {
        self.player_id.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_type = 6;


    pub fn get_unit_type(&self) -> &super::common::ImageData {
        self.unit_type.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_type(&mut self) {
        self.unit_type.clear();
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: super::common::ImageData) {
        self.unit_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_type(&mut self) -> &mut super::common::ImageData {
        if self.unit_type.is_none() {
            self.unit_type.set_default();
        }
        self.unit_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_type(&mut self) -> super::common::ImageData {
        self.unit_type.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData selected = 7;


    pub fn get_selected(&self) -> &super::common::ImageData {
        self.selected.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selected(&mut self) {
        self.selected.clear();
    }

    pub fn has_selected(&self) -> bool {
        self.selected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected(&mut self, v: super::common::ImageData) {
        self.selected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selected(&mut self) -> &mut super::common::ImageData {
        if self.selected.is_none() {
            self.selected.set_default();
        }
        self.selected.as_mut().unwrap()
    }

    // Take field
    pub fn take_selected(&mut self) -> super::common::ImageData {
        self.selected.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_hit_points = 8;


    pub fn get_unit_hit_points(&self) -> &super::common::ImageData {
        self.unit_hit_points.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_hit_points(&mut self) {
        self.unit_hit_points.clear();
    }

    pub fn has_unit_hit_points(&self) -> bool {
        self.unit_hit_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_hit_points(&mut self, v: super::common::ImageData) {
        self.unit_hit_points = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_hit_points(&mut self) -> &mut super::common::ImageData {
        if self.unit_hit_points.is_none() {
            self.unit_hit_points.set_default();
        }
        self.unit_hit_points.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_hit_points(&mut self) -> super::common::ImageData {
        self.unit_hit_points.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_hit_points_ratio = 17;


    pub fn get_unit_hit_points_ratio(&self) -> &super::common::ImageData {
        self.unit_hit_points_ratio.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_hit_points_ratio(&mut self) {
        self.unit_hit_points_ratio.clear();
    }

    pub fn has_unit_hit_points_ratio(&self) -> bool {
        self.unit_hit_points_ratio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_hit_points_ratio(&mut self, v: super::common::ImageData) {
        self.unit_hit_points_ratio = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_hit_points_ratio(&mut self) -> &mut super::common::ImageData {
        if self.unit_hit_points_ratio.is_none() {
            self.unit_hit_points_ratio.set_default();
        }
        self.unit_hit_points_ratio.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_hit_points_ratio(&mut self) -> super::common::ImageData {
        self.unit_hit_points_ratio.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_energy = 9;


    pub fn get_unit_energy(&self) -> &super::common::ImageData {
        self.unit_energy.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_energy(&mut self) {
        self.unit_energy.clear();
    }

    pub fn has_unit_energy(&self) -> bool {
        self.unit_energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_energy(&mut self, v: super::common::ImageData) {
        self.unit_energy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_energy(&mut self) -> &mut super::common::ImageData {
        if self.unit_energy.is_none() {
            self.unit_energy.set_default();
        }
        self.unit_energy.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_energy(&mut self) -> super::common::ImageData {
        self.unit_energy.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_energy_ratio = 18;


    pub fn get_unit_energy_ratio(&self) -> &super::common::ImageData {
        self.unit_energy_ratio.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_energy_ratio(&mut self) {
        self.unit_energy_ratio.clear();
    }

    pub fn has_unit_energy_ratio(&self) -> bool {
        self.unit_energy_ratio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_energy_ratio(&mut self, v: super::common::ImageData) {
        self.unit_energy_ratio = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_energy_ratio(&mut self) -> &mut super::common::ImageData {
        if self.unit_energy_ratio.is_none() {
            self.unit_energy_ratio.set_default();
        }
        self.unit_energy_ratio.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_energy_ratio(&mut self) -> super::common::ImageData {
        self.unit_energy_ratio.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_shields = 10;


    pub fn get_unit_shields(&self) -> &super::common::ImageData {
        self.unit_shields.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_shields(&mut self) {
        self.unit_shields.clear();
    }

    pub fn has_unit_shields(&self) -> bool {
        self.unit_shields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_shields(&mut self, v: super::common::ImageData) {
        self.unit_shields = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_shields(&mut self) -> &mut super::common::ImageData {
        if self.unit_shields.is_none() {
            self.unit_shields.set_default();
        }
        self.unit_shields.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_shields(&mut self) -> super::common::ImageData {
        self.unit_shields.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_shields_ratio = 19;


    pub fn get_unit_shields_ratio(&self) -> &super::common::ImageData {
        self.unit_shields_ratio.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_shields_ratio(&mut self) {
        self.unit_shields_ratio.clear();
    }

    pub fn has_unit_shields_ratio(&self) -> bool {
        self.unit_shields_ratio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_shields_ratio(&mut self, v: super::common::ImageData) {
        self.unit_shields_ratio = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_shields_ratio(&mut self) -> &mut super::common::ImageData {
        if self.unit_shields_ratio.is_none() {
            self.unit_shields_ratio.set_default();
        }
        self.unit_shields_ratio.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_shields_ratio(&mut self) -> super::common::ImageData {
        self.unit_shields_ratio.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData player_relative = 11;


    pub fn get_player_relative(&self) -> &super::common::ImageData {
        self.player_relative.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_relative(&mut self) {
        self.player_relative.clear();
    }

    pub fn has_player_relative(&self) -> bool {
        self.player_relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_relative(&mut self, v: super::common::ImageData) {
        self.player_relative = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_relative(&mut self) -> &mut super::common::ImageData {
        if self.player_relative.is_none() {
            self.player_relative.set_default();
        }
        self.player_relative.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_relative(&mut self) -> super::common::ImageData {
        self.player_relative.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_density_aa = 14;


    pub fn get_unit_density_aa(&self) -> &super::common::ImageData {
        self.unit_density_aa.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_density_aa(&mut self) {
        self.unit_density_aa.clear();
    }

    pub fn has_unit_density_aa(&self) -> bool {
        self.unit_density_aa.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_density_aa(&mut self, v: super::common::ImageData) {
        self.unit_density_aa = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_density_aa(&mut self) -> &mut super::common::ImageData {
        if self.unit_density_aa.is_none() {
            self.unit_density_aa.set_default();
        }
        self.unit_density_aa.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_density_aa(&mut self) -> super::common::ImageData {
        self.unit_density_aa.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_density = 15;


    pub fn get_unit_density(&self) -> &super::common::ImageData {
        self.unit_density.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_density(&mut self) {
        self.unit_density.clear();
    }

    pub fn has_unit_density(&self) -> bool {
        self.unit_density.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_density(&mut self, v: super::common::ImageData) {
        self.unit_density = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_density(&mut self) -> &mut super::common::ImageData {
        if self.unit_density.is_none() {
            self.unit_density.set_default();
        }
        self.unit_density.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_density(&mut self) -> super::common::ImageData {
        self.unit_density.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData effects = 20;


    pub fn get_effects(&self) -> &super::common::ImageData {
        self.effects.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_effects(&mut self) {
        self.effects.clear();
    }

    pub fn has_effects(&self) -> bool {
        self.effects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: super::common::ImageData) {
        self.effects = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effects(&mut self) -> &mut super::common::ImageData {
        if self.effects.is_none() {
            self.effects.set_default();
        }
        self.effects.as_mut().unwrap()
    }

    // Take field
    pub fn take_effects(&mut self) -> super::common::ImageData {
        self.effects.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData hallucinations = 21;


    pub fn get_hallucinations(&self) -> &super::common::ImageData {
        self.hallucinations.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hallucinations(&mut self) {
        self.hallucinations.clear();
    }

    pub fn has_hallucinations(&self) -> bool {
        self.hallucinations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hallucinations(&mut self, v: super::common::ImageData) {
        self.hallucinations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hallucinations(&mut self) -> &mut super::common::ImageData {
        if self.hallucinations.is_none() {
            self.hallucinations.set_default();
        }
        self.hallucinations.as_mut().unwrap()
    }

    // Take field
    pub fn take_hallucinations(&mut self) -> super::common::ImageData {
        self.hallucinations.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData cloaked = 22;


    pub fn get_cloaked(&self) -> &super::common::ImageData {
        self.cloaked.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cloaked(&mut self) {
        self.cloaked.clear();
    }

    pub fn has_cloaked(&self) -> bool {
        self.cloaked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloaked(&mut self, v: super::common::ImageData) {
        self.cloaked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloaked(&mut self) -> &mut super::common::ImageData {
        if self.cloaked.is_none() {
            self.cloaked.set_default();
        }
        self.cloaked.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloaked(&mut self) -> super::common::ImageData {
        self.cloaked.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData blip = 23;


    pub fn get_blip(&self) -> &super::common::ImageData {
        self.blip.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blip(&mut self) {
        self.blip.clear();
    }

    pub fn has_blip(&self) -> bool {
        self.blip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blip(&mut self, v: super::common::ImageData) {
        self.blip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blip(&mut self) -> &mut super::common::ImageData {
        if self.blip.is_none() {
            self.blip.set_default();
        }
        self.blip.as_mut().unwrap()
    }

    // Take field
    pub fn take_blip(&mut self) -> super::common::ImageData {
        self.blip.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData buffs = 24;


    pub fn get_buffs(&self) -> &super::common::ImageData {
        self.buffs.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_buffs(&mut self) {
        self.buffs.clear();
    }

    pub fn has_buffs(&self) -> bool {
        self.buffs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffs(&mut self, v: super::common::ImageData) {
        self.buffs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffs(&mut self) -> &mut super::common::ImageData {
        if self.buffs.is_none() {
            self.buffs.set_default();
        }
        self.buffs.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffs(&mut self) -> super::common::ImageData {
        self.buffs.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData buff_duration = 26;


    pub fn get_buff_duration(&self) -> &super::common::ImageData {
        self.buff_duration.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_buff_duration(&mut self) {
        self.buff_duration.clear();
    }

    pub fn has_buff_duration(&self) -> bool {
        self.buff_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_duration(&mut self, v: super::common::ImageData) {
        self.buff_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buff_duration(&mut self) -> &mut super::common::ImageData {
        if self.buff_duration.is_none() {
            self.buff_duration.set_default();
        }
        self.buff_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_buff_duration(&mut self) -> super::common::ImageData {
        self.buff_duration.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData active = 25;


    pub fn get_active(&self) -> &super::common::ImageData {
        self.active.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_active(&mut self) {
        self.active.clear();
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: super::common::ImageData) {
        self.active = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active(&mut self) -> &mut super::common::ImageData {
        if self.active.is_none() {
            self.active.set_default();
        }
        self.active.as_mut().unwrap()
    }

    // Take field
    pub fn take_active(&mut self) -> super::common::ImageData {
        self.active.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData build_progress = 27;


    pub fn get_build_progress(&self) -> &super::common::ImageData {
        self.build_progress.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_build_progress(&mut self) {
        self.build_progress.clear();
    }

    pub fn has_build_progress(&self) -> bool {
        self.build_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_progress(&mut self, v: super::common::ImageData) {
        self.build_progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_progress(&mut self) -> &mut super::common::ImageData {
        if self.build_progress.is_none() {
            self.build_progress.set_default();
        }
        self.build_progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_progress(&mut self) -> super::common::ImageData {
        self.build_progress.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData buildable = 28;


    pub fn get_buildable(&self) -> &super::common::ImageData {
        self.buildable.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_buildable(&mut self) {
        self.buildable.clear();
    }

    pub fn has_buildable(&self) -> bool {
        self.buildable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buildable(&mut self, v: super::common::ImageData) {
        self.buildable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buildable(&mut self) -> &mut super::common::ImageData {
        if self.buildable.is_none() {
            self.buildable.set_default();
        }
        self.buildable.as_mut().unwrap()
    }

    // Take field
    pub fn take_buildable(&mut self) -> super::common::ImageData {
        self.buildable.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData pathable = 29;


    pub fn get_pathable(&self) -> &super::common::ImageData {
        self.pathable.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pathable(&mut self) {
        self.pathable.clear();
    }

    pub fn has_pathable(&self) -> bool {
        self.pathable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pathable(&mut self, v: super::common::ImageData) {
        self.pathable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pathable(&mut self) -> &mut super::common::ImageData {
        if self.pathable.is_none() {
            self.pathable.set_default();
        }
        self.pathable.as_mut().unwrap()
    }

    // Take field
    pub fn take_pathable(&mut self) -> super::common::ImageData {
        self.pathable.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData placeholder = 30;


    pub fn get_placeholder(&self) -> &super::common::ImageData {
        self.placeholder.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_placeholder(&mut self) {
        self.placeholder.clear();
    }

    pub fn has_placeholder(&self) -> bool {
        self.placeholder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placeholder(&mut self, v: super::common::ImageData) {
        self.placeholder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placeholder(&mut self) -> &mut super::common::ImageData {
        if self.placeholder.is_none() {
            self.placeholder.set_default();
        }
        self.placeholder.as_mut().unwrap()
    }

    // Take field
    pub fn take_placeholder(&mut self) -> super::common::ImageData {
        self.placeholder.take().unwrap_or_else(|| super::common::ImageData::new())
    }
}

impl ::protobuf::Message for FeatureLayers {
    fn is_initialized(&self) -> bool {
        for v in &self.height_map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility_map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creep {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.power {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selected {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_hit_points {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_hit_points_ratio {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_energy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_energy_ratio {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_shields {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_shields_ratio {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_relative {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_density_aa {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_density {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.effects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hallucinations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cloaked {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blip {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buffs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buff_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.build_progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buildable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pathable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.placeholder {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height_map)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility_map)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creep)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.power)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selected)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_hit_points)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_hit_points_ratio)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_energy)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_energy_ratio)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_shields)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_shields_ratio)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_relative)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_density_aa)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_density)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.effects)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hallucinations)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloaked)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blip)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buffs)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buff_duration)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.active)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.build_progress)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buildable)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pathable)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.placeholder)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.visibility_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.creep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.power.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_hit_points.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_hit_points_ratio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_energy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_energy_ratio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_shields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_shields_ratio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player_relative.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_density_aa.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_density.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.effects.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hallucinations.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cloaked.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blip.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buffs.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buff_duration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.active.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.build_progress.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buildable.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pathable.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.placeholder.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height_map.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.visibility_map.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.creep.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.power.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player_id.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_type.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selected.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_hit_points.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_hit_points_ratio.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_energy.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_energy_ratio.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_shields.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_shields_ratio.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player_relative.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_density_aa.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_density.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.effects.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hallucinations.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cloaked.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blip.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buffs.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buff_duration.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.active.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.build_progress.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buildable.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pathable.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.placeholder.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureLayers {
        FeatureLayers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "height_map",
                |m: &FeatureLayers| { &m.height_map },
                |m: &mut FeatureLayers| { &mut m.height_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "visibility_map",
                |m: &FeatureLayers| { &m.visibility_map },
                |m: &mut FeatureLayers| { &mut m.visibility_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "creep",
                |m: &FeatureLayers| { &m.creep },
                |m: &mut FeatureLayers| { &mut m.creep },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "power",
                |m: &FeatureLayers| { &m.power },
                |m: &mut FeatureLayers| { &mut m.power },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "player_id",
                |m: &FeatureLayers| { &m.player_id },
                |m: &mut FeatureLayers| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_type",
                |m: &FeatureLayers| { &m.unit_type },
                |m: &mut FeatureLayers| { &mut m.unit_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "selected",
                |m: &FeatureLayers| { &m.selected },
                |m: &mut FeatureLayers| { &mut m.selected },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_hit_points",
                |m: &FeatureLayers| { &m.unit_hit_points },
                |m: &mut FeatureLayers| { &mut m.unit_hit_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_hit_points_ratio",
                |m: &FeatureLayers| { &m.unit_hit_points_ratio },
                |m: &mut FeatureLayers| { &mut m.unit_hit_points_ratio },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_energy",
                |m: &FeatureLayers| { &m.unit_energy },
                |m: &mut FeatureLayers| { &mut m.unit_energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_energy_ratio",
                |m: &FeatureLayers| { &m.unit_energy_ratio },
                |m: &mut FeatureLayers| { &mut m.unit_energy_ratio },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_shields",
                |m: &FeatureLayers| { &m.unit_shields },
                |m: &mut FeatureLayers| { &mut m.unit_shields },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_shields_ratio",
                |m: &FeatureLayers| { &m.unit_shields_ratio },
                |m: &mut FeatureLayers| { &mut m.unit_shields_ratio },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "player_relative",
                |m: &FeatureLayers| { &m.player_relative },
                |m: &mut FeatureLayers| { &mut m.player_relative },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_density_aa",
                |m: &FeatureLayers| { &m.unit_density_aa },
                |m: &mut FeatureLayers| { &mut m.unit_density_aa },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_density",
                |m: &FeatureLayers| { &m.unit_density },
                |m: &mut FeatureLayers| { &mut m.unit_density },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "effects",
                |m: &FeatureLayers| { &m.effects },
                |m: &mut FeatureLayers| { &mut m.effects },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "hallucinations",
                |m: &FeatureLayers| { &m.hallucinations },
                |m: &mut FeatureLayers| { &mut m.hallucinations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "cloaked",
                |m: &FeatureLayers| { &m.cloaked },
                |m: &mut FeatureLayers| { &mut m.cloaked },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "blip",
                |m: &FeatureLayers| { &m.blip },
                |m: &mut FeatureLayers| { &mut m.blip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "buffs",
                |m: &FeatureLayers| { &m.buffs },
                |m: &mut FeatureLayers| { &mut m.buffs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "buff_duration",
                |m: &FeatureLayers| { &m.buff_duration },
                |m: &mut FeatureLayers| { &mut m.buff_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "active",
                |m: &FeatureLayers| { &m.active },
                |m: &mut FeatureLayers| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "build_progress",
                |m: &FeatureLayers| { &m.build_progress },
                |m: &mut FeatureLayers| { &mut m.build_progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "buildable",
                |m: &FeatureLayers| { &m.buildable },
                |m: &mut FeatureLayers| { &mut m.buildable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "pathable",
                |m: &FeatureLayers| { &m.pathable },
                |m: &mut FeatureLayers| { &mut m.pathable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "placeholder",
                |m: &FeatureLayers| { &m.placeholder },
                |m: &mut FeatureLayers| { &mut m.placeholder },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureLayers>(
                "FeatureLayers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureLayers {
        static instance: ::protobuf::rt::LazyV2<FeatureLayers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureLayers::new)
    }
}

impl ::protobuf::Clear for FeatureLayers {
    fn clear(&mut self) {
        self.height_map.clear();
        self.visibility_map.clear();
        self.creep.clear();
        self.power.clear();
        self.player_id.clear();
        self.unit_type.clear();
        self.selected.clear();
        self.unit_hit_points.clear();
        self.unit_hit_points_ratio.clear();
        self.unit_energy.clear();
        self.unit_energy_ratio.clear();
        self.unit_shields.clear();
        self.unit_shields_ratio.clear();
        self.player_relative.clear();
        self.unit_density_aa.clear();
        self.unit_density.clear();
        self.effects.clear();
        self.hallucinations.clear();
        self.cloaked.clear();
        self.blip.clear();
        self.buffs.clear();
        self.buff_duration.clear();
        self.active.clear();
        self.build_progress.clear();
        self.buildable.clear();
        self.pathable.clear();
        self.placeholder.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureLayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureLayers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureLayersMinimap {
    // message fields
    pub height_map: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub visibility_map: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub creep: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub camera: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub player_id: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub player_relative: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub selected: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub alerts: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub buildable: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub pathable: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub unit_type: ::protobuf::SingularPtrField<super::common::ImageData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeatureLayersMinimap {
    fn default() -> &'a FeatureLayersMinimap {
        <FeatureLayersMinimap as ::protobuf::Message>::default_instance()
    }
}

impl FeatureLayersMinimap {
    pub fn new() -> FeatureLayersMinimap {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ImageData height_map = 1;


    pub fn get_height_map(&self) -> &super::common::ImageData {
        self.height_map.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_height_map(&mut self) {
        self.height_map.clear();
    }

    pub fn has_height_map(&self) -> bool {
        self.height_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height_map(&mut self, v: super::common::ImageData) {
        self.height_map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_height_map(&mut self) -> &mut super::common::ImageData {
        if self.height_map.is_none() {
            self.height_map.set_default();
        }
        self.height_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_height_map(&mut self) -> super::common::ImageData {
        self.height_map.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData visibility_map = 2;


    pub fn get_visibility_map(&self) -> &super::common::ImageData {
        self.visibility_map.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility_map(&mut self) {
        self.visibility_map.clear();
    }

    pub fn has_visibility_map(&self) -> bool {
        self.visibility_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility_map(&mut self, v: super::common::ImageData) {
        self.visibility_map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility_map(&mut self) -> &mut super::common::ImageData {
        if self.visibility_map.is_none() {
            self.visibility_map.set_default();
        }
        self.visibility_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility_map(&mut self) -> super::common::ImageData {
        self.visibility_map.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData creep = 3;


    pub fn get_creep(&self) -> &super::common::ImageData {
        self.creep.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creep(&mut self) {
        self.creep.clear();
    }

    pub fn has_creep(&self) -> bool {
        self.creep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creep(&mut self, v: super::common::ImageData) {
        self.creep = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creep(&mut self) -> &mut super::common::ImageData {
        if self.creep.is_none() {
            self.creep.set_default();
        }
        self.creep.as_mut().unwrap()
    }

    // Take field
    pub fn take_creep(&mut self) -> super::common::ImageData {
        self.creep.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData camera = 4;


    pub fn get_camera(&self) -> &super::common::ImageData {
        self.camera.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_camera(&mut self) {
        self.camera.clear();
    }

    pub fn has_camera(&self) -> bool {
        self.camera.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera(&mut self, v: super::common::ImageData) {
        self.camera = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera(&mut self) -> &mut super::common::ImageData {
        if self.camera.is_none() {
            self.camera.set_default();
        }
        self.camera.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera(&mut self) -> super::common::ImageData {
        self.camera.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData player_id = 5;


    pub fn get_player_id(&self) -> &super::common::ImageData {
        self.player_id.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_id(&mut self) {
        self.player_id.clear();
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: super::common::ImageData) {
        self.player_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_id(&mut self) -> &mut super::common::ImageData {
        if self.player_id.is_none() {
            self.player_id.set_default();
        }
        self.player_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_id(&mut self) -> super::common::ImageData {
        self.player_id.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData player_relative = 6;


    pub fn get_player_relative(&self) -> &super::common::ImageData {
        self.player_relative.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_relative(&mut self) {
        self.player_relative.clear();
    }

    pub fn has_player_relative(&self) -> bool {
        self.player_relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_relative(&mut self, v: super::common::ImageData) {
        self.player_relative = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_relative(&mut self) -> &mut super::common::ImageData {
        if self.player_relative.is_none() {
            self.player_relative.set_default();
        }
        self.player_relative.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_relative(&mut self) -> super::common::ImageData {
        self.player_relative.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData selected = 7;


    pub fn get_selected(&self) -> &super::common::ImageData {
        self.selected.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selected(&mut self) {
        self.selected.clear();
    }

    pub fn has_selected(&self) -> bool {
        self.selected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected(&mut self, v: super::common::ImageData) {
        self.selected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selected(&mut self) -> &mut super::common::ImageData {
        if self.selected.is_none() {
            self.selected.set_default();
        }
        self.selected.as_mut().unwrap()
    }

    // Take field
    pub fn take_selected(&mut self) -> super::common::ImageData {
        self.selected.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData alerts = 9;


    pub fn get_alerts(&self) -> &super::common::ImageData {
        self.alerts.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_alerts(&mut self) {
        self.alerts.clear();
    }

    pub fn has_alerts(&self) -> bool {
        self.alerts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alerts(&mut self, v: super::common::ImageData) {
        self.alerts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alerts(&mut self) -> &mut super::common::ImageData {
        if self.alerts.is_none() {
            self.alerts.set_default();
        }
        self.alerts.as_mut().unwrap()
    }

    // Take field
    pub fn take_alerts(&mut self) -> super::common::ImageData {
        self.alerts.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData buildable = 10;


    pub fn get_buildable(&self) -> &super::common::ImageData {
        self.buildable.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_buildable(&mut self) {
        self.buildable.clear();
    }

    pub fn has_buildable(&self) -> bool {
        self.buildable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buildable(&mut self, v: super::common::ImageData) {
        self.buildable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buildable(&mut self) -> &mut super::common::ImageData {
        if self.buildable.is_none() {
            self.buildable.set_default();
        }
        self.buildable.as_mut().unwrap()
    }

    // Take field
    pub fn take_buildable(&mut self) -> super::common::ImageData {
        self.buildable.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData pathable = 11;


    pub fn get_pathable(&self) -> &super::common::ImageData {
        self.pathable.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pathable(&mut self) {
        self.pathable.clear();
    }

    pub fn has_pathable(&self) -> bool {
        self.pathable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pathable(&mut self, v: super::common::ImageData) {
        self.pathable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pathable(&mut self) -> &mut super::common::ImageData {
        if self.pathable.is_none() {
            self.pathable.set_default();
        }
        self.pathable.as_mut().unwrap()
    }

    // Take field
    pub fn take_pathable(&mut self) -> super::common::ImageData {
        self.pathable.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData unit_type = 8;


    pub fn get_unit_type(&self) -> &super::common::ImageData {
        self.unit_type.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit_type(&mut self) {
        self.unit_type.clear();
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: super::common::ImageData) {
        self.unit_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_type(&mut self) -> &mut super::common::ImageData {
        if self.unit_type.is_none() {
            self.unit_type.set_default();
        }
        self.unit_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_type(&mut self) -> super::common::ImageData {
        self.unit_type.take().unwrap_or_else(|| super::common::ImageData::new())
    }
}

impl ::protobuf::Message for FeatureLayersMinimap {
    fn is_initialized(&self) -> bool {
        for v in &self.height_map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility_map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creep {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.camera {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_relative {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selected {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alerts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buildable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pathable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.height_map)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility_map)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creep)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_relative)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selected)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.alerts)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buildable)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pathable)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.height_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.visibility_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.creep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.camera.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player_relative.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.alerts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buildable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pathable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.height_map.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.visibility_map.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.creep.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.camera.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player_id.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player_relative.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selected.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.alerts.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buildable.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pathable.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit_type.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureLayersMinimap {
        FeatureLayersMinimap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "height_map",
                |m: &FeatureLayersMinimap| { &m.height_map },
                |m: &mut FeatureLayersMinimap| { &mut m.height_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "visibility_map",
                |m: &FeatureLayersMinimap| { &m.visibility_map },
                |m: &mut FeatureLayersMinimap| { &mut m.visibility_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "creep",
                |m: &FeatureLayersMinimap| { &m.creep },
                |m: &mut FeatureLayersMinimap| { &mut m.creep },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "camera",
                |m: &FeatureLayersMinimap| { &m.camera },
                |m: &mut FeatureLayersMinimap| { &mut m.camera },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "player_id",
                |m: &FeatureLayersMinimap| { &m.player_id },
                |m: &mut FeatureLayersMinimap| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "player_relative",
                |m: &FeatureLayersMinimap| { &m.player_relative },
                |m: &mut FeatureLayersMinimap| { &mut m.player_relative },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "selected",
                |m: &FeatureLayersMinimap| { &m.selected },
                |m: &mut FeatureLayersMinimap| { &mut m.selected },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "alerts",
                |m: &FeatureLayersMinimap| { &m.alerts },
                |m: &mut FeatureLayersMinimap| { &mut m.alerts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "buildable",
                |m: &FeatureLayersMinimap| { &m.buildable },
                |m: &mut FeatureLayersMinimap| { &mut m.buildable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "pathable",
                |m: &FeatureLayersMinimap| { &m.pathable },
                |m: &mut FeatureLayersMinimap| { &mut m.pathable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "unit_type",
                |m: &FeatureLayersMinimap| { &m.unit_type },
                |m: &mut FeatureLayersMinimap| { &mut m.unit_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeatureLayersMinimap>(
                "FeatureLayersMinimap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeatureLayersMinimap {
        static instance: ::protobuf::rt::LazyV2<FeatureLayersMinimap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeatureLayersMinimap::new)
    }
}

impl ::protobuf::Clear for FeatureLayersMinimap {
    fn clear(&mut self) {
        self.height_map.clear();
        self.visibility_map.clear();
        self.creep.clear();
        self.camera.clear();
        self.player_id.clear();
        self.player_relative.clear();
        self.selected.clear();
        self.alerts.clear();
        self.buildable.clear();
        self.pathable.clear();
        self.unit_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureLayersMinimap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureLayersMinimap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObservationRender {
    // message fields
    pub map: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub minimap: ::protobuf::SingularPtrField<super::common::ImageData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObservationRender {
    fn default() -> &'a ObservationRender {
        <ObservationRender as ::protobuf::Message>::default_instance()
    }
}

impl ObservationRender {
    pub fn new() -> ObservationRender {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ImageData map = 1;


    pub fn get_map(&self) -> &super::common::ImageData {
        self.map.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: super::common::ImageData) {
        self.map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut super::common::ImageData {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> super::common::ImageData {
        self.map.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData minimap = 2;


    pub fn get_minimap(&self) -> &super::common::ImageData {
        self.minimap.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_minimap(&mut self) {
        self.minimap.clear();
    }

    pub fn has_minimap(&self) -> bool {
        self.minimap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimap(&mut self, v: super::common::ImageData) {
        self.minimap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimap(&mut self) -> &mut super::common::ImageData {
        if self.minimap.is_none() {
            self.minimap.set_default();
        }
        self.minimap.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimap(&mut self) -> super::common::ImageData {
        self.minimap.take().unwrap_or_else(|| super::common::ImageData::new())
    }
}

impl ::protobuf::Message for ObservationRender {
    fn is_initialized(&self) -> bool {
        for v in &self.map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.minimap {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.map)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.minimap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.minimap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.map.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.minimap.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationRender {
        ObservationRender::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "map",
                |m: &ObservationRender| { &m.map },
                |m: &mut ObservationRender| { &mut m.map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "minimap",
                |m: &ObservationRender| { &m.minimap },
                |m: &mut ObservationRender| { &mut m.minimap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObservationRender>(
                "ObservationRender",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObservationRender {
        static instance: ::protobuf::rt::LazyV2<ObservationRender> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObservationRender::new)
    }
}

impl ::protobuf::Clear for ObservationRender {
    fn clear(&mut self) {
        self.map.clear();
        self.minimap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationRender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationRender {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSpatial {
    // message oneof groups
    pub action: ::std::option::Option<ActionSpatial_oneof_action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSpatial {
    fn default() -> &'a ActionSpatial {
        <ActionSpatial as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ActionSpatial_oneof_action {
    unit_command(ActionSpatialUnitCommand),
    camera_move(ActionSpatialCameraMove),
    unit_selection_point(ActionSpatialUnitSelectionPoint),
    unit_selection_rect(ActionSpatialUnitSelectionRect),
}

impl ActionSpatial {
    pub fn new() -> ActionSpatial {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionSpatialUnitCommand unit_command = 1;


    pub fn get_unit_command(&self) -> &ActionSpatialUnitCommand {
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_command(ref v)) => v,
            _ => <ActionSpatialUnitCommand as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_unit_command(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_unit_command(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_command(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_command(&mut self, v: ActionSpatialUnitCommand) {
        self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_command(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_command(&mut self) -> &mut ActionSpatialUnitCommand {
        if let ::std::option::Option::Some(ActionSpatial_oneof_action::unit_command(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_command(ActionSpatialUnitCommand::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_command(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_command(&mut self) -> ActionSpatialUnitCommand {
        if self.has_unit_command() {
            match self.action.take() {
                ::std::option::Option::Some(ActionSpatial_oneof_action::unit_command(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSpatialUnitCommand::new()
        }
    }

    // optional .SC2APIProtocol.ActionSpatialCameraMove camera_move = 2;


    pub fn get_camera_move(&self) -> &ActionSpatialCameraMove {
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::camera_move(ref v)) => v,
            _ => <ActionSpatialCameraMove as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_camera_move(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_move(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::camera_move(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_move(&mut self, v: ActionSpatialCameraMove) {
        self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::camera_move(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_move(&mut self) -> &mut ActionSpatialCameraMove {
        if let ::std::option::Option::Some(ActionSpatial_oneof_action::camera_move(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::camera_move(ActionSpatialCameraMove::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::camera_move(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_move(&mut self) -> ActionSpatialCameraMove {
        if self.has_camera_move() {
            match self.action.take() {
                ::std::option::Option::Some(ActionSpatial_oneof_action::camera_move(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSpatialCameraMove::new()
        }
    }

    // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;


    pub fn get_unit_selection_point(&self) -> &ActionSpatialUnitSelectionPoint {
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_point(ref v)) => v,
            _ => <ActionSpatialUnitSelectionPoint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_unit_selection_point(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_unit_selection_point(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_point(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_selection_point(&mut self, v: ActionSpatialUnitSelectionPoint) {
        self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_point(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_selection_point(&mut self) -> &mut ActionSpatialUnitSelectionPoint {
        if let ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_point(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_point(ActionSpatialUnitSelectionPoint::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_point(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_selection_point(&mut self) -> ActionSpatialUnitSelectionPoint {
        if self.has_unit_selection_point() {
            match self.action.take() {
                ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_point(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSpatialUnitSelectionPoint::new()
        }
    }

    // optional .SC2APIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;


    pub fn get_unit_selection_rect(&self) -> &ActionSpatialUnitSelectionRect {
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_rect(ref v)) => v,
            _ => <ActionSpatialUnitSelectionRect as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_unit_selection_rect(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_unit_selection_rect(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_rect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_selection_rect(&mut self, v: ActionSpatialUnitSelectionRect) {
        self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_rect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_selection_rect(&mut self) -> &mut ActionSpatialUnitSelectionRect {
        if let ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_rect(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_rect(ActionSpatialUnitSelectionRect::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_rect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_selection_rect(&mut self) -> ActionSpatialUnitSelectionRect {
        if self.has_unit_selection_rect() {
            match self.action.take() {
                ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_rect(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSpatialUnitSelectionRect::new()
        }
    }
}

impl ::protobuf::Message for ActionSpatial {
    fn is_initialized(&self) -> bool {
        if let Some(ActionSpatial_oneof_action::unit_command(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionSpatial_oneof_action::camera_move(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionSpatial_oneof_action::unit_selection_point(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionSpatial_oneof_action::unit_selection_rect(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_command(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::camera_move(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_point(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionSpatial_oneof_action::unit_selection_rect(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &ActionSpatial_oneof_action::unit_command(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionSpatial_oneof_action::camera_move(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionSpatial_oneof_action::unit_selection_point(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionSpatial_oneof_action::unit_selection_rect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &ActionSpatial_oneof_action::unit_command(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionSpatial_oneof_action::camera_move(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionSpatial_oneof_action::unit_selection_point(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionSpatial_oneof_action::unit_selection_rect(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSpatial {
        ActionSpatial::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionSpatialUnitCommand>(
                "unit_command",
                ActionSpatial::has_unit_command,
                ActionSpatial::get_unit_command,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionSpatialCameraMove>(
                "camera_move",
                ActionSpatial::has_camera_move,
                ActionSpatial::get_camera_move,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionSpatialUnitSelectionPoint>(
                "unit_selection_point",
                ActionSpatial::has_unit_selection_point,
                ActionSpatial::get_unit_selection_point,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionSpatialUnitSelectionRect>(
                "unit_selection_rect",
                ActionSpatial::has_unit_selection_rect,
                ActionSpatial::get_unit_selection_rect,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSpatial>(
                "ActionSpatial",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSpatial {
        static instance: ::protobuf::rt::LazyV2<ActionSpatial> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSpatial::new)
    }
}

impl ::protobuf::Clear for ActionSpatial {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSpatial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatial {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSpatialUnitCommand {
    // message fields
    pub ability_id: ::std::option::Option<i32>,
    pub queue_command: ::std::option::Option<bool>,
    // message oneof groups
    pub target: ::std::option::Option<ActionSpatialUnitCommand_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSpatialUnitCommand {
    fn default() -> &'a ActionSpatialUnitCommand {
        <ActionSpatialUnitCommand as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ActionSpatialUnitCommand_oneof_target {
    target_screen_coord(super::common::PointI),
    target_minimap_coord(super::common::PointI),
}

impl ActionSpatialUnitCommand {
    pub fn new() -> ActionSpatialUnitCommand {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;


    pub fn get_ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }
    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.PointI target_screen_coord = 2;


    pub fn get_target_screen_coord(&self) -> &super::common::PointI {
        match self.target {
            ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(ref v)) => v,
            _ => <super::common::PointI as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_target_screen_coord(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_screen_coord(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_screen_coord(&mut self, v: super::common::PointI) {
        self.target = ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_screen_coord(&mut self) -> &mut super::common::PointI {
        if let ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(super::common::PointI::new()));
        }
        match self.target {
            ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_screen_coord(&mut self) -> super::common::PointI {
        if self.has_target_screen_coord() {
            match self.target.take() {
                ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::PointI::new()
        }
    }

    // optional .SC2APIProtocol.PointI target_minimap_coord = 3;


    pub fn get_target_minimap_coord(&self) -> &super::common::PointI {
        match self.target {
            ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(ref v)) => v,
            _ => <super::common::PointI as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_target_minimap_coord(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_minimap_coord(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_minimap_coord(&mut self, v: super::common::PointI) {
        self.target = ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_minimap_coord(&mut self) -> &mut super::common::PointI {
        if let ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(super::common::PointI::new()));
        }
        match self.target {
            ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_minimap_coord(&mut self) -> super::common::PointI {
        if self.has_target_minimap_coord() {
            match self.target.take() {
                ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::PointI::new()
        }
    }

    // optional bool queue_command = 4;


    pub fn get_queue_command(&self) -> bool {
        self.queue_command.unwrap_or(false)
    }
    pub fn clear_queue_command(&mut self) {
        self.queue_command = ::std::option::Option::None;
    }

    pub fn has_queue_command(&self) -> bool {
        self.queue_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_command(&mut self, v: bool) {
        self.queue_command = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionSpatialUnitCommand {
    fn is_initialized(&self) -> bool {
        if let Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_screen_coord(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ActionSpatialUnitCommand_oneof_target::target_minimap_coord(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.queue_command = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.queue_command {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ActionSpatialUnitCommand_oneof_target::target_screen_coord(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionSpatialUnitCommand_oneof_target::target_minimap_coord(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.queue_command {
            os.write_bool(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ActionSpatialUnitCommand_oneof_target::target_screen_coord(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionSpatialUnitCommand_oneof_target::target_minimap_coord(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSpatialUnitCommand {
        ActionSpatialUnitCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ability_id",
                |m: &ActionSpatialUnitCommand| { &m.ability_id },
                |m: &mut ActionSpatialUnitCommand| { &mut m.ability_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::common::PointI>(
                "target_screen_coord",
                ActionSpatialUnitCommand::has_target_screen_coord,
                ActionSpatialUnitCommand::get_target_screen_coord,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::common::PointI>(
                "target_minimap_coord",
                ActionSpatialUnitCommand::has_target_minimap_coord,
                ActionSpatialUnitCommand::get_target_minimap_coord,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "queue_command",
                |m: &ActionSpatialUnitCommand| { &m.queue_command },
                |m: &mut ActionSpatialUnitCommand| { &mut m.queue_command },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSpatialUnitCommand>(
                "ActionSpatialUnitCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSpatialUnitCommand {
        static instance: ::protobuf::rt::LazyV2<ActionSpatialUnitCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSpatialUnitCommand::new)
    }
}

impl ::protobuf::Clear for ActionSpatialUnitCommand {
    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.queue_command = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSpatialUnitCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialUnitCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSpatialCameraMove {
    // message fields
    pub center_minimap: ::protobuf::SingularPtrField<super::common::PointI>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSpatialCameraMove {
    fn default() -> &'a ActionSpatialCameraMove {
        <ActionSpatialCameraMove as ::protobuf::Message>::default_instance()
    }
}

impl ActionSpatialCameraMove {
    pub fn new() -> ActionSpatialCameraMove {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.PointI center_minimap = 1;


    pub fn get_center_minimap(&self) -> &super::common::PointI {
        self.center_minimap.as_ref().unwrap_or_else(|| <super::common::PointI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_center_minimap(&mut self) {
        self.center_minimap.clear();
    }

    pub fn has_center_minimap(&self) -> bool {
        self.center_minimap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_minimap(&mut self, v: super::common::PointI) {
        self.center_minimap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_center_minimap(&mut self) -> &mut super::common::PointI {
        if self.center_minimap.is_none() {
            self.center_minimap.set_default();
        }
        self.center_minimap.as_mut().unwrap()
    }

    // Take field
    pub fn take_center_minimap(&mut self) -> super::common::PointI {
        self.center_minimap.take().unwrap_or_else(|| super::common::PointI::new())
    }
}

impl ::protobuf::Message for ActionSpatialCameraMove {
    fn is_initialized(&self) -> bool {
        for v in &self.center_minimap {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.center_minimap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.center_minimap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.center_minimap.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSpatialCameraMove {
        ActionSpatialCameraMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::PointI>>(
                "center_minimap",
                |m: &ActionSpatialCameraMove| { &m.center_minimap },
                |m: &mut ActionSpatialCameraMove| { &mut m.center_minimap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSpatialCameraMove>(
                "ActionSpatialCameraMove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSpatialCameraMove {
        static instance: ::protobuf::rt::LazyV2<ActionSpatialCameraMove> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSpatialCameraMove::new)
    }
}

impl ::protobuf::Clear for ActionSpatialCameraMove {
    fn clear(&mut self) {
        self.center_minimap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSpatialCameraMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialCameraMove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSpatialUnitSelectionPoint {
    // message fields
    pub selection_screen_coord: ::protobuf::SingularPtrField<super::common::PointI>,
    pub field_type: ::std::option::Option<ActionSpatialUnitSelectionPoint_Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSpatialUnitSelectionPoint {
    fn default() -> &'a ActionSpatialUnitSelectionPoint {
        <ActionSpatialUnitSelectionPoint as ::protobuf::Message>::default_instance()
    }
}

impl ActionSpatialUnitSelectionPoint {
    pub fn new() -> ActionSpatialUnitSelectionPoint {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.PointI selection_screen_coord = 1;


    pub fn get_selection_screen_coord(&self) -> &super::common::PointI {
        self.selection_screen_coord.as_ref().unwrap_or_else(|| <super::common::PointI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selection_screen_coord(&mut self) {
        self.selection_screen_coord.clear();
    }

    pub fn has_selection_screen_coord(&self) -> bool {
        self.selection_screen_coord.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_screen_coord(&mut self, v: super::common::PointI) {
        self.selection_screen_coord = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selection_screen_coord(&mut self) -> &mut super::common::PointI {
        if self.selection_screen_coord.is_none() {
            self.selection_screen_coord.set_default();
        }
        self.selection_screen_coord.as_mut().unwrap()
    }

    // Take field
    pub fn take_selection_screen_coord(&mut self) -> super::common::PointI {
        self.selection_screen_coord.take().unwrap_or_else(|| super::common::PointI::new())
    }

    // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;


    pub fn get_field_type(&self) -> ActionSpatialUnitSelectionPoint_Type {
        self.field_type.unwrap_or(ActionSpatialUnitSelectionPoint_Type::Select)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ActionSpatialUnitSelectionPoint_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionSpatialUnitSelectionPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.selection_screen_coord {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selection_screen_coord)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.selection_screen_coord.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.selection_screen_coord.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSpatialUnitSelectionPoint {
        ActionSpatialUnitSelectionPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::PointI>>(
                "selection_screen_coord",
                |m: &ActionSpatialUnitSelectionPoint| { &m.selection_screen_coord },
                |m: &mut ActionSpatialUnitSelectionPoint| { &mut m.selection_screen_coord },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionSpatialUnitSelectionPoint_Type>>(
                "type",
                |m: &ActionSpatialUnitSelectionPoint| { &m.field_type },
                |m: &mut ActionSpatialUnitSelectionPoint| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSpatialUnitSelectionPoint>(
                "ActionSpatialUnitSelectionPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSpatialUnitSelectionPoint {
        static instance: ::protobuf::rt::LazyV2<ActionSpatialUnitSelectionPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSpatialUnitSelectionPoint::new)
    }
}

impl ::protobuf::Clear for ActionSpatialUnitSelectionPoint {
    fn clear(&mut self) {
        self.selection_screen_coord.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSpatialUnitSelectionPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialUnitSelectionPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionSpatialUnitSelectionPoint_Type {
    Select = 1,
    Toggle = 2,
    AllType = 3,
    AddAllType = 4,
}

impl ::protobuf::ProtobufEnum for ActionSpatialUnitSelectionPoint_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionSpatialUnitSelectionPoint_Type> {
        match value {
            1 => ::std::option::Option::Some(ActionSpatialUnitSelectionPoint_Type::Select),
            2 => ::std::option::Option::Some(ActionSpatialUnitSelectionPoint_Type::Toggle),
            3 => ::std::option::Option::Some(ActionSpatialUnitSelectionPoint_Type::AllType),
            4 => ::std::option::Option::Some(ActionSpatialUnitSelectionPoint_Type::AddAllType),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionSpatialUnitSelectionPoint_Type] = &[
            ActionSpatialUnitSelectionPoint_Type::Select,
            ActionSpatialUnitSelectionPoint_Type::Toggle,
            ActionSpatialUnitSelectionPoint_Type::AllType,
            ActionSpatialUnitSelectionPoint_Type::AddAllType,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ActionSpatialUnitSelectionPoint_Type>("ActionSpatialUnitSelectionPoint.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ActionSpatialUnitSelectionPoint_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ActionSpatialUnitSelectionPoint_Type {
    fn default() -> Self {
        ActionSpatialUnitSelectionPoint_Type::Select
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialUnitSelectionPoint_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSpatialUnitSelectionRect {
    // message fields
    pub selection_screen_coord: ::protobuf::RepeatedField<super::common::RectangleI>,
    pub selection_add: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionSpatialUnitSelectionRect {
    fn default() -> &'a ActionSpatialUnitSelectionRect {
        <ActionSpatialUnitSelectionRect as ::protobuf::Message>::default_instance()
    }
}

impl ActionSpatialUnitSelectionRect {
    pub fn new() -> ActionSpatialUnitSelectionRect {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.RectangleI selection_screen_coord = 1;


    pub fn get_selection_screen_coord(&self) -> &[super::common::RectangleI] {
        &self.selection_screen_coord
    }
    pub fn clear_selection_screen_coord(&mut self) {
        self.selection_screen_coord.clear();
    }

    // Param is passed by value, moved
    pub fn set_selection_screen_coord(&mut self, v: ::protobuf::RepeatedField<super::common::RectangleI>) {
        self.selection_screen_coord = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selection_screen_coord(&mut self) -> &mut ::protobuf::RepeatedField<super::common::RectangleI> {
        &mut self.selection_screen_coord
    }

    // Take field
    pub fn take_selection_screen_coord(&mut self) -> ::protobuf::RepeatedField<super::common::RectangleI> {
        ::std::mem::replace(&mut self.selection_screen_coord, ::protobuf::RepeatedField::new())
    }

    // optional bool selection_add = 2;


    pub fn get_selection_add(&self) -> bool {
        self.selection_add.unwrap_or(false)
    }
    pub fn clear_selection_add(&mut self) {
        self.selection_add = ::std::option::Option::None;
    }

    pub fn has_selection_add(&self) -> bool {
        self.selection_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_add(&mut self, v: bool) {
        self.selection_add = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionSpatialUnitSelectionRect {
    fn is_initialized(&self) -> bool {
        for v in &self.selection_screen_coord {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.selection_screen_coord)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selection_add = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.selection_screen_coord {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.selection_add {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.selection_screen_coord {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.selection_add {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSpatialUnitSelectionRect {
        ActionSpatialUnitSelectionRect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::RectangleI>>(
                "selection_screen_coord",
                |m: &ActionSpatialUnitSelectionRect| { &m.selection_screen_coord },
                |m: &mut ActionSpatialUnitSelectionRect| { &mut m.selection_screen_coord },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "selection_add",
                |m: &ActionSpatialUnitSelectionRect| { &m.selection_add },
                |m: &mut ActionSpatialUnitSelectionRect| { &mut m.selection_add },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionSpatialUnitSelectionRect>(
                "ActionSpatialUnitSelectionRect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionSpatialUnitSelectionRect {
        static instance: ::protobuf::rt::LazyV2<ActionSpatialUnitSelectionRect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionSpatialUnitSelectionRect::new)
    }
}

impl ::protobuf::Clear for ActionSpatialUnitSelectionRect {
    fn clear(&mut self) {
        self.selection_screen_coord.clear();
        self.selection_add = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSpatialUnitSelectionRect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialUnitSelectionRect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1es2clientprotocol/spatial.proto\x12\x0eSC2APIProtocol\x1a\x1ds2clie\
    ntprotocol/common.proto\"\xa1\x01\n\x17ObservationFeatureLayer\x127\n\
    \x07renders\x18\x01\x20\x01(\x0b2\x1d.SC2APIProtocol.FeatureLayersR\x07r\
    enders\x12M\n\x0fminimap_renders\x18\x02\x20\x01(\x0b2$.SC2APIProtocol.F\
    eatureLayersMinimapR\x0eminimapRenders\"\xe3\x0c\n\rFeatureLayers\x128\n\
    \nheight_map\x18\x01\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\theight\
    Map\x12@\n\x0evisibility_map\x18\x02\x20\x01(\x0b2\x19.SC2APIProtocol.Im\
    ageDataR\rvisibilityMap\x12/\n\x05creep\x18\x03\x20\x01(\x0b2\x19.SC2API\
    Protocol.ImageDataR\x05creep\x12/\n\x05power\x18\x04\x20\x01(\x0b2\x19.S\
    C2APIProtocol.ImageDataR\x05power\x126\n\tplayer_id\x18\x05\x20\x01(\x0b\
    2\x19.SC2APIProtocol.ImageDataR\x08playerId\x126\n\tunit_type\x18\x06\
    \x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08unitType\x125\n\x08selec\
    ted\x18\x07\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08selected\x12A\
    \n\x0funit_hit_points\x18\x08\x20\x01(\x0b2\x19.SC2APIProtocol.ImageData\
    R\runitHitPoints\x12L\n\x15unit_hit_points_ratio\x18\x11\x20\x01(\x0b2\
    \x19.SC2APIProtocol.ImageDataR\x12unitHitPointsRatio\x12:\n\x0bunit_ener\
    gy\x18\t\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\nunitEnergy\x12E\n\
    \x11unit_energy_ratio\x18\x12\x20\x01(\x0b2\x19.SC2APIProtocol.ImageData\
    R\x0funitEnergyRatio\x12<\n\x0cunit_shields\x18\n\x20\x01(\x0b2\x19.SC2A\
    PIProtocol.ImageDataR\x0bunitShields\x12G\n\x12unit_shields_ratio\x18\
    \x13\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x10unitShieldsRatio\x12\
    B\n\x0fplayer_relative\x18\x0b\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDat\
    aR\x0eplayerRelative\x12A\n\x0funit_density_aa\x18\x0e\x20\x01(\x0b2\x19\
    .SC2APIProtocol.ImageDataR\runitDensityAa\x12<\n\x0cunit_density\x18\x0f\
    \x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x0bunitDensity\x123\n\x07ef\
    fects\x18\x14\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x07effects\x12\
    A\n\x0ehallucinations\x18\x15\x20\x01(\x0b2\x19.SC2APIProtocol.ImageData\
    R\x0ehallucinations\x123\n\x07cloaked\x18\x16\x20\x01(\x0b2\x19.SC2APIPr\
    otocol.ImageDataR\x07cloaked\x12-\n\x04blip\x18\x17\x20\x01(\x0b2\x19.SC\
    2APIProtocol.ImageDataR\x04blip\x12/\n\x05buffs\x18\x18\x20\x01(\x0b2\
    \x19.SC2APIProtocol.ImageDataR\x05buffs\x12>\n\rbuff_duration\x18\x1a\
    \x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x0cbuffDuration\x121\n\x06a\
    ctive\x18\x19\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x06active\x12@\
    \n\x0ebuild_progress\x18\x1b\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\
    \rbuildProgress\x127\n\tbuildable\x18\x1c\x20\x01(\x0b2\x19.SC2APIProtoc\
    ol.ImageDataR\tbuildable\x125\n\x08pathable\x18\x1d\x20\x01(\x0b2\x19.SC\
    2APIProtocol.ImageDataR\x08pathable\x12;\n\x0bplaceholder\x18\x1e\x20\
    \x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x0bplaceholder\"\x84\x05\n\x14F\
    eatureLayersMinimap\x128\n\nheight_map\x18\x01\x20\x01(\x0b2\x19.SC2APIP\
    rotocol.ImageDataR\theightMap\x12@\n\x0evisibility_map\x18\x02\x20\x01(\
    \x0b2\x19.SC2APIProtocol.ImageDataR\rvisibilityMap\x12/\n\x05creep\x18\
    \x03\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x05creep\x121\n\x06came\
    ra\x18\x04\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x06camera\x126\n\
    \tplayer_id\x18\x05\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08playe\
    rId\x12B\n\x0fplayer_relative\x18\x06\x20\x01(\x0b2\x19.SC2APIProtocol.I\
    mageDataR\x0eplayerRelative\x125\n\x08selected\x18\x07\x20\x01(\x0b2\x19\
    .SC2APIProtocol.ImageDataR\x08selected\x121\n\x06alerts\x18\t\x20\x01(\
    \x0b2\x19.SC2APIProtocol.ImageDataR\x06alerts\x127\n\tbuildable\x18\n\
    \x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\tbuildable\x125\n\x08pathab\
    le\x18\x0b\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08pathable\x126\
    \n\tunit_type\x18\x08\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08uni\
    tType\"u\n\x11ObservationRender\x12+\n\x03map\x18\x01\x20\x01(\x0b2\x19.\
    SC2APIProtocol.ImageDataR\x03map\x123\n\x07minimap\x18\x02\x20\x01(\x0b2\
    \x19.SC2APIProtocol.ImageDataR\x07minimap\"\xfb\x02\n\rActionSpatial\x12\
    M\n\x0cunit_command\x18\x01\x20\x01(\x0b2(.SC2APIProtocol.ActionSpatialU\
    nitCommandH\0R\x0bunitCommand\x12J\n\x0bcamera_move\x18\x02\x20\x01(\x0b\
    2'.SC2APIProtocol.ActionSpatialCameraMoveH\0R\ncameraMove\x12c\n\x14unit\
    _selection_point\x18\x03\x20\x01(\x0b2/.SC2APIProtocol.ActionSpatialUnit\
    SelectionPointH\0R\x12unitSelectionPoint\x12`\n\x13unit_selection_rect\
    \x18\x04\x20\x01(\x0b2..SC2APIProtocol.ActionSpatialUnitSelectionRectH\0\
    R\x11unitSelectionRectB\x08\n\x06action\"\xfe\x01\n\x18ActionSpatialUnit\
    Command\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabilityId\x12H\n\
    \x13target_screen_coord\x18\x02\x20\x01(\x0b2\x16.SC2APIProtocol.PointIH\
    \0R\x11targetScreenCoord\x12J\n\x14target_minimap_coord\x18\x03\x20\x01(\
    \x0b2\x16.SC2APIProtocol.PointIH\0R\x12targetMinimapCoord\x12#\n\rqueue_\
    command\x18\x04\x20\x01(\x08R\x0cqueueCommandB\x08\n\x06target\"X\n\x17A\
    ctionSpatialCameraMove\x12=\n\x0ecenter_minimap\x18\x01\x20\x01(\x0b2\
    \x16.SC2APIProtocol.PointIR\rcenterMinimap\"\xf6\x01\n\x1fActionSpatialU\
    nitSelectionPoint\x12L\n\x16selection_screen_coord\x18\x01\x20\x01(\x0b2\
    \x16.SC2APIProtocol.PointIR\x14selectionScreenCoord\x12H\n\x04type\x18\
    \x02\x20\x01(\x0e24.SC2APIProtocol.ActionSpatialUnitSelectionPoint.TypeR\
    \x04type\";\n\x04Type\x12\n\n\x06Select\x10\x01\x12\n\n\x06Toggle\x10\
    \x02\x12\x0b\n\x07AllType\x10\x03\x12\x0e\n\nAddAllType\x10\x04\"\x97\
    \x01\n\x1eActionSpatialUnitSelectionRect\x12P\n\x16selection_screen_coor\
    d\x18\x01\x20\x03(\x0b2\x1a.SC2APIProtocol.RectangleIR\x14selectionScree\
    nCoord\x12#\n\rselection_add\x18\x02\x20\x01(\x08R\x0cselectionAdd\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
