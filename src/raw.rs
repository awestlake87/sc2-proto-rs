// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `s2clientprotocol/raw.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct StartRaw {
    // message fields
    pub map_size: ::protobuf::SingularPtrField<super::common::Size2DI>,
    pub pathing_grid: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub terrain_height: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub placement_grid: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub playable_area: ::protobuf::SingularPtrField<super::common::RectangleI>,
    pub start_locations: ::protobuf::RepeatedField<super::common::Point2D>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartRaw {
    fn default() -> &'a StartRaw {
        <StartRaw as ::protobuf::Message>::default_instance()
    }
}

impl StartRaw {
    pub fn new() -> StartRaw {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Size2DI map_size = 1;


    pub fn get_map_size(&self) -> &super::common::Size2DI {
        self.map_size.as_ref().unwrap_or_else(|| <super::common::Size2DI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_map_size(&mut self) {
        self.map_size.clear();
    }

    pub fn has_map_size(&self) -> bool {
        self.map_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_size(&mut self, v: super::common::Size2DI) {
        self.map_size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_size(&mut self) -> &mut super::common::Size2DI {
        if self.map_size.is_none() {
            self.map_size.set_default();
        }
        self.map_size.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_size(&mut self) -> super::common::Size2DI {
        self.map_size.take().unwrap_or_else(|| super::common::Size2DI::new())
    }

    // optional .SC2APIProtocol.ImageData pathing_grid = 2;


    pub fn get_pathing_grid(&self) -> &super::common::ImageData {
        self.pathing_grid.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pathing_grid(&mut self) {
        self.pathing_grid.clear();
    }

    pub fn has_pathing_grid(&self) -> bool {
        self.pathing_grid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pathing_grid(&mut self, v: super::common::ImageData) {
        self.pathing_grid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pathing_grid(&mut self) -> &mut super::common::ImageData {
        if self.pathing_grid.is_none() {
            self.pathing_grid.set_default();
        }
        self.pathing_grid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pathing_grid(&mut self) -> super::common::ImageData {
        self.pathing_grid.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData terrain_height = 3;


    pub fn get_terrain_height(&self) -> &super::common::ImageData {
        self.terrain_height.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_terrain_height(&mut self) {
        self.terrain_height.clear();
    }

    pub fn has_terrain_height(&self) -> bool {
        self.terrain_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terrain_height(&mut self, v: super::common::ImageData) {
        self.terrain_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terrain_height(&mut self) -> &mut super::common::ImageData {
        if self.terrain_height.is_none() {
            self.terrain_height.set_default();
        }
        self.terrain_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_terrain_height(&mut self) -> super::common::ImageData {
        self.terrain_height.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData placement_grid = 4;


    pub fn get_placement_grid(&self) -> &super::common::ImageData {
        self.placement_grid.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_placement_grid(&mut self) {
        self.placement_grid.clear();
    }

    pub fn has_placement_grid(&self) -> bool {
        self.placement_grid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placement_grid(&mut self, v: super::common::ImageData) {
        self.placement_grid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placement_grid(&mut self) -> &mut super::common::ImageData {
        if self.placement_grid.is_none() {
            self.placement_grid.set_default();
        }
        self.placement_grid.as_mut().unwrap()
    }

    // Take field
    pub fn take_placement_grid(&mut self) -> super::common::ImageData {
        self.placement_grid.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.RectangleI playable_area = 5;


    pub fn get_playable_area(&self) -> &super::common::RectangleI {
        self.playable_area.as_ref().unwrap_or_else(|| <super::common::RectangleI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_playable_area(&mut self) {
        self.playable_area.clear();
    }

    pub fn has_playable_area(&self) -> bool {
        self.playable_area.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playable_area(&mut self, v: super::common::RectangleI) {
        self.playable_area = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playable_area(&mut self) -> &mut super::common::RectangleI {
        if self.playable_area.is_none() {
            self.playable_area.set_default();
        }
        self.playable_area.as_mut().unwrap()
    }

    // Take field
    pub fn take_playable_area(&mut self) -> super::common::RectangleI {
        self.playable_area.take().unwrap_or_else(|| super::common::RectangleI::new())
    }

    // repeated .SC2APIProtocol.Point2D start_locations = 6;


    pub fn get_start_locations(&self) -> &[super::common::Point2D] {
        &self.start_locations
    }
    pub fn clear_start_locations(&mut self) {
        self.start_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_locations(&mut self, v: ::protobuf::RepeatedField<super::common::Point2D>) {
        self.start_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_start_locations(&mut self) -> &mut ::protobuf::RepeatedField<super::common::Point2D> {
        &mut self.start_locations
    }

    // Take field
    pub fn take_start_locations(&mut self) -> ::protobuf::RepeatedField<super::common::Point2D> {
        ::std::mem::replace(&mut self.start_locations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StartRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.map_size {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pathing_grid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.terrain_height {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.placement_grid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.playable_area {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_locations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.map_size)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pathing_grid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.terrain_height)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.placement_grid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.playable_area)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.start_locations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.map_size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pathing_grid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.terrain_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.placement_grid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.playable_area.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.start_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.map_size.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pathing_grid.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.terrain_height.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.placement_grid.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.playable_area.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.start_locations {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartRaw {
        StartRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Size2DI>>(
                "map_size",
                |m: &StartRaw| { &m.map_size },
                |m: &mut StartRaw| { &mut m.map_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "pathing_grid",
                |m: &StartRaw| { &m.pathing_grid },
                |m: &mut StartRaw| { &mut m.pathing_grid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "terrain_height",
                |m: &StartRaw| { &m.terrain_height },
                |m: &mut StartRaw| { &mut m.terrain_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "placement_grid",
                |m: &StartRaw| { &m.placement_grid },
                |m: &mut StartRaw| { &mut m.placement_grid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::RectangleI>>(
                "playable_area",
                |m: &StartRaw| { &m.playable_area },
                |m: &mut StartRaw| { &mut m.playable_area },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point2D>>(
                "start_locations",
                |m: &StartRaw| { &m.start_locations },
                |m: &mut StartRaw| { &mut m.start_locations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartRaw>(
                "StartRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartRaw {
        static instance: ::protobuf::rt::LazyV2<StartRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartRaw::new)
    }
}

impl ::protobuf::Clear for StartRaw {
    fn clear(&mut self) {
        self.map_size.clear();
        self.pathing_grid.clear();
        self.terrain_height.clear();
        self.placement_grid.clear();
        self.playable_area.clear();
        self.start_locations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObservationRaw {
    // message fields
    pub player: ::protobuf::SingularPtrField<PlayerRaw>,
    pub units: ::protobuf::RepeatedField<Unit>,
    pub map_state: ::protobuf::SingularPtrField<MapState>,
    pub event: ::protobuf::SingularPtrField<Event>,
    pub effects: ::protobuf::RepeatedField<Effect>,
    pub radar: ::protobuf::RepeatedField<RadarRing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObservationRaw {
    fn default() -> &'a ObservationRaw {
        <ObservationRaw as ::protobuf::Message>::default_instance()
    }
}

impl ObservationRaw {
    pub fn new() -> ObservationRaw {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.PlayerRaw player = 1;


    pub fn get_player(&self) -> &PlayerRaw {
        self.player.as_ref().unwrap_or_else(|| <PlayerRaw as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player(&mut self) {
        self.player.clear();
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: PlayerRaw) {
        self.player = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player(&mut self) -> &mut PlayerRaw {
        if self.player.is_none() {
            self.player.set_default();
        }
        self.player.as_mut().unwrap()
    }

    // Take field
    pub fn take_player(&mut self) -> PlayerRaw {
        self.player.take().unwrap_or_else(|| PlayerRaw::new())
    }

    // repeated .SC2APIProtocol.Unit units = 2;


    pub fn get_units(&self) -> &[Unit] {
        &self.units
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: ::protobuf::RepeatedField<Unit>) {
        self.units = v;
    }

    // Mutable pointer to the field.
    pub fn mut_units(&mut self) -> &mut ::protobuf::RepeatedField<Unit> {
        &mut self.units
    }

    // Take field
    pub fn take_units(&mut self) -> ::protobuf::RepeatedField<Unit> {
        ::std::mem::replace(&mut self.units, ::protobuf::RepeatedField::new())
    }

    // optional .SC2APIProtocol.MapState map_state = 3;


    pub fn get_map_state(&self) -> &MapState {
        self.map_state.as_ref().unwrap_or_else(|| <MapState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_map_state(&mut self) {
        self.map_state.clear();
    }

    pub fn has_map_state(&self) -> bool {
        self.map_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_state(&mut self, v: MapState) {
        self.map_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_state(&mut self) -> &mut MapState {
        if self.map_state.is_none() {
            self.map_state.set_default();
        }
        self.map_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_state(&mut self) -> MapState {
        self.map_state.take().unwrap_or_else(|| MapState::new())
    }

    // optional .SC2APIProtocol.Event event = 4;


    pub fn get_event(&self) -> &Event {
        self.event.as_ref().unwrap_or_else(|| <Event as ::protobuf::Message>::default_instance())
    }
    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: Event) {
        self.event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event(&mut self) -> &mut Event {
        if self.event.is_none() {
            self.event.set_default();
        }
        self.event.as_mut().unwrap()
    }

    // Take field
    pub fn take_event(&mut self) -> Event {
        self.event.take().unwrap_or_else(|| Event::new())
    }

    // repeated .SC2APIProtocol.Effect effects = 5;


    pub fn get_effects(&self) -> &[Effect] {
        &self.effects
    }
    pub fn clear_effects(&mut self) {
        self.effects.clear();
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: ::protobuf::RepeatedField<Effect>) {
        self.effects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_effects(&mut self) -> &mut ::protobuf::RepeatedField<Effect> {
        &mut self.effects
    }

    // Take field
    pub fn take_effects(&mut self) -> ::protobuf::RepeatedField<Effect> {
        ::std::mem::replace(&mut self.effects, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.RadarRing radar = 6;


    pub fn get_radar(&self) -> &[RadarRing] {
        &self.radar
    }
    pub fn clear_radar(&mut self) {
        self.radar.clear();
    }

    // Param is passed by value, moved
    pub fn set_radar(&mut self, v: ::protobuf::RepeatedField<RadarRing>) {
        self.radar = v;
    }

    // Mutable pointer to the field.
    pub fn mut_radar(&mut self) -> &mut ::protobuf::RepeatedField<RadarRing> {
        &mut self.radar
    }

    // Take field
    pub fn take_radar(&mut self) -> ::protobuf::RepeatedField<RadarRing> {
        ::std::mem::replace(&mut self.radar, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ObservationRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.player {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.map_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.effects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.radar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.units)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.map_state)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.effects)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.radar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.player.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.units {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.map_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.radar {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.player.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.units {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.map_state.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.event.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.effects {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.radar {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationRaw {
        ObservationRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRaw>>(
                "player",
                |m: &ObservationRaw| { &m.player },
                |m: &mut ObservationRaw| { &mut m.player },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unit>>(
                "units",
                |m: &ObservationRaw| { &m.units },
                |m: &mut ObservationRaw| { &mut m.units },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MapState>>(
                "map_state",
                |m: &ObservationRaw| { &m.map_state },
                |m: &mut ObservationRaw| { &mut m.map_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Event>>(
                "event",
                |m: &ObservationRaw| { &m.event },
                |m: &mut ObservationRaw| { &mut m.event },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Effect>>(
                "effects",
                |m: &ObservationRaw| { &m.effects },
                |m: &mut ObservationRaw| { &mut m.effects },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RadarRing>>(
                "radar",
                |m: &ObservationRaw| { &m.radar },
                |m: &mut ObservationRaw| { &mut m.radar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObservationRaw>(
                "ObservationRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObservationRaw {
        static instance: ::protobuf::rt::LazyV2<ObservationRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObservationRaw::new)
    }
}

impl ::protobuf::Clear for ObservationRaw {
    fn clear(&mut self) {
        self.player.clear();
        self.units.clear();
        self.map_state.clear();
        self.event.clear();
        self.effects.clear();
        self.radar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RadarRing {
    // message fields
    pub pos: ::protobuf::SingularPtrField<super::common::Point>,
    pub radius: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RadarRing {
    fn default() -> &'a RadarRing {
        <RadarRing as ::protobuf::Message>::default_instance()
    }
}

impl RadarRing {
    pub fn new() -> RadarRing {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Point pos = 1;


    pub fn get_pos(&self) -> &super::common::Point {
        self.pos.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: super::common::Point) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut super::common::Point {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> super::common::Point {
        self.pos.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional float radius = 2;


    pub fn get_radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }
    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RadarRing {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.radius = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.radius {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.radius {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RadarRing {
        RadarRing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "pos",
                |m: &RadarRing| { &m.pos },
                |m: &mut RadarRing| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "radius",
                |m: &RadarRing| { &m.radius },
                |m: &mut RadarRing| { &mut m.radius },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RadarRing>(
                "RadarRing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RadarRing {
        static instance: ::protobuf::rt::LazyV2<RadarRing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RadarRing::new)
    }
}

impl ::protobuf::Clear for RadarRing {
    fn clear(&mut self) {
        self.pos.clear();
        self.radius = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RadarRing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadarRing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PowerSource {
    // message fields
    pub pos: ::protobuf::SingularPtrField<super::common::Point>,
    pub radius: ::std::option::Option<f32>,
    pub tag: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PowerSource {
    fn default() -> &'a PowerSource {
        <PowerSource as ::protobuf::Message>::default_instance()
    }
}

impl PowerSource {
    pub fn new() -> PowerSource {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Point pos = 1;


    pub fn get_pos(&self) -> &super::common::Point {
        self.pos.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: super::common::Point) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut super::common::Point {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> super::common::Point {
        self.pos.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional float radius = 2;


    pub fn get_radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }
    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional uint64 tag = 3;


    pub fn get_tag(&self) -> u64 {
        self.tag.unwrap_or(0)
    }
    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u64) {
        self.tag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PowerSource {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.radius = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.radius {
            my_size += 5;
        }
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.radius {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.tag {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PowerSource {
        PowerSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "pos",
                |m: &PowerSource| { &m.pos },
                |m: &mut PowerSource| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "radius",
                |m: &PowerSource| { &m.radius },
                |m: &mut PowerSource| { &mut m.radius },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tag",
                |m: &PowerSource| { &m.tag },
                |m: &mut PowerSource| { &mut m.tag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PowerSource>(
                "PowerSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PowerSource {
        static instance: ::protobuf::rt::LazyV2<PowerSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PowerSource::new)
    }
}

impl ::protobuf::Clear for PowerSource {
    fn clear(&mut self) {
        self.pos.clear();
        self.radius = ::std::option::Option::None;
        self.tag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PowerSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PowerSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerRaw {
    // message fields
    pub power_sources: ::protobuf::RepeatedField<PowerSource>,
    pub camera: ::protobuf::SingularPtrField<super::common::Point>,
    pub upgrade_ids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerRaw {
    fn default() -> &'a PlayerRaw {
        <PlayerRaw as ::protobuf::Message>::default_instance()
    }
}

impl PlayerRaw {
    pub fn new() -> PlayerRaw {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.PowerSource power_sources = 1;


    pub fn get_power_sources(&self) -> &[PowerSource] {
        &self.power_sources
    }
    pub fn clear_power_sources(&mut self) {
        self.power_sources.clear();
    }

    // Param is passed by value, moved
    pub fn set_power_sources(&mut self, v: ::protobuf::RepeatedField<PowerSource>) {
        self.power_sources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_power_sources(&mut self) -> &mut ::protobuf::RepeatedField<PowerSource> {
        &mut self.power_sources
    }

    // Take field
    pub fn take_power_sources(&mut self) -> ::protobuf::RepeatedField<PowerSource> {
        ::std::mem::replace(&mut self.power_sources, ::protobuf::RepeatedField::new())
    }

    // optional .SC2APIProtocol.Point camera = 2;


    pub fn get_camera(&self) -> &super::common::Point {
        self.camera.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_camera(&mut self) {
        self.camera.clear();
    }

    pub fn has_camera(&self) -> bool {
        self.camera.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera(&mut self, v: super::common::Point) {
        self.camera = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera(&mut self) -> &mut super::common::Point {
        if self.camera.is_none() {
            self.camera.set_default();
        }
        self.camera.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera(&mut self) -> super::common::Point {
        self.camera.take().unwrap_or_else(|| super::common::Point::new())
    }

    // repeated uint32 upgrade_ids = 3;


    pub fn get_upgrade_ids(&self) -> &[u32] {
        &self.upgrade_ids
    }
    pub fn clear_upgrade_ids(&mut self) {
        self.upgrade_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_upgrade_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.upgrade_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_upgrade_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.upgrade_ids
    }

    // Take field
    pub fn take_upgrade_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.upgrade_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PlayerRaw {
    fn is_initialized(&self) -> bool {
        for v in &self.power_sources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.camera {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.power_sources)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.upgrade_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.power_sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.camera.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.upgrade_ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.power_sources {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.camera.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.upgrade_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerRaw {
        PlayerRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PowerSource>>(
                "power_sources",
                |m: &PlayerRaw| { &m.power_sources },
                |m: &mut PlayerRaw| { &mut m.power_sources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "camera",
                |m: &PlayerRaw| { &m.camera },
                |m: &mut PlayerRaw| { &mut m.camera },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "upgrade_ids",
                |m: &PlayerRaw| { &m.upgrade_ids },
                |m: &mut PlayerRaw| { &mut m.upgrade_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerRaw>(
                "PlayerRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerRaw {
        static instance: ::protobuf::rt::LazyV2<PlayerRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerRaw::new)
    }
}

impl ::protobuf::Clear for PlayerRaw {
    fn clear(&mut self) {
        self.power_sources.clear();
        self.camera.clear();
        self.upgrade_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitOrder {
    // message fields
    pub ability_id: ::std::option::Option<u32>,
    pub progress: ::std::option::Option<f32>,
    // message oneof groups
    pub target: ::std::option::Option<UnitOrder_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnitOrder {
    fn default() -> &'a UnitOrder {
        <UnitOrder as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum UnitOrder_oneof_target {
    target_world_space_pos(super::common::Point),
    target_unit_tag(u64),
}

impl UnitOrder {
    pub fn new() -> UnitOrder {
        ::std::default::Default::default()
    }

    // optional uint32 ability_id = 1;


    pub fn get_ability_id(&self) -> u32 {
        self.ability_id.unwrap_or(0)
    }
    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Point target_world_space_pos = 2;


    pub fn get_target_world_space_pos(&self) -> &super::common::Point {
        match self.target {
            ::std::option::Option::Some(UnitOrder_oneof_target::target_world_space_pos(ref v)) => v,
            _ => <super::common::Point as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_target_world_space_pos(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_world_space_pos(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(UnitOrder_oneof_target::target_world_space_pos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_world_space_pos(&mut self, v: super::common::Point) {
        self.target = ::std::option::Option::Some(UnitOrder_oneof_target::target_world_space_pos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_world_space_pos(&mut self) -> &mut super::common::Point {
        if let ::std::option::Option::Some(UnitOrder_oneof_target::target_world_space_pos(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(UnitOrder_oneof_target::target_world_space_pos(super::common::Point::new()));
        }
        match self.target {
            ::std::option::Option::Some(UnitOrder_oneof_target::target_world_space_pos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_world_space_pos(&mut self) -> super::common::Point {
        if self.has_target_world_space_pos() {
            match self.target.take() {
                ::std::option::Option::Some(UnitOrder_oneof_target::target_world_space_pos(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::Point::new()
        }
    }

    // optional uint64 target_unit_tag = 3;


    pub fn get_target_unit_tag(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(UnitOrder_oneof_target::target_unit_tag(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_target_unit_tag(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_unit_tag(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(UnitOrder_oneof_target::target_unit_tag(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_unit_tag(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(UnitOrder_oneof_target::target_unit_tag(v))
    }

    // optional float progress = 4;


    pub fn get_progress(&self) -> f32 {
        self.progress.unwrap_or(0.)
    }
    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UnitOrder {
    fn is_initialized(&self) -> bool {
        if let Some(UnitOrder_oneof_target::target_world_space_pos(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(UnitOrder_oneof_target::target_world_space_pos(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(UnitOrder_oneof_target::target_unit_tag(is.read_uint64()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.progress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.progress {
            my_size += 5;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &UnitOrder_oneof_target::target_world_space_pos(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UnitOrder_oneof_target::target_unit_tag(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_float(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &UnitOrder_oneof_target::target_world_space_pos(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UnitOrder_oneof_target::target_unit_tag(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitOrder {
        UnitOrder::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ability_id",
                |m: &UnitOrder| { &m.ability_id },
                |m: &mut UnitOrder| { &mut m.ability_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::common::Point>(
                "target_world_space_pos",
                UnitOrder::has_target_world_space_pos,
                UnitOrder::get_target_world_space_pos,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "target_unit_tag",
                UnitOrder::has_target_unit_tag,
                UnitOrder::get_target_unit_tag,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "progress",
                |m: &UnitOrder| { &m.progress },
                |m: &mut UnitOrder| { &mut m.progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnitOrder>(
                "UnitOrder",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnitOrder {
        static instance: ::protobuf::rt::LazyV2<UnitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnitOrder::new)
    }
}

impl ::protobuf::Clear for UnitOrder {
    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PassengerUnit {
    // message fields
    pub tag: ::std::option::Option<u64>,
    pub health: ::std::option::Option<f32>,
    pub health_max: ::std::option::Option<f32>,
    pub shield: ::std::option::Option<f32>,
    pub shield_max: ::std::option::Option<f32>,
    pub energy: ::std::option::Option<f32>,
    pub energy_max: ::std::option::Option<f32>,
    pub unit_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PassengerUnit {
    fn default() -> &'a PassengerUnit {
        <PassengerUnit as ::protobuf::Message>::default_instance()
    }
}

impl PassengerUnit {
    pub fn new() -> PassengerUnit {
        ::std::default::Default::default()
    }

    // optional uint64 tag = 1;


    pub fn get_tag(&self) -> u64 {
        self.tag.unwrap_or(0)
    }
    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u64) {
        self.tag = ::std::option::Option::Some(v);
    }

    // optional float health = 2;


    pub fn get_health(&self) -> f32 {
        self.health.unwrap_or(0.)
    }
    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: f32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional float health_max = 3;


    pub fn get_health_max(&self) -> f32 {
        self.health_max.unwrap_or(0.)
    }
    pub fn clear_health_max(&mut self) {
        self.health_max = ::std::option::Option::None;
    }

    pub fn has_health_max(&self) -> bool {
        self.health_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_max(&mut self, v: f32) {
        self.health_max = ::std::option::Option::Some(v);
    }

    // optional float shield = 4;


    pub fn get_shield(&self) -> f32 {
        self.shield.unwrap_or(0.)
    }
    pub fn clear_shield(&mut self) {
        self.shield = ::std::option::Option::None;
    }

    pub fn has_shield(&self) -> bool {
        self.shield.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield(&mut self, v: f32) {
        self.shield = ::std::option::Option::Some(v);
    }

    // optional float shield_max = 7;


    pub fn get_shield_max(&self) -> f32 {
        self.shield_max.unwrap_or(0.)
    }
    pub fn clear_shield_max(&mut self) {
        self.shield_max = ::std::option::Option::None;
    }

    pub fn has_shield_max(&self) -> bool {
        self.shield_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_max(&mut self, v: f32) {
        self.shield_max = ::std::option::Option::Some(v);
    }

    // optional float energy = 5;


    pub fn get_energy(&self) -> f32 {
        self.energy.unwrap_or(0.)
    }
    pub fn clear_energy(&mut self) {
        self.energy = ::std::option::Option::None;
    }

    pub fn has_energy(&self) -> bool {
        self.energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy(&mut self, v: f32) {
        self.energy = ::std::option::Option::Some(v);
    }

    // optional float energy_max = 8;


    pub fn get_energy_max(&self) -> f32 {
        self.energy_max.unwrap_or(0.)
    }
    pub fn clear_energy_max(&mut self) {
        self.energy_max = ::std::option::Option::None;
    }

    pub fn has_energy_max(&self) -> bool {
        self.energy_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy_max(&mut self, v: f32) {
        self.energy_max = ::std::option::Option::Some(v);
    }

    // optional uint32 unit_type = 6;


    pub fn get_unit_type(&self) -> u32 {
        self.unit_type.unwrap_or(0)
    }
    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: u32) {
        self.unit_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PassengerUnit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tag = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.health = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.health_max = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.shield = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.shield_max = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.energy = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.energy_max = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unit_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.health {
            my_size += 5;
        }
        if let Some(v) = self.health_max {
            my_size += 5;
        }
        if let Some(v) = self.shield {
            my_size += 5;
        }
        if let Some(v) = self.shield_max {
            my_size += 5;
        }
        if let Some(v) = self.energy {
            my_size += 5;
        }
        if let Some(v) = self.energy_max {
            my_size += 5;
        }
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tag {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.health {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.health_max {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.shield {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.shield_max {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.energy {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.energy_max {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.unit_type {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PassengerUnit {
        PassengerUnit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tag",
                |m: &PassengerUnit| { &m.tag },
                |m: &mut PassengerUnit| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "health",
                |m: &PassengerUnit| { &m.health },
                |m: &mut PassengerUnit| { &mut m.health },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "health_max",
                |m: &PassengerUnit| { &m.health_max },
                |m: &mut PassengerUnit| { &mut m.health_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "shield",
                |m: &PassengerUnit| { &m.shield },
                |m: &mut PassengerUnit| { &mut m.shield },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "shield_max",
                |m: &PassengerUnit| { &m.shield_max },
                |m: &mut PassengerUnit| { &mut m.shield_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "energy",
                |m: &PassengerUnit| { &m.energy },
                |m: &mut PassengerUnit| { &mut m.energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "energy_max",
                |m: &PassengerUnit| { &m.energy_max },
                |m: &mut PassengerUnit| { &mut m.energy_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unit_type",
                |m: &PassengerUnit| { &m.unit_type },
                |m: &mut PassengerUnit| { &mut m.unit_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PassengerUnit>(
                "PassengerUnit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PassengerUnit {
        static instance: ::protobuf::rt::LazyV2<PassengerUnit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PassengerUnit::new)
    }
}

impl ::protobuf::Clear for PassengerUnit {
    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.health = ::std::option::Option::None;
        self.health_max = ::std::option::Option::None;
        self.shield = ::std::option::Option::None;
        self.shield_max = ::std::option::Option::None;
        self.energy = ::std::option::Option::None;
        self.energy_max = ::std::option::Option::None;
        self.unit_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PassengerUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassengerUnit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RallyTarget {
    // message fields
    pub point: ::protobuf::SingularPtrField<super::common::Point>,
    pub tag: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RallyTarget {
    fn default() -> &'a RallyTarget {
        <RallyTarget as ::protobuf::Message>::default_instance()
    }
}

impl RallyTarget {
    pub fn new() -> RallyTarget {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Point point = 1;


    pub fn get_point(&self) -> &super::common::Point {
        self.point.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_point(&mut self) {
        self.point.clear();
    }

    pub fn has_point(&self) -> bool {
        self.point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point(&mut self, v: super::common::Point) {
        self.point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_point(&mut self) -> &mut super::common::Point {
        if self.point.is_none() {
            self.point.set_default();
        }
        self.point.as_mut().unwrap()
    }

    // Take field
    pub fn take_point(&mut self) -> super::common::Point {
        self.point.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional uint64 tag = 2;


    pub fn get_tag(&self) -> u64 {
        self.tag.unwrap_or(0)
    }
    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u64) {
        self.tag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RallyTarget {
    fn is_initialized(&self) -> bool {
        for v in &self.point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.tag {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RallyTarget {
        RallyTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "point",
                |m: &RallyTarget| { &m.point },
                |m: &mut RallyTarget| { &mut m.point },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tag",
                |m: &RallyTarget| { &m.tag },
                |m: &mut RallyTarget| { &mut m.tag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RallyTarget>(
                "RallyTarget",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RallyTarget {
        static instance: ::protobuf::rt::LazyV2<RallyTarget> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RallyTarget::new)
    }
}

impl ::protobuf::Clear for RallyTarget {
    fn clear(&mut self) {
        self.point.clear();
        self.tag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RallyTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RallyTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Unit {
    // message fields
    pub display_type: ::std::option::Option<DisplayType>,
    pub alliance: ::std::option::Option<Alliance>,
    pub tag: ::std::option::Option<u64>,
    pub unit_type: ::std::option::Option<u32>,
    pub owner: ::std::option::Option<i32>,
    pub pos: ::protobuf::SingularPtrField<super::common::Point>,
    pub facing: ::std::option::Option<f32>,
    pub radius: ::std::option::Option<f32>,
    pub build_progress: ::std::option::Option<f32>,
    pub cloak: ::std::option::Option<CloakState>,
    pub buff_ids: ::std::vec::Vec<u32>,
    pub detect_range: ::std::option::Option<f32>,
    pub radar_range: ::std::option::Option<f32>,
    pub is_selected: ::std::option::Option<bool>,
    pub is_on_screen: ::std::option::Option<bool>,
    pub is_blip: ::std::option::Option<bool>,
    pub is_powered: ::std::option::Option<bool>,
    pub is_active: ::std::option::Option<bool>,
    pub attack_upgrade_level: ::std::option::Option<i32>,
    pub armor_upgrade_level: ::std::option::Option<i32>,
    pub shield_upgrade_level: ::std::option::Option<i32>,
    pub health: ::std::option::Option<f32>,
    pub health_max: ::std::option::Option<f32>,
    pub shield: ::std::option::Option<f32>,
    pub shield_max: ::std::option::Option<f32>,
    pub energy: ::std::option::Option<f32>,
    pub energy_max: ::std::option::Option<f32>,
    pub mineral_contents: ::std::option::Option<i32>,
    pub vespene_contents: ::std::option::Option<i32>,
    pub is_flying: ::std::option::Option<bool>,
    pub is_burrowed: ::std::option::Option<bool>,
    pub is_hallucination: ::std::option::Option<bool>,
    pub orders: ::protobuf::RepeatedField<UnitOrder>,
    pub add_on_tag: ::std::option::Option<u64>,
    pub passengers: ::protobuf::RepeatedField<PassengerUnit>,
    pub cargo_space_taken: ::std::option::Option<i32>,
    pub cargo_space_max: ::std::option::Option<i32>,
    pub assigned_harvesters: ::std::option::Option<i32>,
    pub ideal_harvesters: ::std::option::Option<i32>,
    pub weapon_cooldown: ::std::option::Option<f32>,
    pub engaged_target_tag: ::std::option::Option<u64>,
    pub buff_duration_remain: ::std::option::Option<i32>,
    pub buff_duration_max: ::std::option::Option<i32>,
    pub rally_targets: ::protobuf::RepeatedField<RallyTarget>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Unit {
    fn default() -> &'a Unit {
        <Unit as ::protobuf::Message>::default_instance()
    }
}

impl Unit {
    pub fn new() -> Unit {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DisplayType display_type = 1;


    pub fn get_display_type(&self) -> DisplayType {
        self.display_type.unwrap_or(DisplayType::Visible)
    }
    pub fn clear_display_type(&mut self) {
        self.display_type = ::std::option::Option::None;
    }

    pub fn has_display_type(&self) -> bool {
        self.display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_type(&mut self, v: DisplayType) {
        self.display_type = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Alliance alliance = 2;


    pub fn get_alliance(&self) -> Alliance {
        self.alliance.unwrap_or(Alliance::value_Self)
    }
    pub fn clear_alliance(&mut self) {
        self.alliance = ::std::option::Option::None;
    }

    pub fn has_alliance(&self) -> bool {
        self.alliance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alliance(&mut self, v: Alliance) {
        self.alliance = ::std::option::Option::Some(v);
    }

    // optional uint64 tag = 3;


    pub fn get_tag(&self) -> u64 {
        self.tag.unwrap_or(0)
    }
    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u64) {
        self.tag = ::std::option::Option::Some(v);
    }

    // optional uint32 unit_type = 4;


    pub fn get_unit_type(&self) -> u32 {
        self.unit_type.unwrap_or(0)
    }
    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: u32) {
        self.unit_type = ::std::option::Option::Some(v);
    }

    // optional int32 owner = 5;


    pub fn get_owner(&self) -> i32 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: i32) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Point pos = 6;


    pub fn get_pos(&self) -> &super::common::Point {
        self.pos.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: super::common::Point) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut super::common::Point {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> super::common::Point {
        self.pos.take().unwrap_or_else(|| super::common::Point::new())
    }

    // optional float facing = 7;


    pub fn get_facing(&self) -> f32 {
        self.facing.unwrap_or(0.)
    }
    pub fn clear_facing(&mut self) {
        self.facing = ::std::option::Option::None;
    }

    pub fn has_facing(&self) -> bool {
        self.facing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facing(&mut self, v: f32) {
        self.facing = ::std::option::Option::Some(v);
    }

    // optional float radius = 8;


    pub fn get_radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }
    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional float build_progress = 9;


    pub fn get_build_progress(&self) -> f32 {
        self.build_progress.unwrap_or(0.)
    }
    pub fn clear_build_progress(&mut self) {
        self.build_progress = ::std::option::Option::None;
    }

    pub fn has_build_progress(&self) -> bool {
        self.build_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_progress(&mut self, v: f32) {
        self.build_progress = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.CloakState cloak = 10;


    pub fn get_cloak(&self) -> CloakState {
        self.cloak.unwrap_or(CloakState::CloakedUnknown)
    }
    pub fn clear_cloak(&mut self) {
        self.cloak = ::std::option::Option::None;
    }

    pub fn has_cloak(&self) -> bool {
        self.cloak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloak(&mut self, v: CloakState) {
        self.cloak = ::std::option::Option::Some(v);
    }

    // repeated uint32 buff_ids = 27;


    pub fn get_buff_ids(&self) -> &[u32] {
        &self.buff_ids
    }
    pub fn clear_buff_ids(&mut self) {
        self.buff_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_buff_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.buff_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buff_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.buff_ids
    }

    // Take field
    pub fn take_buff_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.buff_ids, ::std::vec::Vec::new())
    }

    // optional float detect_range = 31;


    pub fn get_detect_range(&self) -> f32 {
        self.detect_range.unwrap_or(0.)
    }
    pub fn clear_detect_range(&mut self) {
        self.detect_range = ::std::option::Option::None;
    }

    pub fn has_detect_range(&self) -> bool {
        self.detect_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detect_range(&mut self, v: f32) {
        self.detect_range = ::std::option::Option::Some(v);
    }

    // optional float radar_range = 32;


    pub fn get_radar_range(&self) -> f32 {
        self.radar_range.unwrap_or(0.)
    }
    pub fn clear_radar_range(&mut self) {
        self.radar_range = ::std::option::Option::None;
    }

    pub fn has_radar_range(&self) -> bool {
        self.radar_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radar_range(&mut self, v: f32) {
        self.radar_range = ::std::option::Option::Some(v);
    }

    // optional bool is_selected = 11;


    pub fn get_is_selected(&self) -> bool {
        self.is_selected.unwrap_or(false)
    }
    pub fn clear_is_selected(&mut self) {
        self.is_selected = ::std::option::Option::None;
    }

    pub fn has_is_selected(&self) -> bool {
        self.is_selected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_selected(&mut self, v: bool) {
        self.is_selected = ::std::option::Option::Some(v);
    }

    // optional bool is_on_screen = 12;


    pub fn get_is_on_screen(&self) -> bool {
        self.is_on_screen.unwrap_or(false)
    }
    pub fn clear_is_on_screen(&mut self) {
        self.is_on_screen = ::std::option::Option::None;
    }

    pub fn has_is_on_screen(&self) -> bool {
        self.is_on_screen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_on_screen(&mut self, v: bool) {
        self.is_on_screen = ::std::option::Option::Some(v);
    }

    // optional bool is_blip = 13;


    pub fn get_is_blip(&self) -> bool {
        self.is_blip.unwrap_or(false)
    }
    pub fn clear_is_blip(&mut self) {
        self.is_blip = ::std::option::Option::None;
    }

    pub fn has_is_blip(&self) -> bool {
        self.is_blip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_blip(&mut self, v: bool) {
        self.is_blip = ::std::option::Option::Some(v);
    }

    // optional bool is_powered = 35;


    pub fn get_is_powered(&self) -> bool {
        self.is_powered.unwrap_or(false)
    }
    pub fn clear_is_powered(&mut self) {
        self.is_powered = ::std::option::Option::None;
    }

    pub fn has_is_powered(&self) -> bool {
        self.is_powered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_powered(&mut self, v: bool) {
        self.is_powered = ::std::option::Option::Some(v);
    }

    // optional bool is_active = 39;


    pub fn get_is_active(&self) -> bool {
        self.is_active.unwrap_or(false)
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = ::std::option::Option::None;
    }

    pub fn has_is_active(&self) -> bool {
        self.is_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = ::std::option::Option::Some(v);
    }

    // optional int32 attack_upgrade_level = 40;


    pub fn get_attack_upgrade_level(&self) -> i32 {
        self.attack_upgrade_level.unwrap_or(0)
    }
    pub fn clear_attack_upgrade_level(&mut self) {
        self.attack_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_attack_upgrade_level(&self) -> bool {
        self.attack_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_upgrade_level(&mut self, v: i32) {
        self.attack_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional int32 armor_upgrade_level = 41;


    pub fn get_armor_upgrade_level(&self) -> i32 {
        self.armor_upgrade_level.unwrap_or(0)
    }
    pub fn clear_armor_upgrade_level(&mut self) {
        self.armor_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_armor_upgrade_level(&self) -> bool {
        self.armor_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor_upgrade_level(&mut self, v: i32) {
        self.armor_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional int32 shield_upgrade_level = 42;


    pub fn get_shield_upgrade_level(&self) -> i32 {
        self.shield_upgrade_level.unwrap_or(0)
    }
    pub fn clear_shield_upgrade_level(&mut self) {
        self.shield_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_shield_upgrade_level(&self) -> bool {
        self.shield_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_upgrade_level(&mut self, v: i32) {
        self.shield_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional float health = 14;


    pub fn get_health(&self) -> f32 {
        self.health.unwrap_or(0.)
    }
    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: f32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional float health_max = 15;


    pub fn get_health_max(&self) -> f32 {
        self.health_max.unwrap_or(0.)
    }
    pub fn clear_health_max(&mut self) {
        self.health_max = ::std::option::Option::None;
    }

    pub fn has_health_max(&self) -> bool {
        self.health_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_max(&mut self, v: f32) {
        self.health_max = ::std::option::Option::Some(v);
    }

    // optional float shield = 16;


    pub fn get_shield(&self) -> f32 {
        self.shield.unwrap_or(0.)
    }
    pub fn clear_shield(&mut self) {
        self.shield = ::std::option::Option::None;
    }

    pub fn has_shield(&self) -> bool {
        self.shield.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield(&mut self, v: f32) {
        self.shield = ::std::option::Option::Some(v);
    }

    // optional float shield_max = 36;


    pub fn get_shield_max(&self) -> f32 {
        self.shield_max.unwrap_or(0.)
    }
    pub fn clear_shield_max(&mut self) {
        self.shield_max = ::std::option::Option::None;
    }

    pub fn has_shield_max(&self) -> bool {
        self.shield_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_max(&mut self, v: f32) {
        self.shield_max = ::std::option::Option::Some(v);
    }

    // optional float energy = 17;


    pub fn get_energy(&self) -> f32 {
        self.energy.unwrap_or(0.)
    }
    pub fn clear_energy(&mut self) {
        self.energy = ::std::option::Option::None;
    }

    pub fn has_energy(&self) -> bool {
        self.energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy(&mut self, v: f32) {
        self.energy = ::std::option::Option::Some(v);
    }

    // optional float energy_max = 37;


    pub fn get_energy_max(&self) -> f32 {
        self.energy_max.unwrap_or(0.)
    }
    pub fn clear_energy_max(&mut self) {
        self.energy_max = ::std::option::Option::None;
    }

    pub fn has_energy_max(&self) -> bool {
        self.energy_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy_max(&mut self, v: f32) {
        self.energy_max = ::std::option::Option::Some(v);
    }

    // optional int32 mineral_contents = 18;


    pub fn get_mineral_contents(&self) -> i32 {
        self.mineral_contents.unwrap_or(0)
    }
    pub fn clear_mineral_contents(&mut self) {
        self.mineral_contents = ::std::option::Option::None;
    }

    pub fn has_mineral_contents(&self) -> bool {
        self.mineral_contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mineral_contents(&mut self, v: i32) {
        self.mineral_contents = ::std::option::Option::Some(v);
    }

    // optional int32 vespene_contents = 19;


    pub fn get_vespene_contents(&self) -> i32 {
        self.vespene_contents.unwrap_or(0)
    }
    pub fn clear_vespene_contents(&mut self) {
        self.vespene_contents = ::std::option::Option::None;
    }

    pub fn has_vespene_contents(&self) -> bool {
        self.vespene_contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vespene_contents(&mut self, v: i32) {
        self.vespene_contents = ::std::option::Option::Some(v);
    }

    // optional bool is_flying = 20;


    pub fn get_is_flying(&self) -> bool {
        self.is_flying.unwrap_or(false)
    }
    pub fn clear_is_flying(&mut self) {
        self.is_flying = ::std::option::Option::None;
    }

    pub fn has_is_flying(&self) -> bool {
        self.is_flying.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_flying(&mut self, v: bool) {
        self.is_flying = ::std::option::Option::Some(v);
    }

    // optional bool is_burrowed = 21;


    pub fn get_is_burrowed(&self) -> bool {
        self.is_burrowed.unwrap_or(false)
    }
    pub fn clear_is_burrowed(&mut self) {
        self.is_burrowed = ::std::option::Option::None;
    }

    pub fn has_is_burrowed(&self) -> bool {
        self.is_burrowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_burrowed(&mut self, v: bool) {
        self.is_burrowed = ::std::option::Option::Some(v);
    }

    // optional bool is_hallucination = 38;


    pub fn get_is_hallucination(&self) -> bool {
        self.is_hallucination.unwrap_or(false)
    }
    pub fn clear_is_hallucination(&mut self) {
        self.is_hallucination = ::std::option::Option::None;
    }

    pub fn has_is_hallucination(&self) -> bool {
        self.is_hallucination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hallucination(&mut self, v: bool) {
        self.is_hallucination = ::std::option::Option::Some(v);
    }

    // repeated .SC2APIProtocol.UnitOrder orders = 22;


    pub fn get_orders(&self) -> &[UnitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<UnitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<UnitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<UnitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    // optional uint64 add_on_tag = 23;


    pub fn get_add_on_tag(&self) -> u64 {
        self.add_on_tag.unwrap_or(0)
    }
    pub fn clear_add_on_tag(&mut self) {
        self.add_on_tag = ::std::option::Option::None;
    }

    pub fn has_add_on_tag(&self) -> bool {
        self.add_on_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_on_tag(&mut self, v: u64) {
        self.add_on_tag = ::std::option::Option::Some(v);
    }

    // repeated .SC2APIProtocol.PassengerUnit passengers = 24;


    pub fn get_passengers(&self) -> &[PassengerUnit] {
        &self.passengers
    }
    pub fn clear_passengers(&mut self) {
        self.passengers.clear();
    }

    // Param is passed by value, moved
    pub fn set_passengers(&mut self, v: ::protobuf::RepeatedField<PassengerUnit>) {
        self.passengers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_passengers(&mut self) -> &mut ::protobuf::RepeatedField<PassengerUnit> {
        &mut self.passengers
    }

    // Take field
    pub fn take_passengers(&mut self) -> ::protobuf::RepeatedField<PassengerUnit> {
        ::std::mem::replace(&mut self.passengers, ::protobuf::RepeatedField::new())
    }

    // optional int32 cargo_space_taken = 25;


    pub fn get_cargo_space_taken(&self) -> i32 {
        self.cargo_space_taken.unwrap_or(0)
    }
    pub fn clear_cargo_space_taken(&mut self) {
        self.cargo_space_taken = ::std::option::Option::None;
    }

    pub fn has_cargo_space_taken(&self) -> bool {
        self.cargo_space_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cargo_space_taken(&mut self, v: i32) {
        self.cargo_space_taken = ::std::option::Option::Some(v);
    }

    // optional int32 cargo_space_max = 26;


    pub fn get_cargo_space_max(&self) -> i32 {
        self.cargo_space_max.unwrap_or(0)
    }
    pub fn clear_cargo_space_max(&mut self) {
        self.cargo_space_max = ::std::option::Option::None;
    }

    pub fn has_cargo_space_max(&self) -> bool {
        self.cargo_space_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cargo_space_max(&mut self, v: i32) {
        self.cargo_space_max = ::std::option::Option::Some(v);
    }

    // optional int32 assigned_harvesters = 28;


    pub fn get_assigned_harvesters(&self) -> i32 {
        self.assigned_harvesters.unwrap_or(0)
    }
    pub fn clear_assigned_harvesters(&mut self) {
        self.assigned_harvesters = ::std::option::Option::None;
    }

    pub fn has_assigned_harvesters(&self) -> bool {
        self.assigned_harvesters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned_harvesters(&mut self, v: i32) {
        self.assigned_harvesters = ::std::option::Option::Some(v);
    }

    // optional int32 ideal_harvesters = 29;


    pub fn get_ideal_harvesters(&self) -> i32 {
        self.ideal_harvesters.unwrap_or(0)
    }
    pub fn clear_ideal_harvesters(&mut self) {
        self.ideal_harvesters = ::std::option::Option::None;
    }

    pub fn has_ideal_harvesters(&self) -> bool {
        self.ideal_harvesters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ideal_harvesters(&mut self, v: i32) {
        self.ideal_harvesters = ::std::option::Option::Some(v);
    }

    // optional float weapon_cooldown = 30;


    pub fn get_weapon_cooldown(&self) -> f32 {
        self.weapon_cooldown.unwrap_or(0.)
    }
    pub fn clear_weapon_cooldown(&mut self) {
        self.weapon_cooldown = ::std::option::Option::None;
    }

    pub fn has_weapon_cooldown(&self) -> bool {
        self.weapon_cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weapon_cooldown(&mut self, v: f32) {
        self.weapon_cooldown = ::std::option::Option::Some(v);
    }

    // optional uint64 engaged_target_tag = 34;


    pub fn get_engaged_target_tag(&self) -> u64 {
        self.engaged_target_tag.unwrap_or(0)
    }
    pub fn clear_engaged_target_tag(&mut self) {
        self.engaged_target_tag = ::std::option::Option::None;
    }

    pub fn has_engaged_target_tag(&self) -> bool {
        self.engaged_target_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engaged_target_tag(&mut self, v: u64) {
        self.engaged_target_tag = ::std::option::Option::Some(v);
    }

    // optional int32 buff_duration_remain = 43;


    pub fn get_buff_duration_remain(&self) -> i32 {
        self.buff_duration_remain.unwrap_or(0)
    }
    pub fn clear_buff_duration_remain(&mut self) {
        self.buff_duration_remain = ::std::option::Option::None;
    }

    pub fn has_buff_duration_remain(&self) -> bool {
        self.buff_duration_remain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_duration_remain(&mut self, v: i32) {
        self.buff_duration_remain = ::std::option::Option::Some(v);
    }

    // optional int32 buff_duration_max = 44;


    pub fn get_buff_duration_max(&self) -> i32 {
        self.buff_duration_max.unwrap_or(0)
    }
    pub fn clear_buff_duration_max(&mut self) {
        self.buff_duration_max = ::std::option::Option::None;
    }

    pub fn has_buff_duration_max(&self) -> bool {
        self.buff_duration_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_duration_max(&mut self, v: i32) {
        self.buff_duration_max = ::std::option::Option::Some(v);
    }

    // repeated .SC2APIProtocol.RallyTarget rally_targets = 45;


    pub fn get_rally_targets(&self) -> &[RallyTarget] {
        &self.rally_targets
    }
    pub fn clear_rally_targets(&mut self) {
        self.rally_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_rally_targets(&mut self, v: ::protobuf::RepeatedField<RallyTarget>) {
        self.rally_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rally_targets(&mut self) -> &mut ::protobuf::RepeatedField<RallyTarget> {
        &mut self.rally_targets
    }

    // Take field
    pub fn take_rally_targets(&mut self) -> ::protobuf::RepeatedField<RallyTarget> {
        ::std::mem::replace(&mut self.rally_targets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Unit {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.passengers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rally_targets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.display_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.alliance, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tag = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unit_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.facing = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.radius = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.build_progress = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cloak, 10, &mut self.unknown_fields)?
                },
                27 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.buff_ids)?;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.detect_range = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.radar_range = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_selected = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_on_screen = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_blip = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_powered = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attack_upgrade_level = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.armor_upgrade_level = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shield_upgrade_level = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.health = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.health_max = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.shield = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.shield_max = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.energy = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.energy_max = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mineral_contents = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vespene_contents = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_flying = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_burrowed = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_hallucination = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_on_tag = ::std::option::Option::Some(tmp);
                },
                24 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.passengers)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cargo_space_taken = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cargo_space_max = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assigned_harvesters = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ideal_harvesters = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.weapon_cooldown = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.engaged_target_tag = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.buff_duration_remain = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.buff_duration_max = ::std::option::Option::Some(tmp);
                },
                45 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rally_targets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.alliance {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.facing {
            my_size += 5;
        }
        if let Some(v) = self.radius {
            my_size += 5;
        }
        if let Some(v) = self.build_progress {
            my_size += 5;
        }
        if let Some(v) = self.cloak {
            my_size += ::protobuf::rt::enum_size(10, v);
        }
        for value in &self.buff_ids {
            my_size += ::protobuf::rt::value_size(27, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.detect_range {
            my_size += 6;
        }
        if let Some(v) = self.radar_range {
            my_size += 6;
        }
        if let Some(v) = self.is_selected {
            my_size += 2;
        }
        if let Some(v) = self.is_on_screen {
            my_size += 2;
        }
        if let Some(v) = self.is_blip {
            my_size += 2;
        }
        if let Some(v) = self.is_powered {
            my_size += 3;
        }
        if let Some(v) = self.is_active {
            my_size += 3;
        }
        if let Some(v) = self.attack_upgrade_level {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.armor_upgrade_level {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shield_upgrade_level {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.health {
            my_size += 5;
        }
        if let Some(v) = self.health_max {
            my_size += 5;
        }
        if let Some(v) = self.shield {
            my_size += 6;
        }
        if let Some(v) = self.shield_max {
            my_size += 6;
        }
        if let Some(v) = self.energy {
            my_size += 6;
        }
        if let Some(v) = self.energy_max {
            my_size += 6;
        }
        if let Some(v) = self.mineral_contents {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vespene_contents {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_flying {
            my_size += 3;
        }
        if let Some(v) = self.is_burrowed {
            my_size += 3;
        }
        if let Some(v) = self.is_hallucination {
            my_size += 3;
        }
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.add_on_tag {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.passengers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.cargo_space_taken {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cargo_space_max {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assigned_harvesters {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ideal_harvesters {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.weapon_cooldown {
            my_size += 6;
        }
        if let Some(v) = self.engaged_target_tag {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.buff_duration_remain {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.buff_duration_max {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.rally_targets {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.alliance {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.tag {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.unit_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.owner {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.facing {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.radius {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.build_progress {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.cloak {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.buff_ids {
            os.write_uint32(27, *v)?;
        };
        if let Some(v) = self.detect_range {
            os.write_float(31, v)?;
        }
        if let Some(v) = self.radar_range {
            os.write_float(32, v)?;
        }
        if let Some(v) = self.is_selected {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_on_screen {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_blip {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_powered {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.is_active {
            os.write_bool(39, v)?;
        }
        if let Some(v) = self.attack_upgrade_level {
            os.write_int32(40, v)?;
        }
        if let Some(v) = self.armor_upgrade_level {
            os.write_int32(41, v)?;
        }
        if let Some(v) = self.shield_upgrade_level {
            os.write_int32(42, v)?;
        }
        if let Some(v) = self.health {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.health_max {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.shield {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.shield_max {
            os.write_float(36, v)?;
        }
        if let Some(v) = self.energy {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.energy_max {
            os.write_float(37, v)?;
        }
        if let Some(v) = self.mineral_contents {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.vespene_contents {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.is_flying {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.is_burrowed {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.is_hallucination {
            os.write_bool(38, v)?;
        }
        for v in &self.orders {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.add_on_tag {
            os.write_uint64(23, v)?;
        }
        for v in &self.passengers {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.cargo_space_taken {
            os.write_int32(25, v)?;
        }
        if let Some(v) = self.cargo_space_max {
            os.write_int32(26, v)?;
        }
        if let Some(v) = self.assigned_harvesters {
            os.write_int32(28, v)?;
        }
        if let Some(v) = self.ideal_harvesters {
            os.write_int32(29, v)?;
        }
        if let Some(v) = self.weapon_cooldown {
            os.write_float(30, v)?;
        }
        if let Some(v) = self.engaged_target_tag {
            os.write_uint64(34, v)?;
        }
        if let Some(v) = self.buff_duration_remain {
            os.write_int32(43, v)?;
        }
        if let Some(v) = self.buff_duration_max {
            os.write_int32(44, v)?;
        }
        for v in &self.rally_targets {
            os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Unit {
        Unit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DisplayType>>(
                "display_type",
                |m: &Unit| { &m.display_type },
                |m: &mut Unit| { &mut m.display_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Alliance>>(
                "alliance",
                |m: &Unit| { &m.alliance },
                |m: &mut Unit| { &mut m.alliance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tag",
                |m: &Unit| { &m.tag },
                |m: &mut Unit| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unit_type",
                |m: &Unit| { &m.unit_type },
                |m: &mut Unit| { &mut m.unit_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "owner",
                |m: &Unit| { &m.owner },
                |m: &mut Unit| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "pos",
                |m: &Unit| { &m.pos },
                |m: &mut Unit| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "facing",
                |m: &Unit| { &m.facing },
                |m: &mut Unit| { &mut m.facing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "radius",
                |m: &Unit| { &m.radius },
                |m: &mut Unit| { &mut m.radius },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "build_progress",
                |m: &Unit| { &m.build_progress },
                |m: &mut Unit| { &mut m.build_progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CloakState>>(
                "cloak",
                |m: &Unit| { &m.cloak },
                |m: &mut Unit| { &mut m.cloak },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "buff_ids",
                |m: &Unit| { &m.buff_ids },
                |m: &mut Unit| { &mut m.buff_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "detect_range",
                |m: &Unit| { &m.detect_range },
                |m: &mut Unit| { &mut m.detect_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "radar_range",
                |m: &Unit| { &m.radar_range },
                |m: &mut Unit| { &mut m.radar_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_selected",
                |m: &Unit| { &m.is_selected },
                |m: &mut Unit| { &mut m.is_selected },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_on_screen",
                |m: &Unit| { &m.is_on_screen },
                |m: &mut Unit| { &mut m.is_on_screen },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_blip",
                |m: &Unit| { &m.is_blip },
                |m: &mut Unit| { &mut m.is_blip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_powered",
                |m: &Unit| { &m.is_powered },
                |m: &mut Unit| { &mut m.is_powered },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_active",
                |m: &Unit| { &m.is_active },
                |m: &mut Unit| { &mut m.is_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "attack_upgrade_level",
                |m: &Unit| { &m.attack_upgrade_level },
                |m: &mut Unit| { &mut m.attack_upgrade_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "armor_upgrade_level",
                |m: &Unit| { &m.armor_upgrade_level },
                |m: &mut Unit| { &mut m.armor_upgrade_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "shield_upgrade_level",
                |m: &Unit| { &m.shield_upgrade_level },
                |m: &mut Unit| { &mut m.shield_upgrade_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "health",
                |m: &Unit| { &m.health },
                |m: &mut Unit| { &mut m.health },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "health_max",
                |m: &Unit| { &m.health_max },
                |m: &mut Unit| { &mut m.health_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "shield",
                |m: &Unit| { &m.shield },
                |m: &mut Unit| { &mut m.shield },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "shield_max",
                |m: &Unit| { &m.shield_max },
                |m: &mut Unit| { &mut m.shield_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "energy",
                |m: &Unit| { &m.energy },
                |m: &mut Unit| { &mut m.energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "energy_max",
                |m: &Unit| { &m.energy_max },
                |m: &mut Unit| { &mut m.energy_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mineral_contents",
                |m: &Unit| { &m.mineral_contents },
                |m: &mut Unit| { &mut m.mineral_contents },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vespene_contents",
                |m: &Unit| { &m.vespene_contents },
                |m: &mut Unit| { &mut m.vespene_contents },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_flying",
                |m: &Unit| { &m.is_flying },
                |m: &mut Unit| { &mut m.is_flying },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_burrowed",
                |m: &Unit| { &m.is_burrowed },
                |m: &mut Unit| { &mut m.is_burrowed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_hallucination",
                |m: &Unit| { &m.is_hallucination },
                |m: &mut Unit| { &mut m.is_hallucination },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitOrder>>(
                "orders",
                |m: &Unit| { &m.orders },
                |m: &mut Unit| { &mut m.orders },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "add_on_tag",
                |m: &Unit| { &m.add_on_tag },
                |m: &mut Unit| { &mut m.add_on_tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PassengerUnit>>(
                "passengers",
                |m: &Unit| { &m.passengers },
                |m: &mut Unit| { &mut m.passengers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cargo_space_taken",
                |m: &Unit| { &m.cargo_space_taken },
                |m: &mut Unit| { &mut m.cargo_space_taken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cargo_space_max",
                |m: &Unit| { &m.cargo_space_max },
                |m: &mut Unit| { &mut m.cargo_space_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "assigned_harvesters",
                |m: &Unit| { &m.assigned_harvesters },
                |m: &mut Unit| { &mut m.assigned_harvesters },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ideal_harvesters",
                |m: &Unit| { &m.ideal_harvesters },
                |m: &mut Unit| { &mut m.ideal_harvesters },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "weapon_cooldown",
                |m: &Unit| { &m.weapon_cooldown },
                |m: &mut Unit| { &mut m.weapon_cooldown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "engaged_target_tag",
                |m: &Unit| { &m.engaged_target_tag },
                |m: &mut Unit| { &mut m.engaged_target_tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "buff_duration_remain",
                |m: &Unit| { &m.buff_duration_remain },
                |m: &mut Unit| { &mut m.buff_duration_remain },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "buff_duration_max",
                |m: &Unit| { &m.buff_duration_max },
                |m: &mut Unit| { &mut m.buff_duration_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RallyTarget>>(
                "rally_targets",
                |m: &Unit| { &m.rally_targets },
                |m: &mut Unit| { &mut m.rally_targets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Unit>(
                "Unit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Unit {
        static instance: ::protobuf::rt::LazyV2<Unit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Unit::new)
    }
}

impl ::protobuf::Clear for Unit {
    fn clear(&mut self) {
        self.display_type = ::std::option::Option::None;
        self.alliance = ::std::option::Option::None;
        self.tag = ::std::option::Option::None;
        self.unit_type = ::std::option::Option::None;
        self.owner = ::std::option::Option::None;
        self.pos.clear();
        self.facing = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.build_progress = ::std::option::Option::None;
        self.cloak = ::std::option::Option::None;
        self.buff_ids.clear();
        self.detect_range = ::std::option::Option::None;
        self.radar_range = ::std::option::Option::None;
        self.is_selected = ::std::option::Option::None;
        self.is_on_screen = ::std::option::Option::None;
        self.is_blip = ::std::option::Option::None;
        self.is_powered = ::std::option::Option::None;
        self.is_active = ::std::option::Option::None;
        self.attack_upgrade_level = ::std::option::Option::None;
        self.armor_upgrade_level = ::std::option::Option::None;
        self.shield_upgrade_level = ::std::option::Option::None;
        self.health = ::std::option::Option::None;
        self.health_max = ::std::option::Option::None;
        self.shield = ::std::option::Option::None;
        self.shield_max = ::std::option::Option::None;
        self.energy = ::std::option::Option::None;
        self.energy_max = ::std::option::Option::None;
        self.mineral_contents = ::std::option::Option::None;
        self.vespene_contents = ::std::option::Option::None;
        self.is_flying = ::std::option::Option::None;
        self.is_burrowed = ::std::option::Option::None;
        self.is_hallucination = ::std::option::Option::None;
        self.orders.clear();
        self.add_on_tag = ::std::option::Option::None;
        self.passengers.clear();
        self.cargo_space_taken = ::std::option::Option::None;
        self.cargo_space_max = ::std::option::Option::None;
        self.assigned_harvesters = ::std::option::Option::None;
        self.ideal_harvesters = ::std::option::Option::None;
        self.weapon_cooldown = ::std::option::Option::None;
        self.engaged_target_tag = ::std::option::Option::None;
        self.buff_duration_remain = ::std::option::Option::None;
        self.buff_duration_max = ::std::option::Option::None;
        self.rally_targets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Unit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Unit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapState {
    // message fields
    pub visibility: ::protobuf::SingularPtrField<super::common::ImageData>,
    pub creep: ::protobuf::SingularPtrField<super::common::ImageData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MapState {
    fn default() -> &'a MapState {
        <MapState as ::protobuf::Message>::default_instance()
    }
}

impl MapState {
    pub fn new() -> MapState {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ImageData visibility = 1;


    pub fn get_visibility(&self) -> &super::common::ImageData {
        self.visibility.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: super::common::ImageData) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut super::common::ImageData {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> super::common::ImageData {
        self.visibility.take().unwrap_or_else(|| super::common::ImageData::new())
    }

    // optional .SC2APIProtocol.ImageData creep = 2;


    pub fn get_creep(&self) -> &super::common::ImageData {
        self.creep.as_ref().unwrap_or_else(|| <super::common::ImageData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creep(&mut self) {
        self.creep.clear();
    }

    pub fn has_creep(&self) -> bool {
        self.creep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creep(&mut self, v: super::common::ImageData) {
        self.creep = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creep(&mut self) -> &mut super::common::ImageData {
        if self.creep.is_none() {
            self.creep.set_default();
        }
        self.creep.as_mut().unwrap()
    }

    // Take field
    pub fn take_creep(&mut self) -> super::common::ImageData {
        self.creep.take().unwrap_or_else(|| super::common::ImageData::new())
    }
}

impl ::protobuf::Message for MapState {
    fn is_initialized(&self) -> bool {
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creep {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creep)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.creep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.creep.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapState {
        MapState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "visibility",
                |m: &MapState| { &m.visibility },
                |m: &mut MapState| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ImageData>>(
                "creep",
                |m: &MapState| { &m.creep },
                |m: &mut MapState| { &mut m.creep },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MapState>(
                "MapState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MapState {
        static instance: ::protobuf::rt::LazyV2<MapState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MapState::new)
    }
}

impl ::protobuf::Clear for MapState {
    fn clear(&mut self) {
        self.visibility.clear();
        self.creep.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub dead_units: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // repeated uint64 dead_units = 1;


    pub fn get_dead_units(&self) -> &[u64] {
        &self.dead_units
    }
    pub fn clear_dead_units(&mut self) {
        self.dead_units.clear();
    }

    // Param is passed by value, moved
    pub fn set_dead_units(&mut self, v: ::std::vec::Vec<u64>) {
        self.dead_units = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dead_units(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.dead_units
    }

    // Take field
    pub fn take_dead_units(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.dead_units, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.dead_units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dead_units {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dead_units {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dead_units",
                |m: &Event| { &m.dead_units },
                |m: &mut Event| { &mut m.dead_units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Event>(
                "Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Event {
        static instance: ::protobuf::rt::LazyV2<Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Event::new)
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.dead_units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Effect {
    // message fields
    pub effect_id: ::std::option::Option<u32>,
    pub pos: ::protobuf::RepeatedField<super::common::Point2D>,
    pub alliance: ::std::option::Option<Alliance>,
    pub owner: ::std::option::Option<i32>,
    pub radius: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Effect {
    fn default() -> &'a Effect {
        <Effect as ::protobuf::Message>::default_instance()
    }
}

impl Effect {
    pub fn new() -> Effect {
        ::std::default::Default::default()
    }

    // optional uint32 effect_id = 1;


    pub fn get_effect_id(&self) -> u32 {
        self.effect_id.unwrap_or(0)
    }
    pub fn clear_effect_id(&mut self) {
        self.effect_id = ::std::option::Option::None;
    }

    pub fn has_effect_id(&self) -> bool {
        self.effect_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_id(&mut self, v: u32) {
        self.effect_id = ::std::option::Option::Some(v);
    }

    // repeated .SC2APIProtocol.Point2D pos = 2;


    pub fn get_pos(&self) -> &[super::common::Point2D] {
        &self.pos
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: ::protobuf::RepeatedField<super::common::Point2D>) {
        self.pos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pos(&mut self) -> &mut ::protobuf::RepeatedField<super::common::Point2D> {
        &mut self.pos
    }

    // Take field
    pub fn take_pos(&mut self) -> ::protobuf::RepeatedField<super::common::Point2D> {
        ::std::mem::replace(&mut self.pos, ::protobuf::RepeatedField::new())
    }

    // optional .SC2APIProtocol.Alliance alliance = 3;


    pub fn get_alliance(&self) -> Alliance {
        self.alliance.unwrap_or(Alliance::value_Self)
    }
    pub fn clear_alliance(&mut self) {
        self.alliance = ::std::option::Option::None;
    }

    pub fn has_alliance(&self) -> bool {
        self.alliance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alliance(&mut self, v: Alliance) {
        self.alliance = ::std::option::Option::Some(v);
    }

    // optional int32 owner = 4;


    pub fn get_owner(&self) -> i32 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: i32) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional float radius = 5;


    pub fn get_radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }
    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Effect {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.effect_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pos)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.alliance, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.radius = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.effect_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.alliance {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.owner {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.radius {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.effect_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.pos {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.alliance {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.owner {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.radius {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Effect {
        Effect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "effect_id",
                |m: &Effect| { &m.effect_id },
                |m: &mut Effect| { &mut m.effect_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point2D>>(
                "pos",
                |m: &Effect| { &m.pos },
                |m: &mut Effect| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Alliance>>(
                "alliance",
                |m: &Effect| { &m.alliance },
                |m: &mut Effect| { &mut m.alliance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "owner",
                |m: &Effect| { &m.owner },
                |m: &mut Effect| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "radius",
                |m: &Effect| { &m.radius },
                |m: &mut Effect| { &mut m.radius },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Effect>(
                "Effect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Effect {
        static instance: ::protobuf::rt::LazyV2<Effect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Effect::new)
    }
}

impl ::protobuf::Clear for Effect {
    fn clear(&mut self) {
        self.effect_id = ::std::option::Option::None;
        self.pos.clear();
        self.alliance = ::std::option::Option::None;
        self.owner = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Effect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Effect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionRaw {
    // message oneof groups
    pub action: ::std::option::Option<ActionRaw_oneof_action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionRaw {
    fn default() -> &'a ActionRaw {
        <ActionRaw as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ActionRaw_oneof_action {
    unit_command(ActionRawUnitCommand),
    camera_move(ActionRawCameraMove),
    toggle_autocast(ActionRawToggleAutocast),
}

impl ActionRaw {
    pub fn new() -> ActionRaw {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;


    pub fn get_unit_command(&self) -> &ActionRawUnitCommand {
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::unit_command(ref v)) => v,
            _ => <ActionRawUnitCommand as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_unit_command(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_unit_command(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::unit_command(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_command(&mut self, v: ActionRawUnitCommand) {
        self.action = ::std::option::Option::Some(ActionRaw_oneof_action::unit_command(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_command(&mut self) -> &mut ActionRawUnitCommand {
        if let ::std::option::Option::Some(ActionRaw_oneof_action::unit_command(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionRaw_oneof_action::unit_command(ActionRawUnitCommand::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::unit_command(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_command(&mut self) -> ActionRawUnitCommand {
        if self.has_unit_command() {
            match self.action.take() {
                ::std::option::Option::Some(ActionRaw_oneof_action::unit_command(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionRawUnitCommand::new()
        }
    }

    // optional .SC2APIProtocol.ActionRawCameraMove camera_move = 2;


    pub fn get_camera_move(&self) -> &ActionRawCameraMove {
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::camera_move(ref v)) => v,
            _ => <ActionRawCameraMove as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_camera_move(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_move(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::camera_move(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_move(&mut self, v: ActionRawCameraMove) {
        self.action = ::std::option::Option::Some(ActionRaw_oneof_action::camera_move(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_move(&mut self) -> &mut ActionRawCameraMove {
        if let ::std::option::Option::Some(ActionRaw_oneof_action::camera_move(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionRaw_oneof_action::camera_move(ActionRawCameraMove::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::camera_move(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_move(&mut self) -> ActionRawCameraMove {
        if self.has_camera_move() {
            match self.action.take() {
                ::std::option::Option::Some(ActionRaw_oneof_action::camera_move(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionRawCameraMove::new()
        }
    }

    // optional .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;


    pub fn get_toggle_autocast(&self) -> &ActionRawToggleAutocast {
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::toggle_autocast(ref v)) => v,
            _ => <ActionRawToggleAutocast as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_toggle_autocast(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_toggle_autocast(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::toggle_autocast(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_toggle_autocast(&mut self, v: ActionRawToggleAutocast) {
        self.action = ::std::option::Option::Some(ActionRaw_oneof_action::toggle_autocast(v))
    }

    // Mutable pointer to the field.
    pub fn mut_toggle_autocast(&mut self) -> &mut ActionRawToggleAutocast {
        if let ::std::option::Option::Some(ActionRaw_oneof_action::toggle_autocast(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ActionRaw_oneof_action::toggle_autocast(ActionRawToggleAutocast::new()));
        }
        match self.action {
            ::std::option::Option::Some(ActionRaw_oneof_action::toggle_autocast(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_toggle_autocast(&mut self) -> ActionRawToggleAutocast {
        if self.has_toggle_autocast() {
            match self.action.take() {
                ::std::option::Option::Some(ActionRaw_oneof_action::toggle_autocast(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionRawToggleAutocast::new()
        }
    }
}

impl ::protobuf::Message for ActionRaw {
    fn is_initialized(&self) -> bool {
        if let Some(ActionRaw_oneof_action::unit_command(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionRaw_oneof_action::camera_move(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActionRaw_oneof_action::toggle_autocast(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionRaw_oneof_action::unit_command(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionRaw_oneof_action::camera_move(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ActionRaw_oneof_action::toggle_autocast(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &ActionRaw_oneof_action::unit_command(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionRaw_oneof_action::camera_move(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionRaw_oneof_action::toggle_autocast(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &ActionRaw_oneof_action::unit_command(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionRaw_oneof_action::camera_move(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionRaw_oneof_action::toggle_autocast(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionRaw {
        ActionRaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionRawUnitCommand>(
                "unit_command",
                ActionRaw::has_unit_command,
                ActionRaw::get_unit_command,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionRawCameraMove>(
                "camera_move",
                ActionRaw::has_camera_move,
                ActionRaw::get_camera_move,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionRawToggleAutocast>(
                "toggle_autocast",
                ActionRaw::has_toggle_autocast,
                ActionRaw::get_toggle_autocast,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionRaw>(
                "ActionRaw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionRaw {
        static instance: ::protobuf::rt::LazyV2<ActionRaw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionRaw::new)
    }
}

impl ::protobuf::Clear for ActionRaw {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionRawUnitCommand {
    // message fields
    pub ability_id: ::std::option::Option<i32>,
    pub unit_tags: ::std::vec::Vec<u64>,
    pub queue_command: ::std::option::Option<bool>,
    // message oneof groups
    pub target: ::std::option::Option<ActionRawUnitCommand_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionRawUnitCommand {
    fn default() -> &'a ActionRawUnitCommand {
        <ActionRawUnitCommand as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ActionRawUnitCommand_oneof_target {
    target_world_space_pos(super::common::Point2D),
    target_unit_tag(u64),
}

impl ActionRawUnitCommand {
    pub fn new() -> ActionRawUnitCommand {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;


    pub fn get_ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }
    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Point2D target_world_space_pos = 2;


    pub fn get_target_world_space_pos(&self) -> &super::common::Point2D {
        match self.target {
            ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(ref v)) => v,
            _ => <super::common::Point2D as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_target_world_space_pos(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_world_space_pos(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_world_space_pos(&mut self, v: super::common::Point2D) {
        self.target = ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_world_space_pos(&mut self) -> &mut super::common::Point2D {
        if let ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(super::common::Point2D::new()));
        }
        match self.target {
            ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_world_space_pos(&mut self) -> super::common::Point2D {
        if self.has_target_world_space_pos() {
            match self.target.take() {
                ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::Point2D::new()
        }
    }

    // optional uint64 target_unit_tag = 3;


    pub fn get_target_unit_tag(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_unit_tag(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_target_unit_tag(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_unit_tag(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_unit_tag(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_unit_tag(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_unit_tag(v))
    }

    // repeated uint64 unit_tags = 4;


    pub fn get_unit_tags(&self) -> &[u64] {
        &self.unit_tags
    }
    pub fn clear_unit_tags(&mut self) {
        self.unit_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_tags(&mut self, v: ::std::vec::Vec<u64>) {
        self.unit_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_tags(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.unit_tags
    }

    // Take field
    pub fn take_unit_tags(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.unit_tags, ::std::vec::Vec::new())
    }

    // optional bool queue_command = 5;


    pub fn get_queue_command(&self) -> bool {
        self.queue_command.unwrap_or(false)
    }
    pub fn clear_queue_command(&mut self) {
        self.queue_command = ::std::option::Option::None;
    }

    pub fn has_queue_command(&self) -> bool {
        self.queue_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_command(&mut self, v: bool) {
        self.queue_command = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionRawUnitCommand {
    fn is_initialized(&self) -> bool {
        if let Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_world_space_pos(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ActionRawUnitCommand_oneof_target::target_unit_tag(is.read_uint64()?));
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.unit_tags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.queue_command = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unit_tags {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.queue_command {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ActionRawUnitCommand_oneof_target::target_world_space_pos(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActionRawUnitCommand_oneof_target::target_unit_tag(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        for v in &self.unit_tags {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.queue_command {
            os.write_bool(5, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ActionRawUnitCommand_oneof_target::target_world_space_pos(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActionRawUnitCommand_oneof_target::target_unit_tag(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionRawUnitCommand {
        ActionRawUnitCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ability_id",
                |m: &ActionRawUnitCommand| { &m.ability_id },
                |m: &mut ActionRawUnitCommand| { &mut m.ability_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::common::Point2D>(
                "target_world_space_pos",
                ActionRawUnitCommand::has_target_world_space_pos,
                ActionRawUnitCommand::get_target_world_space_pos,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "target_unit_tag",
                ActionRawUnitCommand::has_target_unit_tag,
                ActionRawUnitCommand::get_target_unit_tag,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "unit_tags",
                |m: &ActionRawUnitCommand| { &m.unit_tags },
                |m: &mut ActionRawUnitCommand| { &mut m.unit_tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "queue_command",
                |m: &ActionRawUnitCommand| { &m.queue_command },
                |m: &mut ActionRawUnitCommand| { &mut m.queue_command },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionRawUnitCommand>(
                "ActionRawUnitCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionRawUnitCommand {
        static instance: ::protobuf::rt::LazyV2<ActionRawUnitCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionRawUnitCommand::new)
    }
}

impl ::protobuf::Clear for ActionRawUnitCommand {
    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.unit_tags.clear();
        self.queue_command = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionRawUnitCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRawUnitCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionRawCameraMove {
    // message fields
    pub center_world_space: ::protobuf::SingularPtrField<super::common::Point>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionRawCameraMove {
    fn default() -> &'a ActionRawCameraMove {
        <ActionRawCameraMove as ::protobuf::Message>::default_instance()
    }
}

impl ActionRawCameraMove {
    pub fn new() -> ActionRawCameraMove {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Point center_world_space = 1;


    pub fn get_center_world_space(&self) -> &super::common::Point {
        self.center_world_space.as_ref().unwrap_or_else(|| <super::common::Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_center_world_space(&mut self) {
        self.center_world_space.clear();
    }

    pub fn has_center_world_space(&self) -> bool {
        self.center_world_space.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_world_space(&mut self, v: super::common::Point) {
        self.center_world_space = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_center_world_space(&mut self) -> &mut super::common::Point {
        if self.center_world_space.is_none() {
            self.center_world_space.set_default();
        }
        self.center_world_space.as_mut().unwrap()
    }

    // Take field
    pub fn take_center_world_space(&mut self) -> super::common::Point {
        self.center_world_space.take().unwrap_or_else(|| super::common::Point::new())
    }
}

impl ::protobuf::Message for ActionRawCameraMove {
    fn is_initialized(&self) -> bool {
        for v in &self.center_world_space {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.center_world_space)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.center_world_space.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.center_world_space.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionRawCameraMove {
        ActionRawCameraMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point>>(
                "center_world_space",
                |m: &ActionRawCameraMove| { &m.center_world_space },
                |m: &mut ActionRawCameraMove| { &mut m.center_world_space },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionRawCameraMove>(
                "ActionRawCameraMove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionRawCameraMove {
        static instance: ::protobuf::rt::LazyV2<ActionRawCameraMove> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionRawCameraMove::new)
    }
}

impl ::protobuf::Clear for ActionRawCameraMove {
    fn clear(&mut self) {
        self.center_world_space.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionRawCameraMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRawCameraMove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionRawToggleAutocast {
    // message fields
    pub ability_id: ::std::option::Option<i32>,
    pub unit_tags: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionRawToggleAutocast {
    fn default() -> &'a ActionRawToggleAutocast {
        <ActionRawToggleAutocast as ::protobuf::Message>::default_instance()
    }
}

impl ActionRawToggleAutocast {
    pub fn new() -> ActionRawToggleAutocast {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;


    pub fn get_ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }
    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // repeated uint64 unit_tags = 2;


    pub fn get_unit_tags(&self) -> &[u64] {
        &self.unit_tags
    }
    pub fn clear_unit_tags(&mut self) {
        self.unit_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_tags(&mut self, v: ::std::vec::Vec<u64>) {
        self.unit_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_tags(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.unit_tags
    }

    // Take field
    pub fn take_unit_tags(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.unit_tags, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActionRawToggleAutocast {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.unit_tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unit_tags {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        for v in &self.unit_tags {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionRawToggleAutocast {
        ActionRawToggleAutocast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ability_id",
                |m: &ActionRawToggleAutocast| { &m.ability_id },
                |m: &mut ActionRawToggleAutocast| { &mut m.ability_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "unit_tags",
                |m: &ActionRawToggleAutocast| { &m.unit_tags },
                |m: &mut ActionRawToggleAutocast| { &mut m.unit_tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionRawToggleAutocast>(
                "ActionRawToggleAutocast",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionRawToggleAutocast {
        static instance: ::protobuf::rt::LazyV2<ActionRawToggleAutocast> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionRawToggleAutocast::new)
    }
}

impl ::protobuf::Clear for ActionRawToggleAutocast {
    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.unit_tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionRawToggleAutocast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRawToggleAutocast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DisplayType {
    Visible = 1,
    Snapshot = 2,
    Hidden = 3,
    Placeholder = 4,
}

impl ::protobuf::ProtobufEnum for DisplayType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DisplayType> {
        match value {
            1 => ::std::option::Option::Some(DisplayType::Visible),
            2 => ::std::option::Option::Some(DisplayType::Snapshot),
            3 => ::std::option::Option::Some(DisplayType::Hidden),
            4 => ::std::option::Option::Some(DisplayType::Placeholder),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DisplayType] = &[
            DisplayType::Visible,
            DisplayType::Snapshot,
            DisplayType::Hidden,
            DisplayType::Placeholder,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DisplayType>("DisplayType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DisplayType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DisplayType {
    fn default() -> Self {
        DisplayType::Visible
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Alliance {
    value_Self = 1,
    Ally = 2,
    Neutral = 3,
    Enemy = 4,
}

impl ::protobuf::ProtobufEnum for Alliance {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Alliance> {
        match value {
            1 => ::std::option::Option::Some(Alliance::value_Self),
            2 => ::std::option::Option::Some(Alliance::Ally),
            3 => ::std::option::Option::Some(Alliance::Neutral),
            4 => ::std::option::Option::Some(Alliance::Enemy),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Alliance] = &[
            Alliance::value_Self,
            Alliance::Ally,
            Alliance::Neutral,
            Alliance::Enemy,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Alliance>("Alliance", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Alliance {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Alliance {
    fn default() -> Self {
        Alliance::value_Self
    }
}

impl ::protobuf::reflect::ProtobufValue for Alliance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CloakState {
    CloakedUnknown = 0,
    Cloaked = 1,
    CloakedDetected = 2,
    NotCloaked = 3,
    CloakedAllied = 4,
}

impl ::protobuf::ProtobufEnum for CloakState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CloakState> {
        match value {
            0 => ::std::option::Option::Some(CloakState::CloakedUnknown),
            1 => ::std::option::Option::Some(CloakState::Cloaked),
            2 => ::std::option::Option::Some(CloakState::CloakedDetected),
            3 => ::std::option::Option::Some(CloakState::NotCloaked),
            4 => ::std::option::Option::Some(CloakState::CloakedAllied),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CloakState] = &[
            CloakState::CloakedUnknown,
            CloakState::Cloaked,
            CloakState::CloakedDetected,
            CloakState::NotCloaked,
            CloakState::CloakedAllied,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CloakState>("CloakState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CloakState {
}

impl ::std::default::Default for CloakState {
    fn default() -> Self {
        CloakState::CloakedUnknown
    }
}

impl ::protobuf::reflect::ProtobufValue for CloakState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1as2clientprotocol/raw.proto\x12\x0eSC2APIProtocol\x1a\x1ds2clientpr\
    otocol/common.proto\"\x83\x03\n\x08StartRaw\x122\n\x08map_size\x18\x01\
    \x20\x01(\x0b2\x17.SC2APIProtocol.Size2DIR\x07mapSize\x12<\n\x0cpathing_\
    grid\x18\x02\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x0bpathingGrid\
    \x12@\n\x0eterrain_height\x18\x03\x20\x01(\x0b2\x19.SC2APIProtocol.Image\
    DataR\rterrainHeight\x12@\n\x0eplacement_grid\x18\x04\x20\x01(\x0b2\x19.\
    SC2APIProtocol.ImageDataR\rplacementGrid\x12?\n\rplayable_area\x18\x05\
    \x20\x01(\x0b2\x1a.SC2APIProtocol.RectangleIR\x0cplayableArea\x12@\n\x0f\
    start_locations\x18\x06\x20\x03(\x0b2\x17.SC2APIProtocol.Point2DR\x0esta\
    rtLocations\"\xb6\x02\n\x0eObservationRaw\x121\n\x06player\x18\x01\x20\
    \x01(\x0b2\x19.SC2APIProtocol.PlayerRawR\x06player\x12*\n\x05units\x18\
    \x02\x20\x03(\x0b2\x14.SC2APIProtocol.UnitR\x05units\x125\n\tmap_state\
    \x18\x03\x20\x01(\x0b2\x18.SC2APIProtocol.MapStateR\x08mapState\x12+\n\
    \x05event\x18\x04\x20\x01(\x0b2\x15.SC2APIProtocol.EventR\x05event\x120\
    \n\x07effects\x18\x05\x20\x03(\x0b2\x16.SC2APIProtocol.EffectR\x07effect\
    s\x12/\n\x05radar\x18\x06\x20\x03(\x0b2\x19.SC2APIProtocol.RadarRingR\
    \x05radar\"L\n\tRadarRing\x12'\n\x03pos\x18\x01\x20\x01(\x0b2\x15.SC2API\
    Protocol.PointR\x03pos\x12\x16\n\x06radius\x18\x02\x20\x01(\x02R\x06radi\
    us\"`\n\x0bPowerSource\x12'\n\x03pos\x18\x01\x20\x01(\x0b2\x15.SC2APIPro\
    tocol.PointR\x03pos\x12\x16\n\x06radius\x18\x02\x20\x01(\x02R\x06radius\
    \x12\x10\n\x03tag\x18\x03\x20\x01(\x04R\x03tag\"\x9d\x01\n\tPlayerRaw\
    \x12@\n\rpower_sources\x18\x01\x20\x03(\x0b2\x1b.SC2APIProtocol.PowerSou\
    rceR\x0cpowerSources\x12-\n\x06camera\x18\x02\x20\x01(\x0b2\x15.SC2APIPr\
    otocol.PointR\x06camera\x12\x1f\n\x0bupgrade_ids\x18\x03\x20\x03(\rR\nup\
    gradeIds\"\xc8\x01\n\tUnitOrder\x12\x1d\n\nability_id\x18\x01\x20\x01(\r\
    R\tabilityId\x12L\n\x16target_world_space_pos\x18\x02\x20\x01(\x0b2\x15.\
    SC2APIProtocol.PointH\0R\x13targetWorldSpacePos\x12(\n\x0ftarget_unit_ta\
    g\x18\x03\x20\x01(\x04H\0R\rtargetUnitTag\x12\x1a\n\x08progress\x18\x04\
    \x20\x01(\x02R\x08progressB\x08\n\x06target\"\xe3\x01\n\rPassengerUnit\
    \x12\x10\n\x03tag\x18\x01\x20\x01(\x04R\x03tag\x12\x16\n\x06health\x18\
    \x02\x20\x01(\x02R\x06health\x12\x1d\n\nhealth_max\x18\x03\x20\x01(\x02R\
    \thealthMax\x12\x16\n\x06shield\x18\x04\x20\x01(\x02R\x06shield\x12\x1d\
    \n\nshield_max\x18\x07\x20\x01(\x02R\tshieldMax\x12\x16\n\x06energy\x18\
    \x05\x20\x01(\x02R\x06energy\x12\x1d\n\nenergy_max\x18\x08\x20\x01(\x02R\
    \tenergyMax\x12\x1b\n\tunit_type\x18\x06\x20\x01(\rR\x08unitType\"L\n\
    \x0bRallyTarget\x12+\n\x05point\x18\x01\x20\x01(\x0b2\x15.SC2APIProtocol\
    .PointR\x05point\x12\x10\n\x03tag\x18\x02\x20\x01(\x04R\x03tag\"\x99\r\n\
    \x04Unit\x12>\n\x0cdisplay_type\x18\x01\x20\x01(\x0e2\x1b.SC2APIProtocol\
    .DisplayTypeR\x0bdisplayType\x124\n\x08alliance\x18\x02\x20\x01(\x0e2\
    \x18.SC2APIProtocol.AllianceR\x08alliance\x12\x10\n\x03tag\x18\x03\x20\
    \x01(\x04R\x03tag\x12\x1b\n\tunit_type\x18\x04\x20\x01(\rR\x08unitType\
    \x12\x14\n\x05owner\x18\x05\x20\x01(\x05R\x05owner\x12'\n\x03pos\x18\x06\
    \x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x03pos\x12\x16\n\x06facing\x18\
    \x07\x20\x01(\x02R\x06facing\x12\x16\n\x06radius\x18\x08\x20\x01(\x02R\
    \x06radius\x12%\n\x0ebuild_progress\x18\t\x20\x01(\x02R\rbuildProgress\
    \x120\n\x05cloak\x18\n\x20\x01(\x0e2\x1a.SC2APIProtocol.CloakStateR\x05c\
    loak\x12\x19\n\x08buff_ids\x18\x1b\x20\x03(\rR\x07buffIds\x12!\n\x0cdete\
    ct_range\x18\x1f\x20\x01(\x02R\x0bdetectRange\x12\x1f\n\x0bradar_range\
    \x18\x20\x20\x01(\x02R\nradarRange\x12\x1f\n\x0bis_selected\x18\x0b\x20\
    \x01(\x08R\nisSelected\x12\x20\n\x0cis_on_screen\x18\x0c\x20\x01(\x08R\n\
    isOnScreen\x12\x17\n\x07is_blip\x18\r\x20\x01(\x08R\x06isBlip\x12\x1d\n\
    \nis_powered\x18#\x20\x01(\x08R\tisPowered\x12\x1b\n\tis_active\x18'\x20\
    \x01(\x08R\x08isActive\x120\n\x14attack_upgrade_level\x18(\x20\x01(\x05R\
    \x12attackUpgradeLevel\x12.\n\x13armor_upgrade_level\x18)\x20\x01(\x05R\
    \x11armorUpgradeLevel\x120\n\x14shield_upgrade_level\x18*\x20\x01(\x05R\
    \x12shieldUpgradeLevel\x12\x16\n\x06health\x18\x0e\x20\x01(\x02R\x06heal\
    th\x12\x1d\n\nhealth_max\x18\x0f\x20\x01(\x02R\thealthMax\x12\x16\n\x06s\
    hield\x18\x10\x20\x01(\x02R\x06shield\x12\x1d\n\nshield_max\x18$\x20\x01\
    (\x02R\tshieldMax\x12\x16\n\x06energy\x18\x11\x20\x01(\x02R\x06energy\
    \x12\x1d\n\nenergy_max\x18%\x20\x01(\x02R\tenergyMax\x12)\n\x10mineral_c\
    ontents\x18\x12\x20\x01(\x05R\x0fmineralContents\x12)\n\x10vespene_conte\
    nts\x18\x13\x20\x01(\x05R\x0fvespeneContents\x12\x1b\n\tis_flying\x18\
    \x14\x20\x01(\x08R\x08isFlying\x12\x1f\n\x0bis_burrowed\x18\x15\x20\x01(\
    \x08R\nisBurrowed\x12)\n\x10is_hallucination\x18&\x20\x01(\x08R\x0fisHal\
    lucination\x121\n\x06orders\x18\x16\x20\x03(\x0b2\x19.SC2APIProtocol.Uni\
    tOrderR\x06orders\x12\x1c\n\nadd_on_tag\x18\x17\x20\x01(\x04R\x08addOnTa\
    g\x12=\n\npassengers\x18\x18\x20\x03(\x0b2\x1d.SC2APIProtocol.PassengerU\
    nitR\npassengers\x12*\n\x11cargo_space_taken\x18\x19\x20\x01(\x05R\x0fca\
    rgoSpaceTaken\x12&\n\x0fcargo_space_max\x18\x1a\x20\x01(\x05R\rcargoSpac\
    eMax\x12/\n\x13assigned_harvesters\x18\x1c\x20\x01(\x05R\x12assignedHarv\
    esters\x12)\n\x10ideal_harvesters\x18\x1d\x20\x01(\x05R\x0fidealHarveste\
    rs\x12'\n\x0fweapon_cooldown\x18\x1e\x20\x01(\x02R\x0eweaponCooldown\x12\
    ,\n\x12engaged_target_tag\x18\"\x20\x01(\x04R\x10engagedTargetTag\x120\n\
    \x14buff_duration_remain\x18+\x20\x01(\x05R\x12buffDurationRemain\x12*\n\
    \x11buff_duration_max\x18,\x20\x01(\x05R\x0fbuffDurationMax\x12@\n\rrall\
    y_targets\x18-\x20\x03(\x0b2\x1b.SC2APIProtocol.RallyTargetR\x0crallyTar\
    gets\"v\n\x08MapState\x129\n\nvisibility\x18\x01\x20\x01(\x0b2\x19.SC2AP\
    IProtocol.ImageDataR\nvisibility\x12/\n\x05creep\x18\x02\x20\x01(\x0b2\
    \x19.SC2APIProtocol.ImageDataR\x05creep\"&\n\x05Event\x12\x1d\n\ndead_un\
    its\x18\x01\x20\x03(\x04R\tdeadUnits\"\xb4\x01\n\x06Effect\x12\x1b\n\tef\
    fect_id\x18\x01\x20\x01(\rR\x08effectId\x12)\n\x03pos\x18\x02\x20\x03(\
    \x0b2\x17.SC2APIProtocol.Point2DR\x03pos\x124\n\x08alliance\x18\x03\x20\
    \x01(\x0e2\x18.SC2APIProtocol.AllianceR\x08alliance\x12\x14\n\x05owner\
    \x18\x04\x20\x01(\x05R\x05owner\x12\x16\n\x06radius\x18\x05\x20\x01(\x02\
    R\x06radius\"\xfc\x01\n\tActionRaw\x12I\n\x0cunit_command\x18\x01\x20\
    \x01(\x0b2$.SC2APIProtocol.ActionRawUnitCommandH\0R\x0bunitCommand\x12F\
    \n\x0bcamera_move\x18\x02\x20\x01(\x0b2#.SC2APIProtocol.ActionRawCameraM\
    oveH\0R\ncameraMove\x12R\n\x0ftoggle_autocast\x18\x03\x20\x01(\x0b2'.SC2\
    APIProtocol.ActionRawToggleAutocastH\0R\x0etoggleAutocastB\x08\n\x06acti\
    on\"\xfb\x01\n\x14ActionRawUnitCommand\x12\x1d\n\nability_id\x18\x01\x20\
    \x01(\x05R\tabilityId\x12N\n\x16target_world_space_pos\x18\x02\x20\x01(\
    \x0b2\x17.SC2APIProtocol.Point2DH\0R\x13targetWorldSpacePos\x12(\n\x0fta\
    rget_unit_tag\x18\x03\x20\x01(\x04H\0R\rtargetUnitTag\x12\x1b\n\tunit_ta\
    gs\x18\x04\x20\x03(\x04R\x08unitTags\x12#\n\rqueue_command\x18\x05\x20\
    \x01(\x08R\x0cqueueCommandB\x08\n\x06target\"Z\n\x13ActionRawCameraMove\
    \x12C\n\x12center_world_space\x18\x01\x20\x01(\x0b2\x15.SC2APIProtocol.P\
    ointR\x10centerWorldSpace\"U\n\x17ActionRawToggleAutocast\x12\x1d\n\nabi\
    lity_id\x18\x01\x20\x01(\x05R\tabilityId\x12\x1b\n\tunit_tags\x18\x02\
    \x20\x03(\x04R\x08unitTags*E\n\x0bDisplayType\x12\x0b\n\x07Visible\x10\
    \x01\x12\x0c\n\x08Snapshot\x10\x02\x12\n\n\x06Hidden\x10\x03\x12\x0f\n\
    \x0bPlaceholder\x10\x04*6\n\x08Alliance\x12\x08\n\x04Self\x10\x01\x12\
    \x08\n\x04Ally\x10\x02\x12\x0b\n\x07Neutral\x10\x03\x12\t\n\x05Enemy\x10\
    \x04*e\n\nCloakState\x12\x12\n\x0eCloakedUnknown\x10\0\x12\x0b\n\x07Cloa\
    ked\x10\x01\x12\x13\n\x0fCloakedDetected\x10\x02\x12\x0e\n\nNotCloaked\
    \x10\x03\x12\x11\n\rCloakedAllied\x10\x04\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
