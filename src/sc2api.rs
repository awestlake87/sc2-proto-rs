// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `s2clientprotocol/sc2api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message fields
    pub id: ::std::option::Option<u32>,
    // message oneof groups
    pub request: ::std::option::Option<Request_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Request_oneof_request {
    create_game(RequestCreateGame),
    join_game(RequestJoinGame),
    restart_game(RequestRestartGame),
    start_replay(RequestStartReplay),
    leave_game(RequestLeaveGame),
    quick_save(RequestQuickSave),
    quick_load(RequestQuickLoad),
    quit(RequestQuit),
    game_info(RequestGameInfo),
    observation(RequestObservation),
    action(RequestAction),
    obs_action(RequestObserverAction),
    step(RequestStep),
    data(RequestData),
    query(super::query::RequestQuery),
    save_replay(RequestSaveReplay),
    map_command(RequestMapCommand),
    replay_info(RequestReplayInfo),
    available_maps(RequestAvailableMaps),
    save_map(RequestSaveMap),
    ping(RequestPing),
    debug(RequestDebug),
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.RequestCreateGame create_game = 1;


    pub fn get_create_game(&self) -> &RequestCreateGame {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::create_game(ref v)) => v,
            _ => <RequestCreateGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_create_game(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_create_game(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::create_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_game(&mut self, v: RequestCreateGame) {
        self.request = ::std::option::Option::Some(Request_oneof_request::create_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_game(&mut self) -> &mut RequestCreateGame {
        if let ::std::option::Option::Some(Request_oneof_request::create_game(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::create_game(RequestCreateGame::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::create_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_game(&mut self) -> RequestCreateGame {
        if self.has_create_game() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::create_game(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestCreateGame::new()
        }
    }

    // optional .SC2APIProtocol.RequestJoinGame join_game = 2;


    pub fn get_join_game(&self) -> &RequestJoinGame {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::join_game(ref v)) => v,
            _ => <RequestJoinGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_join_game(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_join_game(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::join_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_join_game(&mut self, v: RequestJoinGame) {
        self.request = ::std::option::Option::Some(Request_oneof_request::join_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_join_game(&mut self) -> &mut RequestJoinGame {
        if let ::std::option::Option::Some(Request_oneof_request::join_game(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::join_game(RequestJoinGame::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::join_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_join_game(&mut self) -> RequestJoinGame {
        if self.has_join_game() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::join_game(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestJoinGame::new()
        }
    }

    // optional .SC2APIProtocol.RequestRestartGame restart_game = 3;


    pub fn get_restart_game(&self) -> &RequestRestartGame {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::restart_game(ref v)) => v,
            _ => <RequestRestartGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_restart_game(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_restart_game(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::restart_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_restart_game(&mut self, v: RequestRestartGame) {
        self.request = ::std::option::Option::Some(Request_oneof_request::restart_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_restart_game(&mut self) -> &mut RequestRestartGame {
        if let ::std::option::Option::Some(Request_oneof_request::restart_game(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::restart_game(RequestRestartGame::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::restart_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_restart_game(&mut self) -> RequestRestartGame {
        if self.has_restart_game() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::restart_game(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestRestartGame::new()
        }
    }

    // optional .SC2APIProtocol.RequestStartReplay start_replay = 4;


    pub fn get_start_replay(&self) -> &RequestStartReplay {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::start_replay(ref v)) => v,
            _ => <RequestStartReplay as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_start_replay(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_start_replay(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::start_replay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_replay(&mut self, v: RequestStartReplay) {
        self.request = ::std::option::Option::Some(Request_oneof_request::start_replay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_replay(&mut self) -> &mut RequestStartReplay {
        if let ::std::option::Option::Some(Request_oneof_request::start_replay(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::start_replay(RequestStartReplay::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::start_replay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_replay(&mut self) -> RequestStartReplay {
        if self.has_start_replay() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::start_replay(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestStartReplay::new()
        }
    }

    // optional .SC2APIProtocol.RequestLeaveGame leave_game = 5;


    pub fn get_leave_game(&self) -> &RequestLeaveGame {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::leave_game(ref v)) => v,
            _ => <RequestLeaveGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_leave_game(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_leave_game(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::leave_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_leave_game(&mut self, v: RequestLeaveGame) {
        self.request = ::std::option::Option::Some(Request_oneof_request::leave_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_leave_game(&mut self) -> &mut RequestLeaveGame {
        if let ::std::option::Option::Some(Request_oneof_request::leave_game(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::leave_game(RequestLeaveGame::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::leave_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_leave_game(&mut self) -> RequestLeaveGame {
        if self.has_leave_game() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::leave_game(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestLeaveGame::new()
        }
    }

    // optional .SC2APIProtocol.RequestQuickSave quick_save = 6;


    pub fn get_quick_save(&self) -> &RequestQuickSave {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quick_save(ref v)) => v,
            _ => <RequestQuickSave as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_quick_save(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_quick_save(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quick_save(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quick_save(&mut self, v: RequestQuickSave) {
        self.request = ::std::option::Option::Some(Request_oneof_request::quick_save(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quick_save(&mut self) -> &mut RequestQuickSave {
        if let ::std::option::Option::Some(Request_oneof_request::quick_save(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::quick_save(RequestQuickSave::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quick_save(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quick_save(&mut self) -> RequestQuickSave {
        if self.has_quick_save() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::quick_save(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestQuickSave::new()
        }
    }

    // optional .SC2APIProtocol.RequestQuickLoad quick_load = 7;


    pub fn get_quick_load(&self) -> &RequestQuickLoad {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quick_load(ref v)) => v,
            _ => <RequestQuickLoad as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_quick_load(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_quick_load(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quick_load(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quick_load(&mut self, v: RequestQuickLoad) {
        self.request = ::std::option::Option::Some(Request_oneof_request::quick_load(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quick_load(&mut self) -> &mut RequestQuickLoad {
        if let ::std::option::Option::Some(Request_oneof_request::quick_load(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::quick_load(RequestQuickLoad::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quick_load(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quick_load(&mut self) -> RequestQuickLoad {
        if self.has_quick_load() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::quick_load(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestQuickLoad::new()
        }
    }

    // optional .SC2APIProtocol.RequestQuit quit = 8;


    pub fn get_quit(&self) -> &RequestQuit {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quit(ref v)) => v,
            _ => <RequestQuit as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_quit(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_quit(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quit(&mut self, v: RequestQuit) {
        self.request = ::std::option::Option::Some(Request_oneof_request::quit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quit(&mut self) -> &mut RequestQuit {
        if let ::std::option::Option::Some(Request_oneof_request::quit(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::quit(RequestQuit::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::quit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quit(&mut self) -> RequestQuit {
        if self.has_quit() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::quit(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestQuit::new()
        }
    }

    // optional .SC2APIProtocol.RequestGameInfo game_info = 9;


    pub fn get_game_info(&self) -> &RequestGameInfo {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::game_info(ref v)) => v,
            _ => <RequestGameInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_game_info(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_game_info(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::game_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_game_info(&mut self, v: RequestGameInfo) {
        self.request = ::std::option::Option::Some(Request_oneof_request::game_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_game_info(&mut self) -> &mut RequestGameInfo {
        if let ::std::option::Option::Some(Request_oneof_request::game_info(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::game_info(RequestGameInfo::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::game_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_game_info(&mut self) -> RequestGameInfo {
        if self.has_game_info() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::game_info(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestGameInfo::new()
        }
    }

    // optional .SC2APIProtocol.RequestObservation observation = 10;


    pub fn get_observation(&self) -> &RequestObservation {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::observation(ref v)) => v,
            _ => <RequestObservation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_observation(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_observation(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::observation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_observation(&mut self, v: RequestObservation) {
        self.request = ::std::option::Option::Some(Request_oneof_request::observation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_observation(&mut self) -> &mut RequestObservation {
        if let ::std::option::Option::Some(Request_oneof_request::observation(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::observation(RequestObservation::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::observation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_observation(&mut self) -> RequestObservation {
        if self.has_observation() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::observation(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestObservation::new()
        }
    }

    // optional .SC2APIProtocol.RequestAction action = 11;


    pub fn get_action(&self) -> &RequestAction {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::action(ref v)) => v,
            _ => <RequestAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_action(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RequestAction) {
        self.request = ::std::option::Option::Some(Request_oneof_request::action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action(&mut self) -> &mut RequestAction {
        if let ::std::option::Option::Some(Request_oneof_request::action(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::action(RequestAction::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action(&mut self) -> RequestAction {
        if self.has_action() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::action(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestAction::new()
        }
    }

    // optional .SC2APIProtocol.RequestObserverAction obs_action = 21;


    pub fn get_obs_action(&self) -> &RequestObserverAction {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::obs_action(ref v)) => v,
            _ => <RequestObserverAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_obs_action(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_obs_action(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::obs_action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_obs_action(&mut self, v: RequestObserverAction) {
        self.request = ::std::option::Option::Some(Request_oneof_request::obs_action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_obs_action(&mut self) -> &mut RequestObserverAction {
        if let ::std::option::Option::Some(Request_oneof_request::obs_action(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::obs_action(RequestObserverAction::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::obs_action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_obs_action(&mut self) -> RequestObserverAction {
        if self.has_obs_action() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::obs_action(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestObserverAction::new()
        }
    }

    // optional .SC2APIProtocol.RequestStep step = 12;


    pub fn get_step(&self) -> &RequestStep {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::step(ref v)) => v,
            _ => <RequestStep as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_step(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_step(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::step(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: RequestStep) {
        self.request = ::std::option::Option::Some(Request_oneof_request::step(v))
    }

    // Mutable pointer to the field.
    pub fn mut_step(&mut self) -> &mut RequestStep {
        if let ::std::option::Option::Some(Request_oneof_request::step(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::step(RequestStep::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::step(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_step(&mut self) -> RequestStep {
        if self.has_step() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::step(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestStep::new()
        }
    }

    // optional .SC2APIProtocol.RequestData data = 13;


    pub fn get_data(&self) -> &RequestData {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::data(ref v)) => v,
            _ => <RequestData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_data(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: RequestData) {
        self.request = ::std::option::Option::Some(Request_oneof_request::data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut RequestData {
        if let ::std::option::Option::Some(Request_oneof_request::data(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::data(RequestData::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data(&mut self) -> RequestData {
        if self.has_data() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::data(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestData::new()
        }
    }

    // optional .SC2APIProtocol.RequestQuery query = 14;


    pub fn get_query(&self) -> &super::query::RequestQuery {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::query(ref v)) => v,
            _ => <super::query::RequestQuery as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_query(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: super::query::RequestQuery) {
        self.request = ::std::option::Option::Some(Request_oneof_request::query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut super::query::RequestQuery {
        if let ::std::option::Option::Some(Request_oneof_request::query(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::query(super::query::RequestQuery::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query(&mut self) -> super::query::RequestQuery {
        if self.has_query() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::query(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::RequestQuery::new()
        }
    }

    // optional .SC2APIProtocol.RequestSaveReplay save_replay = 15;


    pub fn get_save_replay(&self) -> &RequestSaveReplay {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::save_replay(ref v)) => v,
            _ => <RequestSaveReplay as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_save_replay(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_save_replay(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::save_replay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_save_replay(&mut self, v: RequestSaveReplay) {
        self.request = ::std::option::Option::Some(Request_oneof_request::save_replay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_save_replay(&mut self) -> &mut RequestSaveReplay {
        if let ::std::option::Option::Some(Request_oneof_request::save_replay(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::save_replay(RequestSaveReplay::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::save_replay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_save_replay(&mut self) -> RequestSaveReplay {
        if self.has_save_replay() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::save_replay(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestSaveReplay::new()
        }
    }

    // optional .SC2APIProtocol.RequestMapCommand map_command = 22;


    pub fn get_map_command(&self) -> &RequestMapCommand {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::map_command(ref v)) => v,
            _ => <RequestMapCommand as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_map_command(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_map_command(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::map_command(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_command(&mut self, v: RequestMapCommand) {
        self.request = ::std::option::Option::Some(Request_oneof_request::map_command(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_command(&mut self) -> &mut RequestMapCommand {
        if let ::std::option::Option::Some(Request_oneof_request::map_command(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::map_command(RequestMapCommand::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::map_command(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_command(&mut self) -> RequestMapCommand {
        if self.has_map_command() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::map_command(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestMapCommand::new()
        }
    }

    // optional .SC2APIProtocol.RequestReplayInfo replay_info = 16;


    pub fn get_replay_info(&self) -> &RequestReplayInfo {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::replay_info(ref v)) => v,
            _ => <RequestReplayInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_replay_info(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_replay_info(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::replay_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_info(&mut self, v: RequestReplayInfo) {
        self.request = ::std::option::Option::Some(Request_oneof_request::replay_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_info(&mut self) -> &mut RequestReplayInfo {
        if let ::std::option::Option::Some(Request_oneof_request::replay_info(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::replay_info(RequestReplayInfo::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::replay_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_info(&mut self) -> RequestReplayInfo {
        if self.has_replay_info() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::replay_info(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestReplayInfo::new()
        }
    }

    // optional .SC2APIProtocol.RequestAvailableMaps available_maps = 17;


    pub fn get_available_maps(&self) -> &RequestAvailableMaps {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::available_maps(ref v)) => v,
            _ => <RequestAvailableMaps as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_available_maps(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_available_maps(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::available_maps(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_available_maps(&mut self, v: RequestAvailableMaps) {
        self.request = ::std::option::Option::Some(Request_oneof_request::available_maps(v))
    }

    // Mutable pointer to the field.
    pub fn mut_available_maps(&mut self) -> &mut RequestAvailableMaps {
        if let ::std::option::Option::Some(Request_oneof_request::available_maps(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::available_maps(RequestAvailableMaps::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::available_maps(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_available_maps(&mut self) -> RequestAvailableMaps {
        if self.has_available_maps() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::available_maps(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestAvailableMaps::new()
        }
    }

    // optional .SC2APIProtocol.RequestSaveMap save_map = 18;


    pub fn get_save_map(&self) -> &RequestSaveMap {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::save_map(ref v)) => v,
            _ => <RequestSaveMap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_save_map(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_save_map(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::save_map(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_save_map(&mut self, v: RequestSaveMap) {
        self.request = ::std::option::Option::Some(Request_oneof_request::save_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_save_map(&mut self) -> &mut RequestSaveMap {
        if let ::std::option::Option::Some(Request_oneof_request::save_map(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::save_map(RequestSaveMap::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::save_map(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_save_map(&mut self) -> RequestSaveMap {
        if self.has_save_map() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::save_map(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestSaveMap::new()
        }
    }

    // optional .SC2APIProtocol.RequestPing ping = 19;


    pub fn get_ping(&self) -> &RequestPing {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::ping(ref v)) => v,
            _ => <RequestPing as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ping(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: RequestPing) {
        self.request = ::std::option::Option::Some(Request_oneof_request::ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut RequestPing {
        if let ::std::option::Option::Some(Request_oneof_request::ping(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::ping(RequestPing::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> RequestPing {
        if self.has_ping() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::ping(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestPing::new()
        }
    }

    // optional .SC2APIProtocol.RequestDebug debug = 20;


    pub fn get_debug(&self) -> &RequestDebug {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::debug(ref v)) => v,
            _ => <RequestDebug as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_debug(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_debug(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::debug(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: RequestDebug) {
        self.request = ::std::option::Option::Some(Request_oneof_request::debug(v))
    }

    // Mutable pointer to the field.
    pub fn mut_debug(&mut self) -> &mut RequestDebug {
        if let ::std::option::Option::Some(Request_oneof_request::debug(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Request_oneof_request::debug(RequestDebug::new()));
        }
        match self.request {
            ::std::option::Option::Some(Request_oneof_request::debug(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_debug(&mut self) -> RequestDebug {
        if self.has_debug() {
            match self.request.take() {
                ::std::option::Option::Some(Request_oneof_request::debug(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestDebug::new()
        }
    }

    // optional uint32 id = 97;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        if let Some(Request_oneof_request::create_game(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::join_game(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::restart_game(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::start_replay(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::leave_game(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::quick_save(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::quick_load(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::quit(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::game_info(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::observation(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::action(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::obs_action(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::step(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::data(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::query(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::save_replay(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::map_command(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::replay_info(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::available_maps(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::save_map(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::ping(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Request_oneof_request::debug(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::create_game(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::join_game(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::restart_game(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::start_replay(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::leave_game(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::quick_save(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::quick_load(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::quit(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::game_info(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::observation(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::action(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::obs_action(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::step(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::data(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::query(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::save_replay(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::map_command(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::replay_info(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::available_maps(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::save_map(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::ping(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Request_oneof_request::debug(is.read_message()?));
                },
                97 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(97, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Request_oneof_request::create_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::join_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::restart_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::start_replay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::leave_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::quick_save(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::quick_load(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::quit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::game_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::observation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::action(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::obs_action(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::step(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::save_replay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::map_command(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::replay_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::available_maps(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::save_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Request_oneof_request::debug(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(97, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Request_oneof_request::create_game(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::join_game(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::restart_game(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::start_replay(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::leave_game(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::quick_save(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::quick_load(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::quit(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::game_info(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::observation(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::action(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::obs_action(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::step(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::data(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::query(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::save_replay(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::map_command(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::replay_info(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::available_maps(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::save_map(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::ping(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Request_oneof_request::debug(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestCreateGame>(
                "create_game",
                Request::has_create_game,
                Request::get_create_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestJoinGame>(
                "join_game",
                Request::has_join_game,
                Request::get_join_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestRestartGame>(
                "restart_game",
                Request::has_restart_game,
                Request::get_restart_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestStartReplay>(
                "start_replay",
                Request::has_start_replay,
                Request::get_start_replay,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestLeaveGame>(
                "leave_game",
                Request::has_leave_game,
                Request::get_leave_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestQuickSave>(
                "quick_save",
                Request::has_quick_save,
                Request::get_quick_save,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestQuickLoad>(
                "quick_load",
                Request::has_quick_load,
                Request::get_quick_load,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestQuit>(
                "quit",
                Request::has_quit,
                Request::get_quit,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestGameInfo>(
                "game_info",
                Request::has_game_info,
                Request::get_game_info,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestObservation>(
                "observation",
                Request::has_observation,
                Request::get_observation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestAction>(
                "action",
                Request::has_action,
                Request::get_action,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestObserverAction>(
                "obs_action",
                Request::has_obs_action,
                Request::get_obs_action,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestStep>(
                "step",
                Request::has_step,
                Request::get_step,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestData>(
                "data",
                Request::has_data,
                Request::get_data,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::query::RequestQuery>(
                "query",
                Request::has_query,
                Request::get_query,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestSaveReplay>(
                "save_replay",
                Request::has_save_replay,
                Request::get_save_replay,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestMapCommand>(
                "map_command",
                Request::has_map_command,
                Request::get_map_command,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestReplayInfo>(
                "replay_info",
                Request::has_replay_info,
                Request::get_replay_info,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestAvailableMaps>(
                "available_maps",
                Request::has_available_maps,
                Request::get_available_maps,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestSaveMap>(
                "save_map",
                Request::has_save_map,
                Request::get_save_map,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestPing>(
                "ping",
                Request::has_ping,
                Request::get_ping,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestDebug>(
                "debug",
                Request::has_debug,
                Request::get_debug,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Request| { &m.id },
                |m: &mut Request| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request>(
                "Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request {
        static instance: ::protobuf::rt::LazyV2<Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request::new)
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub id: ::std::option::Option<u32>,
    pub error: ::protobuf::RepeatedField<::std::string::String>,
    pub status: ::std::option::Option<Status>,
    // message oneof groups
    pub response: ::std::option::Option<Response_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Response_oneof_response {
    create_game(ResponseCreateGame),
    join_game(ResponseJoinGame),
    restart_game(ResponseRestartGame),
    start_replay(ResponseStartReplay),
    leave_game(ResponseLeaveGame),
    quick_save(ResponseQuickSave),
    quick_load(ResponseQuickLoad),
    quit(ResponseQuit),
    game_info(ResponseGameInfo),
    observation(ResponseObservation),
    action(ResponseAction),
    obs_action(ResponseObserverAction),
    step(ResponseStep),
    data(ResponseData),
    query(super::query::ResponseQuery),
    save_replay(ResponseSaveReplay),
    replay_info(ResponseReplayInfo),
    available_maps(ResponseAvailableMaps),
    save_map(ResponseSaveMap),
    map_command(ResponseMapCommand),
    ping(ResponsePing),
    debug(ResponseDebug),
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseCreateGame create_game = 1;


    pub fn get_create_game(&self) -> &ResponseCreateGame {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::create_game(ref v)) => v,
            _ => <ResponseCreateGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_create_game(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_create_game(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::create_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_game(&mut self, v: ResponseCreateGame) {
        self.response = ::std::option::Option::Some(Response_oneof_response::create_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_game(&mut self) -> &mut ResponseCreateGame {
        if let ::std::option::Option::Some(Response_oneof_response::create_game(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::create_game(ResponseCreateGame::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::create_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_game(&mut self) -> ResponseCreateGame {
        if self.has_create_game() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::create_game(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseCreateGame::new()
        }
    }

    // optional .SC2APIProtocol.ResponseJoinGame join_game = 2;


    pub fn get_join_game(&self) -> &ResponseJoinGame {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::join_game(ref v)) => v,
            _ => <ResponseJoinGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_join_game(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_join_game(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::join_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_join_game(&mut self, v: ResponseJoinGame) {
        self.response = ::std::option::Option::Some(Response_oneof_response::join_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_join_game(&mut self) -> &mut ResponseJoinGame {
        if let ::std::option::Option::Some(Response_oneof_response::join_game(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::join_game(ResponseJoinGame::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::join_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_join_game(&mut self) -> ResponseJoinGame {
        if self.has_join_game() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::join_game(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseJoinGame::new()
        }
    }

    // optional .SC2APIProtocol.ResponseRestartGame restart_game = 3;


    pub fn get_restart_game(&self) -> &ResponseRestartGame {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::restart_game(ref v)) => v,
            _ => <ResponseRestartGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_restart_game(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_restart_game(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::restart_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_restart_game(&mut self, v: ResponseRestartGame) {
        self.response = ::std::option::Option::Some(Response_oneof_response::restart_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_restart_game(&mut self) -> &mut ResponseRestartGame {
        if let ::std::option::Option::Some(Response_oneof_response::restart_game(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::restart_game(ResponseRestartGame::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::restart_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_restart_game(&mut self) -> ResponseRestartGame {
        if self.has_restart_game() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::restart_game(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseRestartGame::new()
        }
    }

    // optional .SC2APIProtocol.ResponseStartReplay start_replay = 4;


    pub fn get_start_replay(&self) -> &ResponseStartReplay {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::start_replay(ref v)) => v,
            _ => <ResponseStartReplay as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_start_replay(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_start_replay(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::start_replay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_replay(&mut self, v: ResponseStartReplay) {
        self.response = ::std::option::Option::Some(Response_oneof_response::start_replay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_replay(&mut self) -> &mut ResponseStartReplay {
        if let ::std::option::Option::Some(Response_oneof_response::start_replay(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::start_replay(ResponseStartReplay::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::start_replay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_replay(&mut self) -> ResponseStartReplay {
        if self.has_start_replay() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::start_replay(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseStartReplay::new()
        }
    }

    // optional .SC2APIProtocol.ResponseLeaveGame leave_game = 5;


    pub fn get_leave_game(&self) -> &ResponseLeaveGame {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::leave_game(ref v)) => v,
            _ => <ResponseLeaveGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_leave_game(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_leave_game(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::leave_game(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_leave_game(&mut self, v: ResponseLeaveGame) {
        self.response = ::std::option::Option::Some(Response_oneof_response::leave_game(v))
    }

    // Mutable pointer to the field.
    pub fn mut_leave_game(&mut self) -> &mut ResponseLeaveGame {
        if let ::std::option::Option::Some(Response_oneof_response::leave_game(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::leave_game(ResponseLeaveGame::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::leave_game(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_leave_game(&mut self) -> ResponseLeaveGame {
        if self.has_leave_game() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::leave_game(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseLeaveGame::new()
        }
    }

    // optional .SC2APIProtocol.ResponseQuickSave quick_save = 6;


    pub fn get_quick_save(&self) -> &ResponseQuickSave {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quick_save(ref v)) => v,
            _ => <ResponseQuickSave as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_quick_save(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_quick_save(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quick_save(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quick_save(&mut self, v: ResponseQuickSave) {
        self.response = ::std::option::Option::Some(Response_oneof_response::quick_save(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quick_save(&mut self) -> &mut ResponseQuickSave {
        if let ::std::option::Option::Some(Response_oneof_response::quick_save(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::quick_save(ResponseQuickSave::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quick_save(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quick_save(&mut self) -> ResponseQuickSave {
        if self.has_quick_save() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::quick_save(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseQuickSave::new()
        }
    }

    // optional .SC2APIProtocol.ResponseQuickLoad quick_load = 7;


    pub fn get_quick_load(&self) -> &ResponseQuickLoad {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quick_load(ref v)) => v,
            _ => <ResponseQuickLoad as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_quick_load(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_quick_load(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quick_load(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quick_load(&mut self, v: ResponseQuickLoad) {
        self.response = ::std::option::Option::Some(Response_oneof_response::quick_load(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quick_load(&mut self) -> &mut ResponseQuickLoad {
        if let ::std::option::Option::Some(Response_oneof_response::quick_load(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::quick_load(ResponseQuickLoad::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quick_load(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quick_load(&mut self) -> ResponseQuickLoad {
        if self.has_quick_load() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::quick_load(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseQuickLoad::new()
        }
    }

    // optional .SC2APIProtocol.ResponseQuit quit = 8;


    pub fn get_quit(&self) -> &ResponseQuit {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quit(ref v)) => v,
            _ => <ResponseQuit as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_quit(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_quit(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quit(&mut self, v: ResponseQuit) {
        self.response = ::std::option::Option::Some(Response_oneof_response::quit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quit(&mut self) -> &mut ResponseQuit {
        if let ::std::option::Option::Some(Response_oneof_response::quit(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::quit(ResponseQuit::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::quit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quit(&mut self) -> ResponseQuit {
        if self.has_quit() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::quit(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseQuit::new()
        }
    }

    // optional .SC2APIProtocol.ResponseGameInfo game_info = 9;


    pub fn get_game_info(&self) -> &ResponseGameInfo {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::game_info(ref v)) => v,
            _ => <ResponseGameInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_game_info(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_game_info(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::game_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_game_info(&mut self, v: ResponseGameInfo) {
        self.response = ::std::option::Option::Some(Response_oneof_response::game_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_game_info(&mut self) -> &mut ResponseGameInfo {
        if let ::std::option::Option::Some(Response_oneof_response::game_info(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::game_info(ResponseGameInfo::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::game_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_game_info(&mut self) -> ResponseGameInfo {
        if self.has_game_info() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::game_info(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseGameInfo::new()
        }
    }

    // optional .SC2APIProtocol.ResponseObservation observation = 10;


    pub fn get_observation(&self) -> &ResponseObservation {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::observation(ref v)) => v,
            _ => <ResponseObservation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_observation(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_observation(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::observation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_observation(&mut self, v: ResponseObservation) {
        self.response = ::std::option::Option::Some(Response_oneof_response::observation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_observation(&mut self) -> &mut ResponseObservation {
        if let ::std::option::Option::Some(Response_oneof_response::observation(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::observation(ResponseObservation::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::observation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_observation(&mut self) -> ResponseObservation {
        if self.has_observation() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::observation(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseObservation::new()
        }
    }

    // optional .SC2APIProtocol.ResponseAction action = 11;


    pub fn get_action(&self) -> &ResponseAction {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::action(ref v)) => v,
            _ => <ResponseAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_action(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ResponseAction) {
        self.response = ::std::option::Option::Some(Response_oneof_response::action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action(&mut self) -> &mut ResponseAction {
        if let ::std::option::Option::Some(Response_oneof_response::action(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::action(ResponseAction::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action(&mut self) -> ResponseAction {
        if self.has_action() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::action(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseAction::new()
        }
    }

    // optional .SC2APIProtocol.ResponseObserverAction obs_action = 21;


    pub fn get_obs_action(&self) -> &ResponseObserverAction {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::obs_action(ref v)) => v,
            _ => <ResponseObserverAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_obs_action(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_obs_action(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::obs_action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_obs_action(&mut self, v: ResponseObserverAction) {
        self.response = ::std::option::Option::Some(Response_oneof_response::obs_action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_obs_action(&mut self) -> &mut ResponseObserverAction {
        if let ::std::option::Option::Some(Response_oneof_response::obs_action(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::obs_action(ResponseObserverAction::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::obs_action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_obs_action(&mut self) -> ResponseObserverAction {
        if self.has_obs_action() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::obs_action(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseObserverAction::new()
        }
    }

    // optional .SC2APIProtocol.ResponseStep step = 12;


    pub fn get_step(&self) -> &ResponseStep {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::step(ref v)) => v,
            _ => <ResponseStep as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_step(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_step(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::step(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: ResponseStep) {
        self.response = ::std::option::Option::Some(Response_oneof_response::step(v))
    }

    // Mutable pointer to the field.
    pub fn mut_step(&mut self) -> &mut ResponseStep {
        if let ::std::option::Option::Some(Response_oneof_response::step(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::step(ResponseStep::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::step(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_step(&mut self) -> ResponseStep {
        if self.has_step() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::step(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseStep::new()
        }
    }

    // optional .SC2APIProtocol.ResponseData data = 13;


    pub fn get_data(&self) -> &ResponseData {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::data(ref v)) => v,
            _ => <ResponseData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_data(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ResponseData) {
        self.response = ::std::option::Option::Some(Response_oneof_response::data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ResponseData {
        if let ::std::option::Option::Some(Response_oneof_response::data(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::data(ResponseData::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data(&mut self) -> ResponseData {
        if self.has_data() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::data(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseData::new()
        }
    }

    // optional .SC2APIProtocol.ResponseQuery query = 14;


    pub fn get_query(&self) -> &super::query::ResponseQuery {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::query(ref v)) => v,
            _ => <super::query::ResponseQuery as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_query(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: super::query::ResponseQuery) {
        self.response = ::std::option::Option::Some(Response_oneof_response::query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut super::query::ResponseQuery {
        if let ::std::option::Option::Some(Response_oneof_response::query(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::query(super::query::ResponseQuery::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query(&mut self) -> super::query::ResponseQuery {
        if self.has_query() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::query(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::ResponseQuery::new()
        }
    }

    // optional .SC2APIProtocol.ResponseSaveReplay save_replay = 15;


    pub fn get_save_replay(&self) -> &ResponseSaveReplay {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::save_replay(ref v)) => v,
            _ => <ResponseSaveReplay as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_save_replay(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_save_replay(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::save_replay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_save_replay(&mut self, v: ResponseSaveReplay) {
        self.response = ::std::option::Option::Some(Response_oneof_response::save_replay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_save_replay(&mut self) -> &mut ResponseSaveReplay {
        if let ::std::option::Option::Some(Response_oneof_response::save_replay(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::save_replay(ResponseSaveReplay::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::save_replay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_save_replay(&mut self) -> ResponseSaveReplay {
        if self.has_save_replay() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::save_replay(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseSaveReplay::new()
        }
    }

    // optional .SC2APIProtocol.ResponseReplayInfo replay_info = 16;


    pub fn get_replay_info(&self) -> &ResponseReplayInfo {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::replay_info(ref v)) => v,
            _ => <ResponseReplayInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_replay_info(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_replay_info(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::replay_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_info(&mut self, v: ResponseReplayInfo) {
        self.response = ::std::option::Option::Some(Response_oneof_response::replay_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_info(&mut self) -> &mut ResponseReplayInfo {
        if let ::std::option::Option::Some(Response_oneof_response::replay_info(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::replay_info(ResponseReplayInfo::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::replay_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_info(&mut self) -> ResponseReplayInfo {
        if self.has_replay_info() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::replay_info(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseReplayInfo::new()
        }
    }

    // optional .SC2APIProtocol.ResponseAvailableMaps available_maps = 17;


    pub fn get_available_maps(&self) -> &ResponseAvailableMaps {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::available_maps(ref v)) => v,
            _ => <ResponseAvailableMaps as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_available_maps(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_available_maps(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::available_maps(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_available_maps(&mut self, v: ResponseAvailableMaps) {
        self.response = ::std::option::Option::Some(Response_oneof_response::available_maps(v))
    }

    // Mutable pointer to the field.
    pub fn mut_available_maps(&mut self) -> &mut ResponseAvailableMaps {
        if let ::std::option::Option::Some(Response_oneof_response::available_maps(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::available_maps(ResponseAvailableMaps::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::available_maps(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_available_maps(&mut self) -> ResponseAvailableMaps {
        if self.has_available_maps() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::available_maps(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseAvailableMaps::new()
        }
    }

    // optional .SC2APIProtocol.ResponseSaveMap save_map = 18;


    pub fn get_save_map(&self) -> &ResponseSaveMap {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::save_map(ref v)) => v,
            _ => <ResponseSaveMap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_save_map(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_save_map(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::save_map(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_save_map(&mut self, v: ResponseSaveMap) {
        self.response = ::std::option::Option::Some(Response_oneof_response::save_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_save_map(&mut self) -> &mut ResponseSaveMap {
        if let ::std::option::Option::Some(Response_oneof_response::save_map(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::save_map(ResponseSaveMap::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::save_map(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_save_map(&mut self) -> ResponseSaveMap {
        if self.has_save_map() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::save_map(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseSaveMap::new()
        }
    }

    // optional .SC2APIProtocol.ResponseMapCommand map_command = 22;


    pub fn get_map_command(&self) -> &ResponseMapCommand {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::map_command(ref v)) => v,
            _ => <ResponseMapCommand as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_map_command(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_map_command(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::map_command(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_command(&mut self, v: ResponseMapCommand) {
        self.response = ::std::option::Option::Some(Response_oneof_response::map_command(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_command(&mut self) -> &mut ResponseMapCommand {
        if let ::std::option::Option::Some(Response_oneof_response::map_command(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::map_command(ResponseMapCommand::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::map_command(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_command(&mut self) -> ResponseMapCommand {
        if self.has_map_command() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::map_command(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseMapCommand::new()
        }
    }

    // optional .SC2APIProtocol.ResponsePing ping = 19;


    pub fn get_ping(&self) -> &ResponsePing {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::ping(ref v)) => v,
            _ => <ResponsePing as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ping(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: ResponsePing) {
        self.response = ::std::option::Option::Some(Response_oneof_response::ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut ResponsePing {
        if let ::std::option::Option::Some(Response_oneof_response::ping(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::ping(ResponsePing::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> ResponsePing {
        if self.has_ping() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::ping(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponsePing::new()
        }
    }

    // optional .SC2APIProtocol.ResponseDebug debug = 20;


    pub fn get_debug(&self) -> &ResponseDebug {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::debug(ref v)) => v,
            _ => <ResponseDebug as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_debug(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_debug(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::debug(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ResponseDebug) {
        self.response = ::std::option::Option::Some(Response_oneof_response::debug(v))
    }

    // Mutable pointer to the field.
    pub fn mut_debug(&mut self) -> &mut ResponseDebug {
        if let ::std::option::Option::Some(Response_oneof_response::debug(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::debug(ResponseDebug::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::debug(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_debug(&mut self) -> ResponseDebug {
        if self.has_debug() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::debug(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseDebug::new()
        }
    }

    // optional uint32 id = 97;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // repeated string error = 98;


    pub fn get_error(&self) -> &[::std::string::String] {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.error = v;
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.error, ::protobuf::RepeatedField::new())
    }

    // optional .SC2APIProtocol.Status status = 99;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::launched)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        if let Some(Response_oneof_response::create_game(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::join_game(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::restart_game(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::start_replay(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::leave_game(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::quick_save(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::quick_load(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::quit(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::game_info(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::observation(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::action(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::obs_action(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::step(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::data(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::query(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::save_replay(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::replay_info(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::available_maps(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::save_map(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::map_command(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::ping(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::debug(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::create_game(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::join_game(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::restart_game(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::start_replay(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::leave_game(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::quick_save(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::quick_load(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::quit(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::game_info(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::observation(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::action(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::obs_action(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::step(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::data(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::query(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::save_replay(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::replay_info(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::available_maps(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::save_map(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::map_command(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::ping(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::debug(is.read_message()?));
                },
                97 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                98 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.error)?;
                },
                99 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 99, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(97, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.error {
            my_size += ::protobuf::rt::string_size(98, &value);
        };
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(99, v);
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &Response_oneof_response::create_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::join_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::restart_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::start_replay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::leave_game(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::quick_save(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::quick_load(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::quit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::game_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::observation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::action(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::obs_action(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::step(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::save_replay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::replay_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::available_maps(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::save_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::map_command(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::debug(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(97, v)?;
        }
        for v in &self.error {
            os.write_string(98, &v)?;
        };
        if let Some(v) = self.status {
            os.write_enum(99, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &Response_oneof_response::create_game(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::join_game(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::restart_game(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::start_replay(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::leave_game(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::quick_save(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::quick_load(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::quit(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::game_info(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::observation(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::action(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::obs_action(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::step(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::data(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::query(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::save_replay(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::replay_info(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::available_maps(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::save_map(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::map_command(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::ping(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::debug(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseCreateGame>(
                "create_game",
                Response::has_create_game,
                Response::get_create_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseJoinGame>(
                "join_game",
                Response::has_join_game,
                Response::get_join_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseRestartGame>(
                "restart_game",
                Response::has_restart_game,
                Response::get_restart_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseStartReplay>(
                "start_replay",
                Response::has_start_replay,
                Response::get_start_replay,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseLeaveGame>(
                "leave_game",
                Response::has_leave_game,
                Response::get_leave_game,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseQuickSave>(
                "quick_save",
                Response::has_quick_save,
                Response::get_quick_save,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseQuickLoad>(
                "quick_load",
                Response::has_quick_load,
                Response::get_quick_load,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseQuit>(
                "quit",
                Response::has_quit,
                Response::get_quit,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseGameInfo>(
                "game_info",
                Response::has_game_info,
                Response::get_game_info,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseObservation>(
                "observation",
                Response::has_observation,
                Response::get_observation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseAction>(
                "action",
                Response::has_action,
                Response::get_action,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseObserverAction>(
                "obs_action",
                Response::has_obs_action,
                Response::get_obs_action,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseStep>(
                "step",
                Response::has_step,
                Response::get_step,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseData>(
                "data",
                Response::has_data,
                Response::get_data,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::query::ResponseQuery>(
                "query",
                Response::has_query,
                Response::get_query,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseSaveReplay>(
                "save_replay",
                Response::has_save_replay,
                Response::get_save_replay,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseReplayInfo>(
                "replay_info",
                Response::has_replay_info,
                Response::get_replay_info,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseAvailableMaps>(
                "available_maps",
                Response::has_available_maps,
                Response::get_available_maps,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseSaveMap>(
                "save_map",
                Response::has_save_map,
                Response::get_save_map,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseMapCommand>(
                "map_command",
                Response::has_map_command,
                Response::get_map_command,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponsePing>(
                "ping",
                Response::has_ping,
                Response::get_ping,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResponseDebug>(
                "debug",
                Response::has_debug,
                Response::get_debug,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Response| { &m.id },
                |m: &mut Response| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &Response| { &m.error },
                |m: &mut Response| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &Response| { &m.status },
                |m: &mut Response| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response>(
                "Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response {
        static instance: ::protobuf::rt::LazyV2<Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response::new)
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.error.clear();
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestCreateGame {
    // message fields
    pub player_setup: ::protobuf::RepeatedField<PlayerSetup>,
    pub disable_fog: ::std::option::Option<bool>,
    pub random_seed: ::std::option::Option<u32>,
    pub realtime: ::std::option::Option<bool>,
    // message oneof groups
    pub Map: ::std::option::Option<RequestCreateGame_oneof_Map>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestCreateGame {
    fn default() -> &'a RequestCreateGame {
        <RequestCreateGame as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RequestCreateGame_oneof_Map {
    local_map(LocalMap),
    battlenet_map_name(::std::string::String),
}

impl RequestCreateGame {
    pub fn new() -> RequestCreateGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.LocalMap local_map = 1;


    pub fn get_local_map(&self) -> &LocalMap {
        match self.Map {
            ::std::option::Option::Some(RequestCreateGame_oneof_Map::local_map(ref v)) => v,
            _ => <LocalMap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_local_map(&mut self) {
        self.Map = ::std::option::Option::None;
    }

    pub fn has_local_map(&self) -> bool {
        match self.Map {
            ::std::option::Option::Some(RequestCreateGame_oneof_Map::local_map(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local_map(&mut self, v: LocalMap) {
        self.Map = ::std::option::Option::Some(RequestCreateGame_oneof_Map::local_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local_map(&mut self) -> &mut LocalMap {
        if let ::std::option::Option::Some(RequestCreateGame_oneof_Map::local_map(_)) = self.Map {
        } else {
            self.Map = ::std::option::Option::Some(RequestCreateGame_oneof_Map::local_map(LocalMap::new()));
        }
        match self.Map {
            ::std::option::Option::Some(RequestCreateGame_oneof_Map::local_map(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local_map(&mut self) -> LocalMap {
        if self.has_local_map() {
            match self.Map.take() {
                ::std::option::Option::Some(RequestCreateGame_oneof_Map::local_map(v)) => v,
                _ => panic!(),
            }
        } else {
            LocalMap::new()
        }
    }

    // optional string battlenet_map_name = 2;


    pub fn get_battlenet_map_name(&self) -> &str {
        match self.Map {
            ::std::option::Option::Some(RequestCreateGame_oneof_Map::battlenet_map_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_battlenet_map_name(&mut self) {
        self.Map = ::std::option::Option::None;
    }

    pub fn has_battlenet_map_name(&self) -> bool {
        match self.Map {
            ::std::option::Option::Some(RequestCreateGame_oneof_Map::battlenet_map_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_battlenet_map_name(&mut self, v: ::std::string::String) {
        self.Map = ::std::option::Option::Some(RequestCreateGame_oneof_Map::battlenet_map_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_battlenet_map_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RequestCreateGame_oneof_Map::battlenet_map_name(_)) = self.Map {
        } else {
            self.Map = ::std::option::Option::Some(RequestCreateGame_oneof_Map::battlenet_map_name(::std::string::String::new()));
        }
        match self.Map {
            ::std::option::Option::Some(RequestCreateGame_oneof_Map::battlenet_map_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_battlenet_map_name(&mut self) -> ::std::string::String {
        if self.has_battlenet_map_name() {
            match self.Map.take() {
                ::std::option::Option::Some(RequestCreateGame_oneof_Map::battlenet_map_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // repeated .SC2APIProtocol.PlayerSetup player_setup = 3;


    pub fn get_player_setup(&self) -> &[PlayerSetup] {
        &self.player_setup
    }
    pub fn clear_player_setup(&mut self) {
        self.player_setup.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_setup(&mut self, v: ::protobuf::RepeatedField<PlayerSetup>) {
        self.player_setup = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_setup(&mut self) -> &mut ::protobuf::RepeatedField<PlayerSetup> {
        &mut self.player_setup
    }

    // Take field
    pub fn take_player_setup(&mut self) -> ::protobuf::RepeatedField<PlayerSetup> {
        ::std::mem::replace(&mut self.player_setup, ::protobuf::RepeatedField::new())
    }

    // optional bool disable_fog = 4;


    pub fn get_disable_fog(&self) -> bool {
        self.disable_fog.unwrap_or(false)
    }
    pub fn clear_disable_fog(&mut self) {
        self.disable_fog = ::std::option::Option::None;
    }

    pub fn has_disable_fog(&self) -> bool {
        self.disable_fog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_fog(&mut self, v: bool) {
        self.disable_fog = ::std::option::Option::Some(v);
    }

    // optional uint32 random_seed = 5;


    pub fn get_random_seed(&self) -> u32 {
        self.random_seed.unwrap_or(0)
    }
    pub fn clear_random_seed(&mut self) {
        self.random_seed = ::std::option::Option::None;
    }

    pub fn has_random_seed(&self) -> bool {
        self.random_seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_seed(&mut self, v: u32) {
        self.random_seed = ::std::option::Option::Some(v);
    }

    // optional bool realtime = 6;


    pub fn get_realtime(&self) -> bool {
        self.realtime.unwrap_or(false)
    }
    pub fn clear_realtime(&mut self) {
        self.realtime = ::std::option::Option::None;
    }

    pub fn has_realtime(&self) -> bool {
        self.realtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realtime(&mut self, v: bool) {
        self.realtime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RequestCreateGame {
    fn is_initialized(&self) -> bool {
        if let Some(RequestCreateGame_oneof_Map::local_map(ref v)) = self.Map {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.player_setup {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Map = ::std::option::Option::Some(RequestCreateGame_oneof_Map::local_map(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Map = ::std::option::Option::Some(RequestCreateGame_oneof_Map::battlenet_map_name(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_setup)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_fog = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.random_seed = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.realtime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_setup {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.disable_fog {
            my_size += 2;
        }
        if let Some(v) = self.random_seed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.realtime {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.Map {
            match v {
                &RequestCreateGame_oneof_Map::local_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestCreateGame_oneof_Map::battlenet_map_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_setup {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.disable_fog {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.random_seed {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.realtime {
            os.write_bool(6, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.Map {
            match v {
                &RequestCreateGame_oneof_Map::local_map(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestCreateGame_oneof_Map::battlenet_map_name(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestCreateGame {
        RequestCreateGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LocalMap>(
                "local_map",
                RequestCreateGame::has_local_map,
                RequestCreateGame::get_local_map,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "battlenet_map_name",
                RequestCreateGame::has_battlenet_map_name,
                RequestCreateGame::get_battlenet_map_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerSetup>>(
                "player_setup",
                |m: &RequestCreateGame| { &m.player_setup },
                |m: &mut RequestCreateGame| { &mut m.player_setup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_fog",
                |m: &RequestCreateGame| { &m.disable_fog },
                |m: &mut RequestCreateGame| { &mut m.disable_fog },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "random_seed",
                |m: &RequestCreateGame| { &m.random_seed },
                |m: &mut RequestCreateGame| { &mut m.random_seed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "realtime",
                |m: &RequestCreateGame| { &m.realtime },
                |m: &mut RequestCreateGame| { &mut m.realtime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestCreateGame>(
                "RequestCreateGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestCreateGame {
        static instance: ::protobuf::rt::LazyV2<RequestCreateGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestCreateGame::new)
    }
}

impl ::protobuf::Clear for RequestCreateGame {
    fn clear(&mut self) {
        self.Map = ::std::option::Option::None;
        self.Map = ::std::option::Option::None;
        self.player_setup.clear();
        self.disable_fog = ::std::option::Option::None;
        self.random_seed = ::std::option::Option::None;
        self.realtime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestCreateGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestCreateGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalMap {
    // message fields
    pub map_path: ::protobuf::SingularField<::std::string::String>,
    pub map_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalMap {
    fn default() -> &'a LocalMap {
        <LocalMap as ::protobuf::Message>::default_instance()
    }
}

impl LocalMap {
    pub fn new() -> LocalMap {
        ::std::default::Default::default()
    }

    // optional string map_path = 1;


    pub fn get_map_path(&self) -> &str {
        match self.map_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map_path(&mut self) {
        self.map_path.clear();
    }

    pub fn has_map_path(&self) -> bool {
        self.map_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_path(&mut self, v: ::std::string::String) {
        self.map_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_path(&mut self) -> &mut ::std::string::String {
        if self.map_path.is_none() {
            self.map_path.set_default();
        }
        self.map_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_path(&mut self) -> ::std::string::String {
        self.map_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes map_data = 7;


    pub fn get_map_data(&self) -> &[u8] {
        match self.map_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_map_data(&mut self) {
        self.map_data.clear();
    }

    pub fn has_map_data(&self) -> bool {
        self.map_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.map_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.map_data.is_none() {
            self.map_data.set_default();
        }
        self.map_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_data(&mut self) -> ::std::vec::Vec<u8> {
        self.map_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for LocalMap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map_path)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.map_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.map_path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.map_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.map_path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.map_data.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalMap {
        LocalMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map_path",
                |m: &LocalMap| { &m.map_path },
                |m: &mut LocalMap| { &mut m.map_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "map_data",
                |m: &LocalMap| { &m.map_data },
                |m: &mut LocalMap| { &mut m.map_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocalMap>(
                "LocalMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocalMap {
        static instance: ::protobuf::rt::LazyV2<LocalMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocalMap::new)
    }
}

impl ::protobuf::Clear for LocalMap {
    fn clear(&mut self) {
        self.map_path.clear();
        self.map_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseCreateGame {
    // message fields
    pub error: ::std::option::Option<ResponseCreateGame_Error>,
    pub error_details: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseCreateGame {
    fn default() -> &'a ResponseCreateGame {
        <ResponseCreateGame as ::protobuf::Message>::default_instance()
    }
}

impl ResponseCreateGame {
    pub fn new() -> ResponseCreateGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseCreateGame.Error error = 1;


    pub fn get_error(&self) -> ResponseCreateGame_Error {
        self.error.unwrap_or(ResponseCreateGame_Error::MissingMap)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ResponseCreateGame_Error) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 2;


    pub fn get_error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_details(&mut self) {
        self.error_details.clear();
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details.set_default();
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResponseCreateGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_details.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseCreateGame {
        ResponseCreateGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseCreateGame_Error>>(
                "error",
                |m: &ResponseCreateGame| { &m.error },
                |m: &mut ResponseCreateGame| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_details",
                |m: &ResponseCreateGame| { &m.error_details },
                |m: &mut ResponseCreateGame| { &mut m.error_details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseCreateGame>(
                "ResponseCreateGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseCreateGame {
        static instance: ::protobuf::rt::LazyV2<ResponseCreateGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseCreateGame::new)
    }
}

impl ::protobuf::Clear for ResponseCreateGame {
    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseCreateGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseCreateGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseCreateGame_Error {
    MissingMap = 1,
    InvalidMapPath = 2,
    InvalidMapData = 3,
    InvalidMapName = 4,
    InvalidMapHandle = 5,
    MissingPlayerSetup = 6,
    InvalidPlayerSetup = 7,
    MultiplayerUnsupported = 8,
}

impl ::protobuf::ProtobufEnum for ResponseCreateGame_Error {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseCreateGame_Error> {
        match value {
            1 => ::std::option::Option::Some(ResponseCreateGame_Error::MissingMap),
            2 => ::std::option::Option::Some(ResponseCreateGame_Error::InvalidMapPath),
            3 => ::std::option::Option::Some(ResponseCreateGame_Error::InvalidMapData),
            4 => ::std::option::Option::Some(ResponseCreateGame_Error::InvalidMapName),
            5 => ::std::option::Option::Some(ResponseCreateGame_Error::InvalidMapHandle),
            6 => ::std::option::Option::Some(ResponseCreateGame_Error::MissingPlayerSetup),
            7 => ::std::option::Option::Some(ResponseCreateGame_Error::InvalidPlayerSetup),
            8 => ::std::option::Option::Some(ResponseCreateGame_Error::MultiplayerUnsupported),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseCreateGame_Error] = &[
            ResponseCreateGame_Error::MissingMap,
            ResponseCreateGame_Error::InvalidMapPath,
            ResponseCreateGame_Error::InvalidMapData,
            ResponseCreateGame_Error::InvalidMapName,
            ResponseCreateGame_Error::InvalidMapHandle,
            ResponseCreateGame_Error::MissingPlayerSetup,
            ResponseCreateGame_Error::InvalidPlayerSetup,
            ResponseCreateGame_Error::MultiplayerUnsupported,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseCreateGame_Error>("ResponseCreateGame.Error", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseCreateGame_Error {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ResponseCreateGame_Error {
    fn default() -> Self {
        ResponseCreateGame_Error::MissingMap
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseCreateGame_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestJoinGame {
    // message fields
    pub options: ::protobuf::SingularPtrField<InterfaceOptions>,
    pub server_ports: ::protobuf::SingularPtrField<PortSet>,
    pub client_ports: ::protobuf::RepeatedField<PortSet>,
    pub shared_port: ::std::option::Option<i32>,
    pub player_name: ::protobuf::SingularField<::std::string::String>,
    pub host_ip: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub participation: ::std::option::Option<RequestJoinGame_oneof_participation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestJoinGame {
    fn default() -> &'a RequestJoinGame {
        <RequestJoinGame as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RequestJoinGame_oneof_participation {
    race(super::common::Race),
    observed_player_id(u32),
}

impl RequestJoinGame {
    pub fn new() -> RequestJoinGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Race race = 1;


    pub fn get_race(&self) -> super::common::Race {
        match self.participation {
            ::std::option::Option::Some(RequestJoinGame_oneof_participation::race(v)) => v,
            _ => super::common::Race::NoRace,
        }
    }
    pub fn clear_race(&mut self) {
        self.participation = ::std::option::Option::None;
    }

    pub fn has_race(&self) -> bool {
        match self.participation {
            ::std::option::Option::Some(RequestJoinGame_oneof_participation::race(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_race(&mut self, v: super::common::Race) {
        self.participation = ::std::option::Option::Some(RequestJoinGame_oneof_participation::race(v))
    }

    // optional uint32 observed_player_id = 2;


    pub fn get_observed_player_id(&self) -> u32 {
        match self.participation {
            ::std::option::Option::Some(RequestJoinGame_oneof_participation::observed_player_id(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_observed_player_id(&mut self) {
        self.participation = ::std::option::Option::None;
    }

    pub fn has_observed_player_id(&self) -> bool {
        match self.participation {
            ::std::option::Option::Some(RequestJoinGame_oneof_participation::observed_player_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_observed_player_id(&mut self, v: u32) {
        self.participation = ::std::option::Option::Some(RequestJoinGame_oneof_participation::observed_player_id(v))
    }

    // optional .SC2APIProtocol.InterfaceOptions options = 3;


    pub fn get_options(&self) -> &InterfaceOptions {
        self.options.as_ref().unwrap_or_else(|| <InterfaceOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: InterfaceOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut InterfaceOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> InterfaceOptions {
        self.options.take().unwrap_or_else(|| InterfaceOptions::new())
    }

    // optional .SC2APIProtocol.PortSet server_ports = 4;


    pub fn get_server_ports(&self) -> &PortSet {
        self.server_ports.as_ref().unwrap_or_else(|| <PortSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_ports(&mut self) {
        self.server_ports.clear();
    }

    pub fn has_server_ports(&self) -> bool {
        self.server_ports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ports(&mut self, v: PortSet) {
        self.server_ports = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_ports(&mut self) -> &mut PortSet {
        if self.server_ports.is_none() {
            self.server_ports.set_default();
        }
        self.server_ports.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_ports(&mut self) -> PortSet {
        self.server_ports.take().unwrap_or_else(|| PortSet::new())
    }

    // repeated .SC2APIProtocol.PortSet client_ports = 5;


    pub fn get_client_ports(&self) -> &[PortSet] {
        &self.client_ports
    }
    pub fn clear_client_ports(&mut self) {
        self.client_ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_ports(&mut self, v: ::protobuf::RepeatedField<PortSet>) {
        self.client_ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_ports(&mut self) -> &mut ::protobuf::RepeatedField<PortSet> {
        &mut self.client_ports
    }

    // Take field
    pub fn take_client_ports(&mut self) -> ::protobuf::RepeatedField<PortSet> {
        ::std::mem::replace(&mut self.client_ports, ::protobuf::RepeatedField::new())
    }

    // optional int32 shared_port = 6;


    pub fn get_shared_port(&self) -> i32 {
        self.shared_port.unwrap_or(0)
    }
    pub fn clear_shared_port(&mut self) {
        self.shared_port = ::std::option::Option::None;
    }

    pub fn has_shared_port(&self) -> bool {
        self.shared_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_port(&mut self, v: i32) {
        self.shared_port = ::std::option::Option::Some(v);
    }

    // optional string player_name = 7;


    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host_ip = 8;


    pub fn get_host_ip(&self) -> &str {
        match self.host_ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host_ip(&mut self) {
        self.host_ip.clear();
    }

    pub fn has_host_ip(&self) -> bool {
        self.host_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_ip(&mut self, v: ::std::string::String) {
        self.host_ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_ip(&mut self) -> &mut ::std::string::String {
        if self.host_ip.is_none() {
            self.host_ip.set_default();
        }
        self.host_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_ip(&mut self) -> ::std::string::String {
        self.host_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RequestJoinGame {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_ports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.client_ports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.participation = ::std::option::Option::Some(RequestJoinGame_oneof_participation::race(is.read_enum()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.participation = ::std::option::Option::Some(RequestJoinGame_oneof_participation::observed_player_id(is.read_uint32()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_ports)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.client_ports)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shared_port = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.server_ports.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.client_ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.shared_port {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.host_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.participation {
            match v {
                &RequestJoinGame_oneof_participation::race(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
                &RequestJoinGame_oneof_participation::observed_player_id(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.server_ports.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.client_ports {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.shared_port {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.host_ip.as_ref() {
            os.write_string(8, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.participation {
            match v {
                &RequestJoinGame_oneof_participation::race(v) => {
                    os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &RequestJoinGame_oneof_participation::observed_player_id(v) => {
                    os.write_uint32(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestJoinGame {
        RequestJoinGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, super::common::Race>(
                "race",
                RequestJoinGame::has_race,
                RequestJoinGame::get_race,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "observed_player_id",
                RequestJoinGame::has_observed_player_id,
                RequestJoinGame::get_observed_player_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterfaceOptions>>(
                "options",
                |m: &RequestJoinGame| { &m.options },
                |m: &mut RequestJoinGame| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortSet>>(
                "server_ports",
                |m: &RequestJoinGame| { &m.server_ports },
                |m: &mut RequestJoinGame| { &mut m.server_ports },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortSet>>(
                "client_ports",
                |m: &RequestJoinGame| { &m.client_ports },
                |m: &mut RequestJoinGame| { &mut m.client_ports },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "shared_port",
                |m: &RequestJoinGame| { &m.shared_port },
                |m: &mut RequestJoinGame| { &mut m.shared_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "player_name",
                |m: &RequestJoinGame| { &m.player_name },
                |m: &mut RequestJoinGame| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_ip",
                |m: &RequestJoinGame| { &m.host_ip },
                |m: &mut RequestJoinGame| { &mut m.host_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestJoinGame>(
                "RequestJoinGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestJoinGame {
        static instance: ::protobuf::rt::LazyV2<RequestJoinGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestJoinGame::new)
    }
}

impl ::protobuf::Clear for RequestJoinGame {
    fn clear(&mut self) {
        self.participation = ::std::option::Option::None;
        self.participation = ::std::option::Option::None;
        self.options.clear();
        self.server_ports.clear();
        self.client_ports.clear();
        self.shared_port = ::std::option::Option::None;
        self.player_name.clear();
        self.host_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestJoinGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestJoinGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortSet {
    // message fields
    pub game_port: ::std::option::Option<i32>,
    pub base_port: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortSet {
    fn default() -> &'a PortSet {
        <PortSet as ::protobuf::Message>::default_instance()
    }
}

impl PortSet {
    pub fn new() -> PortSet {
        ::std::default::Default::default()
    }

    // optional int32 game_port = 1;


    pub fn get_game_port(&self) -> i32 {
        self.game_port.unwrap_or(0)
    }
    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: i32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional int32 base_port = 2;


    pub fn get_base_port(&self) -> i32 {
        self.base_port.unwrap_or(0)
    }
    pub fn clear_base_port(&mut self) {
        self.base_port = ::std::option::Option::None;
    }

    pub fn has_base_port(&self) -> bool {
        self.base_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_port(&mut self, v: i32) {
        self.base_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PortSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.base_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_port {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.base_port {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortSet {
        PortSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_port",
                |m: &PortSet| { &m.game_port },
                |m: &mut PortSet| { &mut m.game_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "base_port",
                |m: &PortSet| { &m.base_port },
                |m: &mut PortSet| { &mut m.base_port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortSet>(
                "PortSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortSet {
        static instance: ::protobuf::rt::LazyV2<PortSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortSet::new)
    }
}

impl ::protobuf::Clear for PortSet {
    fn clear(&mut self) {
        self.game_port = ::std::option::Option::None;
        self.base_port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseJoinGame {
    // message fields
    pub player_id: ::std::option::Option<u32>,
    pub error: ::std::option::Option<ResponseJoinGame_Error>,
    pub error_details: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseJoinGame {
    fn default() -> &'a ResponseJoinGame {
        <ResponseJoinGame as ::protobuf::Message>::default_instance()
    }
}

impl ResponseJoinGame {
    pub fn new() -> ResponseJoinGame {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;


    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.ResponseJoinGame.Error error = 2;


    pub fn get_error(&self) -> ResponseJoinGame_Error {
        self.error.unwrap_or(ResponseJoinGame_Error::MissingParticipation)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ResponseJoinGame_Error) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 3;


    pub fn get_error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_details(&mut self) {
        self.error_details.clear();
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details.set_default();
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResponseJoinGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_details.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseJoinGame {
        ResponseJoinGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_id",
                |m: &ResponseJoinGame| { &m.player_id },
                |m: &mut ResponseJoinGame| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseJoinGame_Error>>(
                "error",
                |m: &ResponseJoinGame| { &m.error },
                |m: &mut ResponseJoinGame| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_details",
                |m: &ResponseJoinGame| { &m.error_details },
                |m: &mut ResponseJoinGame| { &mut m.error_details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseJoinGame>(
                "ResponseJoinGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseJoinGame {
        static instance: ::protobuf::rt::LazyV2<ResponseJoinGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseJoinGame::new)
    }
}

impl ::protobuf::Clear for ResponseJoinGame {
    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.error_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseJoinGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseJoinGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseJoinGame_Error {
    MissingParticipation = 1,
    InvalidObservedPlayerId = 2,
    MissingOptions = 3,
    MissingPorts = 4,
    GameFull = 5,
    LaunchError = 6,
    FeatureUnsupported = 7,
    NoSpaceForUser = 8,
    MapDoesNotExist = 9,
    CannotOpenMap = 10,
    ChecksumError = 11,
    NetworkError = 12,
    OtherError = 13,
}

impl ::protobuf::ProtobufEnum for ResponseJoinGame_Error {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseJoinGame_Error> {
        match value {
            1 => ::std::option::Option::Some(ResponseJoinGame_Error::MissingParticipation),
            2 => ::std::option::Option::Some(ResponseJoinGame_Error::InvalidObservedPlayerId),
            3 => ::std::option::Option::Some(ResponseJoinGame_Error::MissingOptions),
            4 => ::std::option::Option::Some(ResponseJoinGame_Error::MissingPorts),
            5 => ::std::option::Option::Some(ResponseJoinGame_Error::GameFull),
            6 => ::std::option::Option::Some(ResponseJoinGame_Error::LaunchError),
            7 => ::std::option::Option::Some(ResponseJoinGame_Error::FeatureUnsupported),
            8 => ::std::option::Option::Some(ResponseJoinGame_Error::NoSpaceForUser),
            9 => ::std::option::Option::Some(ResponseJoinGame_Error::MapDoesNotExist),
            10 => ::std::option::Option::Some(ResponseJoinGame_Error::CannotOpenMap),
            11 => ::std::option::Option::Some(ResponseJoinGame_Error::ChecksumError),
            12 => ::std::option::Option::Some(ResponseJoinGame_Error::NetworkError),
            13 => ::std::option::Option::Some(ResponseJoinGame_Error::OtherError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseJoinGame_Error] = &[
            ResponseJoinGame_Error::MissingParticipation,
            ResponseJoinGame_Error::InvalidObservedPlayerId,
            ResponseJoinGame_Error::MissingOptions,
            ResponseJoinGame_Error::MissingPorts,
            ResponseJoinGame_Error::GameFull,
            ResponseJoinGame_Error::LaunchError,
            ResponseJoinGame_Error::FeatureUnsupported,
            ResponseJoinGame_Error::NoSpaceForUser,
            ResponseJoinGame_Error::MapDoesNotExist,
            ResponseJoinGame_Error::CannotOpenMap,
            ResponseJoinGame_Error::ChecksumError,
            ResponseJoinGame_Error::NetworkError,
            ResponseJoinGame_Error::OtherError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseJoinGame_Error>("ResponseJoinGame.Error", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseJoinGame_Error {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ResponseJoinGame_Error {
    fn default() -> Self {
        ResponseJoinGame_Error::MissingParticipation
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseJoinGame_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestRestartGame {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestRestartGame {
    fn default() -> &'a RequestRestartGame {
        <RequestRestartGame as ::protobuf::Message>::default_instance()
    }
}

impl RequestRestartGame {
    pub fn new() -> RequestRestartGame {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestRestartGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestRestartGame {
        RequestRestartGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestRestartGame>(
                "RequestRestartGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestRestartGame {
        static instance: ::protobuf::rt::LazyV2<RequestRestartGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestRestartGame::new)
    }
}

impl ::protobuf::Clear for RequestRestartGame {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestRestartGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestRestartGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseRestartGame {
    // message fields
    pub error: ::std::option::Option<ResponseRestartGame_Error>,
    pub error_details: ::protobuf::SingularField<::std::string::String>,
    pub need_hard_reset: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseRestartGame {
    fn default() -> &'a ResponseRestartGame {
        <ResponseRestartGame as ::protobuf::Message>::default_instance()
    }
}

impl ResponseRestartGame {
    pub fn new() -> ResponseRestartGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseRestartGame.Error error = 1;


    pub fn get_error(&self) -> ResponseRestartGame_Error {
        self.error.unwrap_or(ResponseRestartGame_Error::LaunchError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ResponseRestartGame_Error) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 2;


    pub fn get_error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_details(&mut self) {
        self.error_details.clear();
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details.set_default();
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool need_hard_reset = 3;


    pub fn get_need_hard_reset(&self) -> bool {
        self.need_hard_reset.unwrap_or(false)
    }
    pub fn clear_need_hard_reset(&mut self) {
        self.need_hard_reset = ::std::option::Option::None;
    }

    pub fn has_need_hard_reset(&self) -> bool {
        self.need_hard_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_hard_reset(&mut self, v: bool) {
        self.need_hard_reset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ResponseRestartGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_details)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.need_hard_reset = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.need_hard_reset {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_details.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.need_hard_reset {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseRestartGame {
        ResponseRestartGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseRestartGame_Error>>(
                "error",
                |m: &ResponseRestartGame| { &m.error },
                |m: &mut ResponseRestartGame| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_details",
                |m: &ResponseRestartGame| { &m.error_details },
                |m: &mut ResponseRestartGame| { &mut m.error_details },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "need_hard_reset",
                |m: &ResponseRestartGame| { &m.need_hard_reset },
                |m: &mut ResponseRestartGame| { &mut m.need_hard_reset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseRestartGame>(
                "ResponseRestartGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseRestartGame {
        static instance: ::protobuf::rt::LazyV2<ResponseRestartGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseRestartGame::new)
    }
}

impl ::protobuf::Clear for ResponseRestartGame {
    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error_details.clear();
        self.need_hard_reset = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseRestartGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseRestartGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseRestartGame_Error {
    LaunchError = 1,
}

impl ::protobuf::ProtobufEnum for ResponseRestartGame_Error {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseRestartGame_Error> {
        match value {
            1 => ::std::option::Option::Some(ResponseRestartGame_Error::LaunchError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseRestartGame_Error] = &[
            ResponseRestartGame_Error::LaunchError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseRestartGame_Error>("ResponseRestartGame.Error", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseRestartGame_Error {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ResponseRestartGame_Error {
    fn default() -> Self {
        ResponseRestartGame_Error::LaunchError
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseRestartGame_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestStartReplay {
    // message fields
    pub map_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub observed_player_id: ::std::option::Option<i32>,
    pub options: ::protobuf::SingularPtrField<InterfaceOptions>,
    pub disable_fog: ::std::option::Option<bool>,
    pub realtime: ::std::option::Option<bool>,
    pub record_replay: ::std::option::Option<bool>,
    // message oneof groups
    pub replay: ::std::option::Option<RequestStartReplay_oneof_replay>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestStartReplay {
    fn default() -> &'a RequestStartReplay {
        <RequestStartReplay as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RequestStartReplay_oneof_replay {
    replay_path(::std::string::String),
    replay_data(::std::vec::Vec<u8>),
}

impl RequestStartReplay {
    pub fn new() -> RequestStartReplay {
        ::std::default::Default::default()
    }

    // optional string replay_path = 1;


    pub fn get_replay_path(&self) -> &str {
        match self.replay {
            ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_path(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_replay_path(&mut self) {
        self.replay = ::std::option::Option::None;
    }

    pub fn has_replay_path(&self) -> bool {
        match self.replay {
            ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_path(&mut self, v: ::std::string::String) {
        self.replay = ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_path(_)) = self.replay {
        } else {
            self.replay = ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_path(::std::string::String::new()));
        }
        match self.replay {
            ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_path(&mut self) -> ::std::string::String {
        if self.has_replay_path() {
            match self.replay.take() {
                ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_path(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bytes replay_data = 5;


    pub fn get_replay_data(&self) -> &[u8] {
        match self.replay {
            ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_data(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_replay_data(&mut self) {
        self.replay = ::std::option::Option::None;
    }

    pub fn has_replay_data(&self) -> bool {
        match self.replay {
            ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.replay = ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_data(_)) = self.replay {
        } else {
            self.replay = ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_data(::std::vec::Vec::new()));
        }
        match self.replay {
            ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_data(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_replay_data() {
            match self.replay.take() {
                ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_data(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // optional bytes map_data = 6;


    pub fn get_map_data(&self) -> &[u8] {
        match self.map_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_map_data(&mut self) {
        self.map_data.clear();
    }

    pub fn has_map_data(&self) -> bool {
        self.map_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.map_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.map_data.is_none() {
            self.map_data.set_default();
        }
        self.map_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_data(&mut self) -> ::std::vec::Vec<u8> {
        self.map_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 observed_player_id = 2;


    pub fn get_observed_player_id(&self) -> i32 {
        self.observed_player_id.unwrap_or(0)
    }
    pub fn clear_observed_player_id(&mut self) {
        self.observed_player_id = ::std::option::Option::None;
    }

    pub fn has_observed_player_id(&self) -> bool {
        self.observed_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observed_player_id(&mut self, v: i32) {
        self.observed_player_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.InterfaceOptions options = 3;


    pub fn get_options(&self) -> &InterfaceOptions {
        self.options.as_ref().unwrap_or_else(|| <InterfaceOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: InterfaceOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut InterfaceOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> InterfaceOptions {
        self.options.take().unwrap_or_else(|| InterfaceOptions::new())
    }

    // optional bool disable_fog = 4;


    pub fn get_disable_fog(&self) -> bool {
        self.disable_fog.unwrap_or(false)
    }
    pub fn clear_disable_fog(&mut self) {
        self.disable_fog = ::std::option::Option::None;
    }

    pub fn has_disable_fog(&self) -> bool {
        self.disable_fog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_fog(&mut self, v: bool) {
        self.disable_fog = ::std::option::Option::Some(v);
    }

    // optional bool realtime = 7;


    pub fn get_realtime(&self) -> bool {
        self.realtime.unwrap_or(false)
    }
    pub fn clear_realtime(&mut self) {
        self.realtime = ::std::option::Option::None;
    }

    pub fn has_realtime(&self) -> bool {
        self.realtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realtime(&mut self, v: bool) {
        self.realtime = ::std::option::Option::Some(v);
    }

    // optional bool record_replay = 8;


    pub fn get_record_replay(&self) -> bool {
        self.record_replay.unwrap_or(false)
    }
    pub fn clear_record_replay(&mut self) {
        self.record_replay = ::std::option::Option::None;
    }

    pub fn has_record_replay(&self) -> bool {
        self.record_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record_replay(&mut self, v: bool) {
        self.record_replay = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RequestStartReplay {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.replay = ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_path(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.replay = ::std::option::Option::Some(RequestStartReplay_oneof_replay::replay_data(is.read_bytes()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.map_data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.observed_player_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_fog = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.realtime = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.record_replay = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.map_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.observed_player_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.disable_fog {
            my_size += 2;
        }
        if let Some(v) = self.realtime {
            my_size += 2;
        }
        if let Some(v) = self.record_replay {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.replay {
            match v {
                &RequestStartReplay_oneof_replay::replay_path(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &RequestStartReplay_oneof_replay::replay_data(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.map_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.observed_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.disable_fog {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.realtime {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.record_replay {
            os.write_bool(8, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.replay {
            match v {
                &RequestStartReplay_oneof_replay::replay_path(ref v) => {
                    os.write_string(1, v)?;
                },
                &RequestStartReplay_oneof_replay::replay_data(ref v) => {
                    os.write_bytes(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestStartReplay {
        RequestStartReplay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "replay_path",
                RequestStartReplay::has_replay_path,
                RequestStartReplay::get_replay_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "replay_data",
                RequestStartReplay::has_replay_data,
                RequestStartReplay::get_replay_data,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "map_data",
                |m: &RequestStartReplay| { &m.map_data },
                |m: &mut RequestStartReplay| { &mut m.map_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "observed_player_id",
                |m: &RequestStartReplay| { &m.observed_player_id },
                |m: &mut RequestStartReplay| { &mut m.observed_player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterfaceOptions>>(
                "options",
                |m: &RequestStartReplay| { &m.options },
                |m: &mut RequestStartReplay| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_fog",
                |m: &RequestStartReplay| { &m.disable_fog },
                |m: &mut RequestStartReplay| { &mut m.disable_fog },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "realtime",
                |m: &RequestStartReplay| { &m.realtime },
                |m: &mut RequestStartReplay| { &mut m.realtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "record_replay",
                |m: &RequestStartReplay| { &m.record_replay },
                |m: &mut RequestStartReplay| { &mut m.record_replay },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestStartReplay>(
                "RequestStartReplay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestStartReplay {
        static instance: ::protobuf::rt::LazyV2<RequestStartReplay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestStartReplay::new)
    }
}

impl ::protobuf::Clear for RequestStartReplay {
    fn clear(&mut self) {
        self.replay = ::std::option::Option::None;
        self.replay = ::std::option::Option::None;
        self.map_data.clear();
        self.observed_player_id = ::std::option::Option::None;
        self.options.clear();
        self.disable_fog = ::std::option::Option::None;
        self.realtime = ::std::option::Option::None;
        self.record_replay = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestStartReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestStartReplay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseStartReplay {
    // message fields
    pub error: ::std::option::Option<ResponseStartReplay_Error>,
    pub error_details: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseStartReplay {
    fn default() -> &'a ResponseStartReplay {
        <ResponseStartReplay as ::protobuf::Message>::default_instance()
    }
}

impl ResponseStartReplay {
    pub fn new() -> ResponseStartReplay {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseStartReplay.Error error = 1;


    pub fn get_error(&self) -> ResponseStartReplay_Error {
        self.error.unwrap_or(ResponseStartReplay_Error::MissingReplay)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ResponseStartReplay_Error) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 2;


    pub fn get_error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_details(&mut self) {
        self.error_details.clear();
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details.set_default();
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResponseStartReplay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_details.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseStartReplay {
        ResponseStartReplay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseStartReplay_Error>>(
                "error",
                |m: &ResponseStartReplay| { &m.error },
                |m: &mut ResponseStartReplay| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_details",
                |m: &ResponseStartReplay| { &m.error_details },
                |m: &mut ResponseStartReplay| { &mut m.error_details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseStartReplay>(
                "ResponseStartReplay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseStartReplay {
        static instance: ::protobuf::rt::LazyV2<ResponseStartReplay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseStartReplay::new)
    }
}

impl ::protobuf::Clear for ResponseStartReplay {
    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseStartReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseStartReplay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseStartReplay_Error {
    MissingReplay = 1,
    InvalidReplayPath = 2,
    InvalidReplayData = 3,
    InvalidMapData = 4,
    InvalidObservedPlayerId = 5,
    MissingOptions = 6,
    LaunchError = 7,
}

impl ::protobuf::ProtobufEnum for ResponseStartReplay_Error {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseStartReplay_Error> {
        match value {
            1 => ::std::option::Option::Some(ResponseStartReplay_Error::MissingReplay),
            2 => ::std::option::Option::Some(ResponseStartReplay_Error::InvalidReplayPath),
            3 => ::std::option::Option::Some(ResponseStartReplay_Error::InvalidReplayData),
            4 => ::std::option::Option::Some(ResponseStartReplay_Error::InvalidMapData),
            5 => ::std::option::Option::Some(ResponseStartReplay_Error::InvalidObservedPlayerId),
            6 => ::std::option::Option::Some(ResponseStartReplay_Error::MissingOptions),
            7 => ::std::option::Option::Some(ResponseStartReplay_Error::LaunchError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseStartReplay_Error] = &[
            ResponseStartReplay_Error::MissingReplay,
            ResponseStartReplay_Error::InvalidReplayPath,
            ResponseStartReplay_Error::InvalidReplayData,
            ResponseStartReplay_Error::InvalidMapData,
            ResponseStartReplay_Error::InvalidObservedPlayerId,
            ResponseStartReplay_Error::MissingOptions,
            ResponseStartReplay_Error::LaunchError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseStartReplay_Error>("ResponseStartReplay.Error", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseStartReplay_Error {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ResponseStartReplay_Error {
    fn default() -> Self {
        ResponseStartReplay_Error::MissingReplay
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseStartReplay_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestMapCommand {
    // message fields
    pub trigger_cmd: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestMapCommand {
    fn default() -> &'a RequestMapCommand {
        <RequestMapCommand as ::protobuf::Message>::default_instance()
    }
}

impl RequestMapCommand {
    pub fn new() -> RequestMapCommand {
        ::std::default::Default::default()
    }

    // optional string trigger_cmd = 1;


    pub fn get_trigger_cmd(&self) -> &str {
        match self.trigger_cmd.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_trigger_cmd(&mut self) {
        self.trigger_cmd.clear();
    }

    pub fn has_trigger_cmd(&self) -> bool {
        self.trigger_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trigger_cmd(&mut self, v: ::std::string::String) {
        self.trigger_cmd = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_cmd(&mut self) -> &mut ::std::string::String {
        if self.trigger_cmd.is_none() {
            self.trigger_cmd.set_default();
        }
        self.trigger_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_trigger_cmd(&mut self) -> ::std::string::String {
        self.trigger_cmd.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RequestMapCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.trigger_cmd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trigger_cmd.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trigger_cmd.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestMapCommand {
        RequestMapCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trigger_cmd",
                |m: &RequestMapCommand| { &m.trigger_cmd },
                |m: &mut RequestMapCommand| { &mut m.trigger_cmd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestMapCommand>(
                "RequestMapCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestMapCommand {
        static instance: ::protobuf::rt::LazyV2<RequestMapCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestMapCommand::new)
    }
}

impl ::protobuf::Clear for RequestMapCommand {
    fn clear(&mut self) {
        self.trigger_cmd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestMapCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestMapCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseMapCommand {
    // message fields
    pub error: ::std::option::Option<ResponseMapCommand_Error>,
    pub error_details: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseMapCommand {
    fn default() -> &'a ResponseMapCommand {
        <ResponseMapCommand as ::protobuf::Message>::default_instance()
    }
}

impl ResponseMapCommand {
    pub fn new() -> ResponseMapCommand {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseMapCommand.Error error = 1;


    pub fn get_error(&self) -> ResponseMapCommand_Error {
        self.error.unwrap_or(ResponseMapCommand_Error::NoTriggerError)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ResponseMapCommand_Error) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 2;


    pub fn get_error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_details(&mut self) {
        self.error_details.clear();
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details.set_default();
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResponseMapCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_details.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseMapCommand {
        ResponseMapCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseMapCommand_Error>>(
                "error",
                |m: &ResponseMapCommand| { &m.error },
                |m: &mut ResponseMapCommand| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_details",
                |m: &ResponseMapCommand| { &m.error_details },
                |m: &mut ResponseMapCommand| { &mut m.error_details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseMapCommand>(
                "ResponseMapCommand",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseMapCommand {
        static instance: ::protobuf::rt::LazyV2<ResponseMapCommand> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseMapCommand::new)
    }
}

impl ::protobuf::Clear for ResponseMapCommand {
    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseMapCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseMapCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseMapCommand_Error {
    NoTriggerError = 1,
}

impl ::protobuf::ProtobufEnum for ResponseMapCommand_Error {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseMapCommand_Error> {
        match value {
            1 => ::std::option::Option::Some(ResponseMapCommand_Error::NoTriggerError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseMapCommand_Error] = &[
            ResponseMapCommand_Error::NoTriggerError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseMapCommand_Error>("ResponseMapCommand.Error", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseMapCommand_Error {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ResponseMapCommand_Error {
    fn default() -> Self {
        ResponseMapCommand_Error::NoTriggerError
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseMapCommand_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestLeaveGame {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestLeaveGame {
    fn default() -> &'a RequestLeaveGame {
        <RequestLeaveGame as ::protobuf::Message>::default_instance()
    }
}

impl RequestLeaveGame {
    pub fn new() -> RequestLeaveGame {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestLeaveGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestLeaveGame {
        RequestLeaveGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestLeaveGame>(
                "RequestLeaveGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestLeaveGame {
        static instance: ::protobuf::rt::LazyV2<RequestLeaveGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestLeaveGame::new)
    }
}

impl ::protobuf::Clear for RequestLeaveGame {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestLeaveGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestLeaveGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseLeaveGame {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseLeaveGame {
    fn default() -> &'a ResponseLeaveGame {
        <ResponseLeaveGame as ::protobuf::Message>::default_instance()
    }
}

impl ResponseLeaveGame {
    pub fn new() -> ResponseLeaveGame {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseLeaveGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseLeaveGame {
        ResponseLeaveGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseLeaveGame>(
                "ResponseLeaveGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseLeaveGame {
        static instance: ::protobuf::rt::LazyV2<ResponseLeaveGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseLeaveGame::new)
    }
}

impl ::protobuf::Clear for ResponseLeaveGame {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseLeaveGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseLeaveGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestQuickSave {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestQuickSave {
    fn default() -> &'a RequestQuickSave {
        <RequestQuickSave as ::protobuf::Message>::default_instance()
    }
}

impl RequestQuickSave {
    pub fn new() -> RequestQuickSave {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestQuickSave {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestQuickSave {
        RequestQuickSave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestQuickSave>(
                "RequestQuickSave",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestQuickSave {
        static instance: ::protobuf::rt::LazyV2<RequestQuickSave> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestQuickSave::new)
    }
}

impl ::protobuf::Clear for RequestQuickSave {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestQuickSave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQuickSave {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseQuickSave {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseQuickSave {
    fn default() -> &'a ResponseQuickSave {
        <ResponseQuickSave as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQuickSave {
    pub fn new() -> ResponseQuickSave {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseQuickSave {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseQuickSave {
        ResponseQuickSave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseQuickSave>(
                "ResponseQuickSave",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseQuickSave {
        static instance: ::protobuf::rt::LazyV2<ResponseQuickSave> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseQuickSave::new)
    }
}

impl ::protobuf::Clear for ResponseQuickSave {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseQuickSave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQuickSave {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestQuickLoad {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestQuickLoad {
    fn default() -> &'a RequestQuickLoad {
        <RequestQuickLoad as ::protobuf::Message>::default_instance()
    }
}

impl RequestQuickLoad {
    pub fn new() -> RequestQuickLoad {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestQuickLoad {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestQuickLoad {
        RequestQuickLoad::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestQuickLoad>(
                "RequestQuickLoad",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestQuickLoad {
        static instance: ::protobuf::rt::LazyV2<RequestQuickLoad> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestQuickLoad::new)
    }
}

impl ::protobuf::Clear for RequestQuickLoad {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestQuickLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQuickLoad {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseQuickLoad {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseQuickLoad {
    fn default() -> &'a ResponseQuickLoad {
        <ResponseQuickLoad as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQuickLoad {
    pub fn new() -> ResponseQuickLoad {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseQuickLoad {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseQuickLoad {
        ResponseQuickLoad::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseQuickLoad>(
                "ResponseQuickLoad",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseQuickLoad {
        static instance: ::protobuf::rt::LazyV2<ResponseQuickLoad> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseQuickLoad::new)
    }
}

impl ::protobuf::Clear for ResponseQuickLoad {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseQuickLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQuickLoad {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestQuit {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestQuit {
    fn default() -> &'a RequestQuit {
        <RequestQuit as ::protobuf::Message>::default_instance()
    }
}

impl RequestQuit {
    pub fn new() -> RequestQuit {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestQuit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestQuit {
        RequestQuit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestQuit>(
                "RequestQuit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestQuit {
        static instance: ::protobuf::rt::LazyV2<RequestQuit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestQuit::new)
    }
}

impl ::protobuf::Clear for RequestQuit {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestQuit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQuit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseQuit {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseQuit {
    fn default() -> &'a ResponseQuit {
        <ResponseQuit as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQuit {
    pub fn new() -> ResponseQuit {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseQuit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseQuit {
        ResponseQuit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseQuit>(
                "ResponseQuit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseQuit {
        static instance: ::protobuf::rt::LazyV2<ResponseQuit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseQuit::new)
    }
}

impl ::protobuf::Clear for ResponseQuit {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseQuit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQuit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestGameInfo {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestGameInfo {
    fn default() -> &'a RequestGameInfo {
        <RequestGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl RequestGameInfo {
    pub fn new() -> RequestGameInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestGameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestGameInfo {
        RequestGameInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestGameInfo>(
                "RequestGameInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestGameInfo {
        static instance: ::protobuf::rt::LazyV2<RequestGameInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestGameInfo::new)
    }
}

impl ::protobuf::Clear for RequestGameInfo {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestGameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseGameInfo {
    // message fields
    pub map_name: ::protobuf::SingularField<::std::string::String>,
    pub mod_names: ::protobuf::RepeatedField<::std::string::String>,
    pub local_map_path: ::protobuf::SingularField<::std::string::String>,
    pub player_info: ::protobuf::RepeatedField<PlayerInfo>,
    pub start_raw: ::protobuf::SingularPtrField<super::raw::StartRaw>,
    pub options: ::protobuf::SingularPtrField<InterfaceOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseGameInfo {
    fn default() -> &'a ResponseGameInfo {
        <ResponseGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl ResponseGameInfo {
    pub fn new() -> ResponseGameInfo {
        ::std::default::Default::default()
    }

    // optional string map_name = 1;


    pub fn get_map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string mod_names = 6;


    pub fn get_mod_names(&self) -> &[::std::string::String] {
        &self.mod_names
    }
    pub fn clear_mod_names(&mut self) {
        self.mod_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_mod_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mod_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mod_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mod_names
    }

    // Take field
    pub fn take_mod_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mod_names, ::protobuf::RepeatedField::new())
    }

    // optional string local_map_path = 2;


    pub fn get_local_map_path(&self) -> &str {
        match self.local_map_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_local_map_path(&mut self) {
        self.local_map_path.clear();
    }

    pub fn has_local_map_path(&self) -> bool {
        self.local_map_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_map_path(&mut self, v: ::std::string::String) {
        self.local_map_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_map_path(&mut self) -> &mut ::std::string::String {
        if self.local_map_path.is_none() {
            self.local_map_path.set_default();
        }
        self.local_map_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_map_path(&mut self) -> ::std::string::String {
        self.local_map_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .SC2APIProtocol.PlayerInfo player_info = 3;


    pub fn get_player_info(&self) -> &[PlayerInfo] {
        &self.player_info
    }
    pub fn clear_player_info(&mut self) {
        self.player_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_info(&mut self, v: ::protobuf::RepeatedField<PlayerInfo>) {
        self.player_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_info(&mut self) -> &mut ::protobuf::RepeatedField<PlayerInfo> {
        &mut self.player_info
    }

    // Take field
    pub fn take_player_info(&mut self) -> ::protobuf::RepeatedField<PlayerInfo> {
        ::std::mem::replace(&mut self.player_info, ::protobuf::RepeatedField::new())
    }

    // optional .SC2APIProtocol.StartRaw start_raw = 4;


    pub fn get_start_raw(&self) -> &super::raw::StartRaw {
        self.start_raw.as_ref().unwrap_or_else(|| <super::raw::StartRaw as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_raw(&mut self) {
        self.start_raw.clear();
    }

    pub fn has_start_raw(&self) -> bool {
        self.start_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_raw(&mut self, v: super::raw::StartRaw) {
        self.start_raw = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_raw(&mut self) -> &mut super::raw::StartRaw {
        if self.start_raw.is_none() {
            self.start_raw.set_default();
        }
        self.start_raw.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_raw(&mut self) -> super::raw::StartRaw {
        self.start_raw.take().unwrap_or_else(|| super::raw::StartRaw::new())
    }

    // optional .SC2APIProtocol.InterfaceOptions options = 5;


    pub fn get_options(&self) -> &InterfaceOptions {
        self.options.as_ref().unwrap_or_else(|| <InterfaceOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: InterfaceOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut InterfaceOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> InterfaceOptions {
        self.options.take().unwrap_or_else(|| InterfaceOptions::new())
    }
}

impl ::protobuf::Message for ResponseGameInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.player_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_raw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map_name)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mod_names)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.local_map_path)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_info)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_raw)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.mod_names {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(ref v) = self.local_map_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.player_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.start_raw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.map_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.mod_names {
            os.write_string(6, &v)?;
        };
        if let Some(ref v) = self.local_map_path.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.player_info {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.start_raw.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseGameInfo {
        ResponseGameInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map_name",
                |m: &ResponseGameInfo| { &m.map_name },
                |m: &mut ResponseGameInfo| { &mut m.map_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mod_names",
                |m: &ResponseGameInfo| { &m.mod_names },
                |m: &mut ResponseGameInfo| { &mut m.mod_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_map_path",
                |m: &ResponseGameInfo| { &m.local_map_path },
                |m: &mut ResponseGameInfo| { &mut m.local_map_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerInfo>>(
                "player_info",
                |m: &ResponseGameInfo| { &m.player_info },
                |m: &mut ResponseGameInfo| { &mut m.player_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::raw::StartRaw>>(
                "start_raw",
                |m: &ResponseGameInfo| { &m.start_raw },
                |m: &mut ResponseGameInfo| { &mut m.start_raw },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterfaceOptions>>(
                "options",
                |m: &ResponseGameInfo| { &m.options },
                |m: &mut ResponseGameInfo| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseGameInfo>(
                "ResponseGameInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseGameInfo {
        static instance: ::protobuf::rt::LazyV2<ResponseGameInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseGameInfo::new)
    }
}

impl ::protobuf::Clear for ResponseGameInfo {
    fn clear(&mut self) {
        self.map_name.clear();
        self.mod_names.clear();
        self.local_map_path.clear();
        self.player_info.clear();
        self.start_raw.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseGameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestObservation {
    // message fields
    pub disable_fog: ::std::option::Option<bool>,
    pub game_loop: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestObservation {
    fn default() -> &'a RequestObservation {
        <RequestObservation as ::protobuf::Message>::default_instance()
    }
}

impl RequestObservation {
    pub fn new() -> RequestObservation {
        ::std::default::Default::default()
    }

    // optional bool disable_fog = 1;


    pub fn get_disable_fog(&self) -> bool {
        self.disable_fog.unwrap_or(false)
    }
    pub fn clear_disable_fog(&mut self) {
        self.disable_fog = ::std::option::Option::None;
    }

    pub fn has_disable_fog(&self) -> bool {
        self.disable_fog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_fog(&mut self, v: bool) {
        self.disable_fog = ::std::option::Option::Some(v);
    }

    // optional uint32 game_loop = 2;


    pub fn get_game_loop(&self) -> u32 {
        self.game_loop.unwrap_or(0)
    }
    pub fn clear_game_loop(&mut self) {
        self.game_loop = ::std::option::Option::None;
    }

    pub fn has_game_loop(&self) -> bool {
        self.game_loop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_loop(&mut self, v: u32) {
        self.game_loop = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RequestObservation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_fog = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_loop = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.disable_fog {
            my_size += 2;
        }
        if let Some(v) = self.game_loop {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.disable_fog {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_loop {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestObservation {
        RequestObservation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_fog",
                |m: &RequestObservation| { &m.disable_fog },
                |m: &mut RequestObservation| { &mut m.disable_fog },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_loop",
                |m: &RequestObservation| { &m.game_loop },
                |m: &mut RequestObservation| { &mut m.game_loop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestObservation>(
                "RequestObservation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestObservation {
        static instance: ::protobuf::rt::LazyV2<RequestObservation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestObservation::new)
    }
}

impl ::protobuf::Clear for RequestObservation {
    fn clear(&mut self) {
        self.disable_fog = ::std::option::Option::None;
        self.game_loop = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestObservation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestObservation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseObservation {
    // message fields
    pub actions: ::protobuf::RepeatedField<Action>,
    pub action_errors: ::protobuf::RepeatedField<ActionError>,
    pub observation: ::protobuf::SingularPtrField<Observation>,
    pub player_result: ::protobuf::RepeatedField<PlayerResult>,
    pub chat: ::protobuf::RepeatedField<ChatReceived>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseObservation {
    fn default() -> &'a ResponseObservation {
        <ResponseObservation as ::protobuf::Message>::default_instance()
    }
}

impl ResponseObservation {
    pub fn new() -> ResponseObservation {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.Action actions = 1;


    pub fn get_actions(&self) -> &[Action] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<Action>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<Action> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<Action> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.ActionError action_errors = 2;


    pub fn get_action_errors(&self) -> &[ActionError] {
        &self.action_errors
    }
    pub fn clear_action_errors(&mut self) {
        self.action_errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_action_errors(&mut self, v: ::protobuf::RepeatedField<ActionError>) {
        self.action_errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_action_errors(&mut self) -> &mut ::protobuf::RepeatedField<ActionError> {
        &mut self.action_errors
    }

    // Take field
    pub fn take_action_errors(&mut self) -> ::protobuf::RepeatedField<ActionError> {
        ::std::mem::replace(&mut self.action_errors, ::protobuf::RepeatedField::new())
    }

    // optional .SC2APIProtocol.Observation observation = 3;


    pub fn get_observation(&self) -> &Observation {
        self.observation.as_ref().unwrap_or_else(|| <Observation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_observation(&mut self) {
        self.observation.clear();
    }

    pub fn has_observation(&self) -> bool {
        self.observation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observation(&mut self, v: Observation) {
        self.observation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_observation(&mut self) -> &mut Observation {
        if self.observation.is_none() {
            self.observation.set_default();
        }
        self.observation.as_mut().unwrap()
    }

    // Take field
    pub fn take_observation(&mut self) -> Observation {
        self.observation.take().unwrap_or_else(|| Observation::new())
    }

    // repeated .SC2APIProtocol.PlayerResult player_result = 4;


    pub fn get_player_result(&self) -> &[PlayerResult] {
        &self.player_result
    }
    pub fn clear_player_result(&mut self) {
        self.player_result.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_result(&mut self, v: ::protobuf::RepeatedField<PlayerResult>) {
        self.player_result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_result(&mut self) -> &mut ::protobuf::RepeatedField<PlayerResult> {
        &mut self.player_result
    }

    // Take field
    pub fn take_player_result(&mut self) -> ::protobuf::RepeatedField<PlayerResult> {
        ::std::mem::replace(&mut self.player_result, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.ChatReceived chat = 5;


    pub fn get_chat(&self) -> &[ChatReceived] {
        &self.chat
    }
    pub fn clear_chat(&mut self) {
        self.chat.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: ::protobuf::RepeatedField<ChatReceived>) {
        self.chat = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat(&mut self) -> &mut ::protobuf::RepeatedField<ChatReceived> {
        &mut self.chat
    }

    // Take field
    pub fn take_chat(&mut self) -> ::protobuf::RepeatedField<ChatReceived> {
        ::std::mem::replace(&mut self.chat, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResponseObservation {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_errors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.observation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.action_errors)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.observation)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_result)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.action_errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.observation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.player_result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.chat {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.action_errors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.observation.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.player_result {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.chat {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseObservation {
        ResponseObservation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                "actions",
                |m: &ResponseObservation| { &m.actions },
                |m: &mut ResponseObservation| { &mut m.actions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActionError>>(
                "action_errors",
                |m: &ResponseObservation| { &m.action_errors },
                |m: &mut ResponseObservation| { &mut m.action_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Observation>>(
                "observation",
                |m: &ResponseObservation| { &m.observation },
                |m: &mut ResponseObservation| { &mut m.observation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerResult>>(
                "player_result",
                |m: &ResponseObservation| { &m.player_result },
                |m: &mut ResponseObservation| { &mut m.player_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChatReceived>>(
                "chat",
                |m: &ResponseObservation| { &m.chat },
                |m: &mut ResponseObservation| { &mut m.chat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseObservation>(
                "ResponseObservation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseObservation {
        static instance: ::protobuf::rt::LazyV2<ResponseObservation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseObservation::new)
    }
}

impl ::protobuf::Clear for ResponseObservation {
    fn clear(&mut self) {
        self.actions.clear();
        self.action_errors.clear();
        self.observation.clear();
        self.player_result.clear();
        self.chat.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseObservation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseObservation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChatReceived {
    // message fields
    pub player_id: ::std::option::Option<u32>,
    pub message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChatReceived {
    fn default() -> &'a ChatReceived {
        <ChatReceived as ::protobuf::Message>::default_instance()
    }
}

impl ChatReceived {
    pub fn new() -> ChatReceived {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;


    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChatReceived {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChatReceived {
        ChatReceived::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_id",
                |m: &ChatReceived| { &m.player_id },
                |m: &mut ChatReceived| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ChatReceived| { &m.message },
                |m: &mut ChatReceived| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChatReceived>(
                "ChatReceived",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChatReceived {
        static instance: ::protobuf::rt::LazyV2<ChatReceived> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChatReceived::new)
    }
}

impl ::protobuf::Clear for ChatReceived {
    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChatReceived {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatReceived {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestAction {
    // message fields
    pub actions: ::protobuf::RepeatedField<Action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestAction {
    fn default() -> &'a RequestAction {
        <RequestAction as ::protobuf::Message>::default_instance()
    }
}

impl RequestAction {
    pub fn new() -> RequestAction {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.Action actions = 1;


    pub fn get_actions(&self) -> &[Action] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<Action>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<Action> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<Action> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RequestAction {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestAction {
        RequestAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Action>>(
                "actions",
                |m: &RequestAction| { &m.actions },
                |m: &mut RequestAction| { &mut m.actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestAction>(
                "RequestAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestAction {
        static instance: ::protobuf::rt::LazyV2<RequestAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestAction::new)
    }
}

impl ::protobuf::Clear for RequestAction {
    fn clear(&mut self) {
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseAction {
    // message fields
    pub result: ::std::vec::Vec<super::error::ActionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseAction {
    fn default() -> &'a ResponseAction {
        <ResponseAction as ::protobuf::Message>::default_instance()
    }
}

impl ResponseAction {
    pub fn new() -> ResponseAction {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.ActionResult result = 1;


    pub fn get_result(&self) -> &[super::error::ActionResult] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::std::vec::Vec<super::error::ActionResult>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::std::vec::Vec<super::error::ActionResult> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::std::vec::Vec<super::error::ActionResult> {
        ::std::mem::replace(&mut self.result, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ResponseAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.result {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.result {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseAction {
        ResponseAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::error::ActionResult>>(
                "result",
                |m: &ResponseAction| { &m.result },
                |m: &mut ResponseAction| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseAction>(
                "ResponseAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseAction {
        static instance: ::protobuf::rt::LazyV2<ResponseAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseAction::new)
    }
}

impl ::protobuf::Clear for ResponseAction {
    fn clear(&mut self) {
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestObserverAction {
    // message fields
    pub actions: ::protobuf::RepeatedField<ObserverAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestObserverAction {
    fn default() -> &'a RequestObserverAction {
        <RequestObserverAction as ::protobuf::Message>::default_instance()
    }
}

impl RequestObserverAction {
    pub fn new() -> RequestObserverAction {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.ObserverAction actions = 1;


    pub fn get_actions(&self) -> &[ObserverAction] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<ObserverAction>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<ObserverAction> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<ObserverAction> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RequestObserverAction {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestObserverAction {
        RequestObserverAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObserverAction>>(
                "actions",
                |m: &RequestObserverAction| { &m.actions },
                |m: &mut RequestObserverAction| { &mut m.actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestObserverAction>(
                "RequestObserverAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestObserverAction {
        static instance: ::protobuf::rt::LazyV2<RequestObserverAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestObserverAction::new)
    }
}

impl ::protobuf::Clear for RequestObserverAction {
    fn clear(&mut self) {
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestObserverAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestObserverAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseObserverAction {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseObserverAction {
    fn default() -> &'a ResponseObserverAction {
        <ResponseObserverAction as ::protobuf::Message>::default_instance()
    }
}

impl ResponseObserverAction {
    pub fn new() -> ResponseObserverAction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseObserverAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseObserverAction {
        ResponseObserverAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseObserverAction>(
                "ResponseObserverAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseObserverAction {
        static instance: ::protobuf::rt::LazyV2<ResponseObserverAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseObserverAction::new)
    }
}

impl ::protobuf::Clear for ResponseObserverAction {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseObserverAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseObserverAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestStep {
    // message fields
    pub count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestStep {
    fn default() -> &'a RequestStep {
        <RequestStep as ::protobuf::Message>::default_instance()
    }
}

impl RequestStep {
    pub fn new() -> RequestStep {
        ::std::default::Default::default()
    }

    // optional uint32 count = 1;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RequestStep {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestStep {
        RequestStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &RequestStep| { &m.count },
                |m: &mut RequestStep| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestStep>(
                "RequestStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestStep {
        static instance: ::protobuf::rt::LazyV2<RequestStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestStep::new)
    }
}

impl ::protobuf::Clear for RequestStep {
    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseStep {
    // message fields
    pub simulation_loop: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseStep {
    fn default() -> &'a ResponseStep {
        <ResponseStep as ::protobuf::Message>::default_instance()
    }
}

impl ResponseStep {
    pub fn new() -> ResponseStep {
        ::std::default::Default::default()
    }

    // optional uint32 simulation_loop = 1;


    pub fn get_simulation_loop(&self) -> u32 {
        self.simulation_loop.unwrap_or(0)
    }
    pub fn clear_simulation_loop(&mut self) {
        self.simulation_loop = ::std::option::Option::None;
    }

    pub fn has_simulation_loop(&self) -> bool {
        self.simulation_loop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_simulation_loop(&mut self, v: u32) {
        self.simulation_loop = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ResponseStep {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.simulation_loop = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.simulation_loop {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.simulation_loop {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseStep {
        ResponseStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "simulation_loop",
                |m: &ResponseStep| { &m.simulation_loop },
                |m: &mut ResponseStep| { &mut m.simulation_loop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseStep>(
                "ResponseStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseStep {
        static instance: ::protobuf::rt::LazyV2<ResponseStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseStep::new)
    }
}

impl ::protobuf::Clear for ResponseStep {
    fn clear(&mut self) {
        self.simulation_loop = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestData {
    // message fields
    pub ability_id: ::std::option::Option<bool>,
    pub unit_type_id: ::std::option::Option<bool>,
    pub upgrade_id: ::std::option::Option<bool>,
    pub buff_id: ::std::option::Option<bool>,
    pub effect_id: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestData {
    fn default() -> &'a RequestData {
        <RequestData as ::protobuf::Message>::default_instance()
    }
}

impl RequestData {
    pub fn new() -> RequestData {
        ::std::default::Default::default()
    }

    // optional bool ability_id = 1;


    pub fn get_ability_id(&self) -> bool {
        self.ability_id.unwrap_or(false)
    }
    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: bool) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional bool unit_type_id = 2;


    pub fn get_unit_type_id(&self) -> bool {
        self.unit_type_id.unwrap_or(false)
    }
    pub fn clear_unit_type_id(&mut self) {
        self.unit_type_id = ::std::option::Option::None;
    }

    pub fn has_unit_type_id(&self) -> bool {
        self.unit_type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type_id(&mut self, v: bool) {
        self.unit_type_id = ::std::option::Option::Some(v);
    }

    // optional bool upgrade_id = 3;


    pub fn get_upgrade_id(&self) -> bool {
        self.upgrade_id.unwrap_or(false)
    }
    pub fn clear_upgrade_id(&mut self) {
        self.upgrade_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_id(&self) -> bool {
        self.upgrade_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_id(&mut self, v: bool) {
        self.upgrade_id = ::std::option::Option::Some(v);
    }

    // optional bool buff_id = 4;


    pub fn get_buff_id(&self) -> bool {
        self.buff_id.unwrap_or(false)
    }
    pub fn clear_buff_id(&mut self) {
        self.buff_id = ::std::option::Option::None;
    }

    pub fn has_buff_id(&self) -> bool {
        self.buff_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_id(&mut self, v: bool) {
        self.buff_id = ::std::option::Option::Some(v);
    }

    // optional bool effect_id = 5;


    pub fn get_effect_id(&self) -> bool {
        self.effect_id.unwrap_or(false)
    }
    pub fn clear_effect_id(&mut self) {
        self.effect_id = ::std::option::Option::None;
    }

    pub fn has_effect_id(&self) -> bool {
        self.effect_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_id(&mut self, v: bool) {
        self.effect_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RequestData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unit_type_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.upgrade_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.buff_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.effect_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += 2;
        }
        if let Some(v) = self.unit_type_id {
            my_size += 2;
        }
        if let Some(v) = self.upgrade_id {
            my_size += 2;
        }
        if let Some(v) = self.buff_id {
            my_size += 2;
        }
        if let Some(v) = self.effect_id {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.unit_type_id {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.upgrade_id {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.buff_id {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.effect_id {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestData {
        RequestData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ability_id",
                |m: &RequestData| { &m.ability_id },
                |m: &mut RequestData| { &mut m.ability_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unit_type_id",
                |m: &RequestData| { &m.unit_type_id },
                |m: &mut RequestData| { &mut m.unit_type_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "upgrade_id",
                |m: &RequestData| { &m.upgrade_id },
                |m: &mut RequestData| { &mut m.upgrade_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "buff_id",
                |m: &RequestData| { &m.buff_id },
                |m: &mut RequestData| { &mut m.buff_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "effect_id",
                |m: &RequestData| { &m.effect_id },
                |m: &mut RequestData| { &mut m.effect_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestData>(
                "RequestData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestData {
        static instance: ::protobuf::rt::LazyV2<RequestData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestData::new)
    }
}

impl ::protobuf::Clear for RequestData {
    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.unit_type_id = ::std::option::Option::None;
        self.upgrade_id = ::std::option::Option::None;
        self.buff_id = ::std::option::Option::None;
        self.effect_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseData {
    // message fields
    pub abilities: ::protobuf::RepeatedField<super::data::AbilityData>,
    pub units: ::protobuf::RepeatedField<super::data::UnitTypeData>,
    pub upgrades: ::protobuf::RepeatedField<super::data::UpgradeData>,
    pub buffs: ::protobuf::RepeatedField<super::data::BuffData>,
    pub effects: ::protobuf::RepeatedField<super::data::EffectData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseData {
    fn default() -> &'a ResponseData {
        <ResponseData as ::protobuf::Message>::default_instance()
    }
}

impl ResponseData {
    pub fn new() -> ResponseData {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.AbilityData abilities = 1;


    pub fn get_abilities(&self) -> &[super::data::AbilityData] {
        &self.abilities
    }
    pub fn clear_abilities(&mut self) {
        self.abilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_abilities(&mut self, v: ::protobuf::RepeatedField<super::data::AbilityData>) {
        self.abilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abilities(&mut self) -> &mut ::protobuf::RepeatedField<super::data::AbilityData> {
        &mut self.abilities
    }

    // Take field
    pub fn take_abilities(&mut self) -> ::protobuf::RepeatedField<super::data::AbilityData> {
        ::std::mem::replace(&mut self.abilities, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.UnitTypeData units = 2;


    pub fn get_units(&self) -> &[super::data::UnitTypeData] {
        &self.units
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: ::protobuf::RepeatedField<super::data::UnitTypeData>) {
        self.units = v;
    }

    // Mutable pointer to the field.
    pub fn mut_units(&mut self) -> &mut ::protobuf::RepeatedField<super::data::UnitTypeData> {
        &mut self.units
    }

    // Take field
    pub fn take_units(&mut self) -> ::protobuf::RepeatedField<super::data::UnitTypeData> {
        ::std::mem::replace(&mut self.units, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.UpgradeData upgrades = 3;


    pub fn get_upgrades(&self) -> &[super::data::UpgradeData] {
        &self.upgrades
    }
    pub fn clear_upgrades(&mut self) {
        self.upgrades.clear();
    }

    // Param is passed by value, moved
    pub fn set_upgrades(&mut self, v: ::protobuf::RepeatedField<super::data::UpgradeData>) {
        self.upgrades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_upgrades(&mut self) -> &mut ::protobuf::RepeatedField<super::data::UpgradeData> {
        &mut self.upgrades
    }

    // Take field
    pub fn take_upgrades(&mut self) -> ::protobuf::RepeatedField<super::data::UpgradeData> {
        ::std::mem::replace(&mut self.upgrades, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.BuffData buffs = 4;


    pub fn get_buffs(&self) -> &[super::data::BuffData] {
        &self.buffs
    }
    pub fn clear_buffs(&mut self) {
        self.buffs.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffs(&mut self, v: ::protobuf::RepeatedField<super::data::BuffData>) {
        self.buffs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buffs(&mut self) -> &mut ::protobuf::RepeatedField<super::data::BuffData> {
        &mut self.buffs
    }

    // Take field
    pub fn take_buffs(&mut self) -> ::protobuf::RepeatedField<super::data::BuffData> {
        ::std::mem::replace(&mut self.buffs, ::protobuf::RepeatedField::new())
    }

    // repeated .SC2APIProtocol.EffectData effects = 5;


    pub fn get_effects(&self) -> &[super::data::EffectData] {
        &self.effects
    }
    pub fn clear_effects(&mut self) {
        self.effects.clear();
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: ::protobuf::RepeatedField<super::data::EffectData>) {
        self.effects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_effects(&mut self) -> &mut ::protobuf::RepeatedField<super::data::EffectData> {
        &mut self.effects
    }

    // Take field
    pub fn take_effects(&mut self) -> ::protobuf::RepeatedField<super::data::EffectData> {
        ::std::mem::replace(&mut self.effects, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResponseData {
    fn is_initialized(&self) -> bool {
        for v in &self.abilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.upgrades {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buffs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.effects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.abilities)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.units)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.upgrades)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buffs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.effects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.units {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.upgrades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buffs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.abilities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.units {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.upgrades {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buffs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.effects {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseData {
        ResponseData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::data::AbilityData>>(
                "abilities",
                |m: &ResponseData| { &m.abilities },
                |m: &mut ResponseData| { &mut m.abilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::data::UnitTypeData>>(
                "units",
                |m: &ResponseData| { &m.units },
                |m: &mut ResponseData| { &mut m.units },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::data::UpgradeData>>(
                "upgrades",
                |m: &ResponseData| { &m.upgrades },
                |m: &mut ResponseData| { &mut m.upgrades },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::data::BuffData>>(
                "buffs",
                |m: &ResponseData| { &m.buffs },
                |m: &mut ResponseData| { &mut m.buffs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::data::EffectData>>(
                "effects",
                |m: &ResponseData| { &m.effects },
                |m: &mut ResponseData| { &mut m.effects },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseData>(
                "ResponseData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseData {
        static instance: ::protobuf::rt::LazyV2<ResponseData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseData::new)
    }
}

impl ::protobuf::Clear for ResponseData {
    fn clear(&mut self) {
        self.abilities.clear();
        self.units.clear();
        self.upgrades.clear();
        self.buffs.clear();
        self.effects.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestSaveReplay {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestSaveReplay {
    fn default() -> &'a RequestSaveReplay {
        <RequestSaveReplay as ::protobuf::Message>::default_instance()
    }
}

impl RequestSaveReplay {
    pub fn new() -> RequestSaveReplay {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestSaveReplay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestSaveReplay {
        RequestSaveReplay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestSaveReplay>(
                "RequestSaveReplay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestSaveReplay {
        static instance: ::protobuf::rt::LazyV2<RequestSaveReplay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestSaveReplay::new)
    }
}

impl ::protobuf::Clear for RequestSaveReplay {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestSaveReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestSaveReplay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseSaveReplay {
    // message fields
    pub data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseSaveReplay {
    fn default() -> &'a ResponseSaveReplay {
        <ResponseSaveReplay as ::protobuf::Message>::default_instance()
    }
}

impl ResponseSaveReplay {
    pub fn new() -> ResponseSaveReplay {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ResponseSaveReplay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseSaveReplay {
        ResponseSaveReplay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &ResponseSaveReplay| { &m.data },
                |m: &mut ResponseSaveReplay| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseSaveReplay>(
                "ResponseSaveReplay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseSaveReplay {
        static instance: ::protobuf::rt::LazyV2<ResponseSaveReplay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseSaveReplay::new)
    }
}

impl ::protobuf::Clear for ResponseSaveReplay {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseSaveReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseSaveReplay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestReplayInfo {
    // message fields
    pub download_data: ::std::option::Option<bool>,
    // message oneof groups
    pub replay: ::std::option::Option<RequestReplayInfo_oneof_replay>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestReplayInfo {
    fn default() -> &'a RequestReplayInfo {
        <RequestReplayInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RequestReplayInfo_oneof_replay {
    replay_path(::std::string::String),
    replay_data(::std::vec::Vec<u8>),
}

impl RequestReplayInfo {
    pub fn new() -> RequestReplayInfo {
        ::std::default::Default::default()
    }

    // optional string replay_path = 1;


    pub fn get_replay_path(&self) -> &str {
        match self.replay {
            ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_path(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_replay_path(&mut self) {
        self.replay = ::std::option::Option::None;
    }

    pub fn has_replay_path(&self) -> bool {
        match self.replay {
            ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_path(&mut self, v: ::std::string::String) {
        self.replay = ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_path(_)) = self.replay {
        } else {
            self.replay = ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_path(::std::string::String::new()));
        }
        match self.replay {
            ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_path(&mut self) -> ::std::string::String {
        if self.has_replay_path() {
            match self.replay.take() {
                ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_path(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bytes replay_data = 2;


    pub fn get_replay_data(&self) -> &[u8] {
        match self.replay {
            ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_data(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_replay_data(&mut self) {
        self.replay = ::std::option::Option::None;
    }

    pub fn has_replay_data(&self) -> bool {
        match self.replay {
            ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.replay = ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_data(_)) = self.replay {
        } else {
            self.replay = ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_data(::std::vec::Vec::new()));
        }
        match self.replay {
            ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_data(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_replay_data() {
            match self.replay.take() {
                ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_data(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // optional bool download_data = 3;


    pub fn get_download_data(&self) -> bool {
        self.download_data.unwrap_or(false)
    }
    pub fn clear_download_data(&mut self) {
        self.download_data = ::std::option::Option::None;
    }

    pub fn has_download_data(&self) -> bool {
        self.download_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_data(&mut self, v: bool) {
        self.download_data = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RequestReplayInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.replay = ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_path(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.replay = ::std::option::Option::Some(RequestReplayInfo_oneof_replay::replay_data(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.download_data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.download_data {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.replay {
            match v {
                &RequestReplayInfo_oneof_replay::replay_path(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &RequestReplayInfo_oneof_replay::replay_data(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.download_data {
            os.write_bool(3, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.replay {
            match v {
                &RequestReplayInfo_oneof_replay::replay_path(ref v) => {
                    os.write_string(1, v)?;
                },
                &RequestReplayInfo_oneof_replay::replay_data(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestReplayInfo {
        RequestReplayInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "replay_path",
                RequestReplayInfo::has_replay_path,
                RequestReplayInfo::get_replay_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "replay_data",
                RequestReplayInfo::has_replay_data,
                RequestReplayInfo::get_replay_data,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "download_data",
                |m: &RequestReplayInfo| { &m.download_data },
                |m: &mut RequestReplayInfo| { &mut m.download_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestReplayInfo>(
                "RequestReplayInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestReplayInfo {
        static instance: ::protobuf::rt::LazyV2<RequestReplayInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestReplayInfo::new)
    }
}

impl ::protobuf::Clear for RequestReplayInfo {
    fn clear(&mut self) {
        self.replay = ::std::option::Option::None;
        self.replay = ::std::option::Option::None;
        self.download_data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestReplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestReplayInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerInfoExtra {
    // message fields
    pub player_info: ::protobuf::SingularPtrField<PlayerInfo>,
    pub player_result: ::protobuf::SingularPtrField<PlayerResult>,
    pub player_mmr: ::std::option::Option<i32>,
    pub player_apm: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerInfoExtra {
    fn default() -> &'a PlayerInfoExtra {
        <PlayerInfoExtra as ::protobuf::Message>::default_instance()
    }
}

impl PlayerInfoExtra {
    pub fn new() -> PlayerInfoExtra {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.PlayerInfo player_info = 1;


    pub fn get_player_info(&self) -> &PlayerInfo {
        self.player_info.as_ref().unwrap_or_else(|| <PlayerInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_info(&mut self) {
        self.player_info.clear();
    }

    pub fn has_player_info(&self) -> bool {
        self.player_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_info(&mut self, v: PlayerInfo) {
        self.player_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_info(&mut self) -> &mut PlayerInfo {
        if self.player_info.is_none() {
            self.player_info.set_default();
        }
        self.player_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_info(&mut self) -> PlayerInfo {
        self.player_info.take().unwrap_or_else(|| PlayerInfo::new())
    }

    // optional .SC2APIProtocol.PlayerResult player_result = 2;


    pub fn get_player_result(&self) -> &PlayerResult {
        self.player_result.as_ref().unwrap_or_else(|| <PlayerResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_result(&mut self) {
        self.player_result.clear();
    }

    pub fn has_player_result(&self) -> bool {
        self.player_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_result(&mut self, v: PlayerResult) {
        self.player_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_result(&mut self) -> &mut PlayerResult {
        if self.player_result.is_none() {
            self.player_result.set_default();
        }
        self.player_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_result(&mut self) -> PlayerResult {
        self.player_result.take().unwrap_or_else(|| PlayerResult::new())
    }

    // optional int32 player_mmr = 3;


    pub fn get_player_mmr(&self) -> i32 {
        self.player_mmr.unwrap_or(0)
    }
    pub fn clear_player_mmr(&mut self) {
        self.player_mmr = ::std::option::Option::None;
    }

    pub fn has_player_mmr(&self) -> bool {
        self.player_mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mmr(&mut self, v: i32) {
        self.player_mmr = ::std::option::Option::Some(v);
    }

    // optional int32 player_apm = 4;


    pub fn get_player_apm(&self) -> i32 {
        self.player_apm.unwrap_or(0)
    }
    pub fn clear_player_apm(&mut self) {
        self.player_apm = ::std::option::Option::None;
    }

    pub fn has_player_apm(&self) -> bool {
        self.player_apm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_apm(&mut self, v: i32) {
        self.player_apm = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerInfoExtra {
    fn is_initialized(&self) -> bool {
        for v in &self.player_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_result)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_mmr = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_apm = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.player_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.player_mmr {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_apm {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.player_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player_result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.player_mmr {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.player_apm {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerInfoExtra {
        PlayerInfoExtra::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerInfo>>(
                "player_info",
                |m: &PlayerInfoExtra| { &m.player_info },
                |m: &mut PlayerInfoExtra| { &mut m.player_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerResult>>(
                "player_result",
                |m: &PlayerInfoExtra| { &m.player_result },
                |m: &mut PlayerInfoExtra| { &mut m.player_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "player_mmr",
                |m: &PlayerInfoExtra| { &m.player_mmr },
                |m: &mut PlayerInfoExtra| { &mut m.player_mmr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "player_apm",
                |m: &PlayerInfoExtra| { &m.player_apm },
                |m: &mut PlayerInfoExtra| { &mut m.player_apm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerInfoExtra>(
                "PlayerInfoExtra",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerInfoExtra {
        static instance: ::protobuf::rt::LazyV2<PlayerInfoExtra> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerInfoExtra::new)
    }
}

impl ::protobuf::Clear for PlayerInfoExtra {
    fn clear(&mut self) {
        self.player_info.clear();
        self.player_result.clear();
        self.player_mmr = ::std::option::Option::None;
        self.player_apm = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerInfoExtra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerInfoExtra {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseReplayInfo {
    // message fields
    pub map_name: ::protobuf::SingularField<::std::string::String>,
    pub local_map_path: ::protobuf::SingularField<::std::string::String>,
    pub player_info: ::protobuf::RepeatedField<PlayerInfoExtra>,
    pub game_duration_loops: ::std::option::Option<u32>,
    pub game_duration_seconds: ::std::option::Option<f32>,
    pub game_version: ::protobuf::SingularField<::std::string::String>,
    pub data_version: ::protobuf::SingularField<::std::string::String>,
    pub data_build: ::std::option::Option<u32>,
    pub base_build: ::std::option::Option<u32>,
    pub error: ::std::option::Option<ResponseReplayInfo_Error>,
    pub error_details: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseReplayInfo {
    fn default() -> &'a ResponseReplayInfo {
        <ResponseReplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl ResponseReplayInfo {
    pub fn new() -> ResponseReplayInfo {
        ::std::default::Default::default()
    }

    // optional string map_name = 1;


    pub fn get_map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string local_map_path = 2;


    pub fn get_local_map_path(&self) -> &str {
        match self.local_map_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_local_map_path(&mut self) {
        self.local_map_path.clear();
    }

    pub fn has_local_map_path(&self) -> bool {
        self.local_map_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_map_path(&mut self, v: ::std::string::String) {
        self.local_map_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_map_path(&mut self) -> &mut ::std::string::String {
        if self.local_map_path.is_none() {
            self.local_map_path.set_default();
        }
        self.local_map_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_map_path(&mut self) -> ::std::string::String {
        self.local_map_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .SC2APIProtocol.PlayerInfoExtra player_info = 3;


    pub fn get_player_info(&self) -> &[PlayerInfoExtra] {
        &self.player_info
    }
    pub fn clear_player_info(&mut self) {
        self.player_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_info(&mut self, v: ::protobuf::RepeatedField<PlayerInfoExtra>) {
        self.player_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_info(&mut self) -> &mut ::protobuf::RepeatedField<PlayerInfoExtra> {
        &mut self.player_info
    }

    // Take field
    pub fn take_player_info(&mut self) -> ::protobuf::RepeatedField<PlayerInfoExtra> {
        ::std::mem::replace(&mut self.player_info, ::protobuf::RepeatedField::new())
    }

    // optional uint32 game_duration_loops = 4;


    pub fn get_game_duration_loops(&self) -> u32 {
        self.game_duration_loops.unwrap_or(0)
    }
    pub fn clear_game_duration_loops(&mut self) {
        self.game_duration_loops = ::std::option::Option::None;
    }

    pub fn has_game_duration_loops(&self) -> bool {
        self.game_duration_loops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_duration_loops(&mut self, v: u32) {
        self.game_duration_loops = ::std::option::Option::Some(v);
    }

    // optional float game_duration_seconds = 5;


    pub fn get_game_duration_seconds(&self) -> f32 {
        self.game_duration_seconds.unwrap_or(0.)
    }
    pub fn clear_game_duration_seconds(&mut self) {
        self.game_duration_seconds = ::std::option::Option::None;
    }

    pub fn has_game_duration_seconds(&self) -> bool {
        self.game_duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_duration_seconds(&mut self, v: f32) {
        self.game_duration_seconds = ::std::option::Option::Some(v);
    }

    // optional string game_version = 6;


    pub fn get_game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_version(&mut self) {
        self.game_version.clear();
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version.set_default();
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string data_version = 11;


    pub fn get_data_version(&self) -> &str {
        match self.data_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_data_version(&mut self) {
        self.data_version.clear();
    }

    pub fn has_data_version(&self) -> bool {
        self.data_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_version(&mut self, v: ::std::string::String) {
        self.data_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_version(&mut self) -> &mut ::std::string::String {
        if self.data_version.is_none() {
            self.data_version.set_default();
        }
        self.data_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_version(&mut self) -> ::std::string::String {
        self.data_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 data_build = 7;


    pub fn get_data_build(&self) -> u32 {
        self.data_build.unwrap_or(0)
    }
    pub fn clear_data_build(&mut self) {
        self.data_build = ::std::option::Option::None;
    }

    pub fn has_data_build(&self) -> bool {
        self.data_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_build(&mut self, v: u32) {
        self.data_build = ::std::option::Option::Some(v);
    }

    // optional uint32 base_build = 8;


    pub fn get_base_build(&self) -> u32 {
        self.base_build.unwrap_or(0)
    }
    pub fn clear_base_build(&mut self) {
        self.base_build = ::std::option::Option::None;
    }

    pub fn has_base_build(&self) -> bool {
        self.base_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_build(&mut self, v: u32) {
        self.base_build = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.ResponseReplayInfo.Error error = 9;


    pub fn get_error(&self) -> ResponseReplayInfo_Error {
        self.error.unwrap_or(ResponseReplayInfo_Error::MissingReplay)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ResponseReplayInfo_Error) {
        self.error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 10;


    pub fn get_error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_details(&mut self) {
        self.error_details.clear();
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details.set_default();
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResponseReplayInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.player_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.local_map_path)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_info)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_duration_loops = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.game_duration_seconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_version)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.data_version)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_build = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_build = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.local_map_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.player_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.game_duration_loops {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_duration_seconds {
            my_size += 5;
        }
        if let Some(ref v) = self.game_version.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.data_version.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.data_build {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_build {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(9, v);
        }
        if let Some(ref v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.map_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.local_map_path.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.player_info {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.game_duration_loops {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_duration_seconds {
            os.write_float(5, v)?;
        }
        if let Some(ref v) = self.game_version.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.data_version.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.data_build {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.base_build {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error_details.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseReplayInfo {
        ResponseReplayInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map_name",
                |m: &ResponseReplayInfo| { &m.map_name },
                |m: &mut ResponseReplayInfo| { &mut m.map_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_map_path",
                |m: &ResponseReplayInfo| { &m.local_map_path },
                |m: &mut ResponseReplayInfo| { &mut m.local_map_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerInfoExtra>>(
                "player_info",
                |m: &ResponseReplayInfo| { &m.player_info },
                |m: &mut ResponseReplayInfo| { &mut m.player_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_duration_loops",
                |m: &ResponseReplayInfo| { &m.game_duration_loops },
                |m: &mut ResponseReplayInfo| { &mut m.game_duration_loops },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "game_duration_seconds",
                |m: &ResponseReplayInfo| { &m.game_duration_seconds },
                |m: &mut ResponseReplayInfo| { &mut m.game_duration_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_version",
                |m: &ResponseReplayInfo| { &m.game_version },
                |m: &mut ResponseReplayInfo| { &mut m.game_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data_version",
                |m: &ResponseReplayInfo| { &m.data_version },
                |m: &mut ResponseReplayInfo| { &mut m.data_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_build",
                |m: &ResponseReplayInfo| { &m.data_build },
                |m: &mut ResponseReplayInfo| { &mut m.data_build },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "base_build",
                |m: &ResponseReplayInfo| { &m.base_build },
                |m: &mut ResponseReplayInfo| { &mut m.base_build },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseReplayInfo_Error>>(
                "error",
                |m: &ResponseReplayInfo| { &m.error },
                |m: &mut ResponseReplayInfo| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_details",
                |m: &ResponseReplayInfo| { &m.error_details },
                |m: &mut ResponseReplayInfo| { &mut m.error_details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseReplayInfo>(
                "ResponseReplayInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseReplayInfo {
        static instance: ::protobuf::rt::LazyV2<ResponseReplayInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseReplayInfo::new)
    }
}

impl ::protobuf::Clear for ResponseReplayInfo {
    fn clear(&mut self) {
        self.map_name.clear();
        self.local_map_path.clear();
        self.player_info.clear();
        self.game_duration_loops = ::std::option::Option::None;
        self.game_duration_seconds = ::std::option::Option::None;
        self.game_version.clear();
        self.data_version.clear();
        self.data_build = ::std::option::Option::None;
        self.base_build = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.error_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseReplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseReplayInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseReplayInfo_Error {
    MissingReplay = 1,
    InvalidReplayPath = 2,
    InvalidReplayData = 3,
    ParsingError = 4,
    DownloadError = 5,
}

impl ::protobuf::ProtobufEnum for ResponseReplayInfo_Error {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseReplayInfo_Error> {
        match value {
            1 => ::std::option::Option::Some(ResponseReplayInfo_Error::MissingReplay),
            2 => ::std::option::Option::Some(ResponseReplayInfo_Error::InvalidReplayPath),
            3 => ::std::option::Option::Some(ResponseReplayInfo_Error::InvalidReplayData),
            4 => ::std::option::Option::Some(ResponseReplayInfo_Error::ParsingError),
            5 => ::std::option::Option::Some(ResponseReplayInfo_Error::DownloadError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseReplayInfo_Error] = &[
            ResponseReplayInfo_Error::MissingReplay,
            ResponseReplayInfo_Error::InvalidReplayPath,
            ResponseReplayInfo_Error::InvalidReplayData,
            ResponseReplayInfo_Error::ParsingError,
            ResponseReplayInfo_Error::DownloadError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseReplayInfo_Error>("ResponseReplayInfo.Error", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseReplayInfo_Error {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ResponseReplayInfo_Error {
    fn default() -> Self {
        ResponseReplayInfo_Error::MissingReplay
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseReplayInfo_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestAvailableMaps {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestAvailableMaps {
    fn default() -> &'a RequestAvailableMaps {
        <RequestAvailableMaps as ::protobuf::Message>::default_instance()
    }
}

impl RequestAvailableMaps {
    pub fn new() -> RequestAvailableMaps {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestAvailableMaps {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestAvailableMaps {
        RequestAvailableMaps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestAvailableMaps>(
                "RequestAvailableMaps",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestAvailableMaps {
        static instance: ::protobuf::rt::LazyV2<RequestAvailableMaps> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestAvailableMaps::new)
    }
}

impl ::protobuf::Clear for RequestAvailableMaps {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestAvailableMaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestAvailableMaps {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseAvailableMaps {
    // message fields
    pub local_map_paths: ::protobuf::RepeatedField<::std::string::String>,
    pub battlenet_map_names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseAvailableMaps {
    fn default() -> &'a ResponseAvailableMaps {
        <ResponseAvailableMaps as ::protobuf::Message>::default_instance()
    }
}

impl ResponseAvailableMaps {
    pub fn new() -> ResponseAvailableMaps {
        ::std::default::Default::default()
    }

    // repeated string local_map_paths = 1;


    pub fn get_local_map_paths(&self) -> &[::std::string::String] {
        &self.local_map_paths
    }
    pub fn clear_local_map_paths(&mut self) {
        self.local_map_paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_map_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.local_map_paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_local_map_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.local_map_paths
    }

    // Take field
    pub fn take_local_map_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.local_map_paths, ::protobuf::RepeatedField::new())
    }

    // repeated string battlenet_map_names = 2;


    pub fn get_battlenet_map_names(&self) -> &[::std::string::String] {
        &self.battlenet_map_names
    }
    pub fn clear_battlenet_map_names(&mut self) {
        self.battlenet_map_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_battlenet_map_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.battlenet_map_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_battlenet_map_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.battlenet_map_names
    }

    // Take field
    pub fn take_battlenet_map_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.battlenet_map_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResponseAvailableMaps {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.local_map_paths)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.battlenet_map_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.local_map_paths {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.battlenet_map_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.local_map_paths {
            os.write_string(1, &v)?;
        };
        for v in &self.battlenet_map_names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseAvailableMaps {
        ResponseAvailableMaps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_map_paths",
                |m: &ResponseAvailableMaps| { &m.local_map_paths },
                |m: &mut ResponseAvailableMaps| { &mut m.local_map_paths },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "battlenet_map_names",
                |m: &ResponseAvailableMaps| { &m.battlenet_map_names },
                |m: &mut ResponseAvailableMaps| { &mut m.battlenet_map_names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseAvailableMaps>(
                "ResponseAvailableMaps",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseAvailableMaps {
        static instance: ::protobuf::rt::LazyV2<ResponseAvailableMaps> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseAvailableMaps::new)
    }
}

impl ::protobuf::Clear for ResponseAvailableMaps {
    fn clear(&mut self) {
        self.local_map_paths.clear();
        self.battlenet_map_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseAvailableMaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseAvailableMaps {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestSaveMap {
    // message fields
    pub map_path: ::protobuf::SingularField<::std::string::String>,
    pub map_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestSaveMap {
    fn default() -> &'a RequestSaveMap {
        <RequestSaveMap as ::protobuf::Message>::default_instance()
    }
}

impl RequestSaveMap {
    pub fn new() -> RequestSaveMap {
        ::std::default::Default::default()
    }

    // optional string map_path = 1;


    pub fn get_map_path(&self) -> &str {
        match self.map_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map_path(&mut self) {
        self.map_path.clear();
    }

    pub fn has_map_path(&self) -> bool {
        self.map_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_path(&mut self, v: ::std::string::String) {
        self.map_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_path(&mut self) -> &mut ::std::string::String {
        if self.map_path.is_none() {
            self.map_path.set_default();
        }
        self.map_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_path(&mut self) -> ::std::string::String {
        self.map_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes map_data = 2;


    pub fn get_map_data(&self) -> &[u8] {
        match self.map_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_map_data(&mut self) {
        self.map_data.clear();
    }

    pub fn has_map_data(&self) -> bool {
        self.map_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.map_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.map_data.is_none() {
            self.map_data.set_default();
        }
        self.map_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_data(&mut self) -> ::std::vec::Vec<u8> {
        self.map_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RequestSaveMap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.map_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.map_path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.map_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.map_path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.map_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestSaveMap {
        RequestSaveMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map_path",
                |m: &RequestSaveMap| { &m.map_path },
                |m: &mut RequestSaveMap| { &mut m.map_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "map_data",
                |m: &RequestSaveMap| { &m.map_data },
                |m: &mut RequestSaveMap| { &mut m.map_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestSaveMap>(
                "RequestSaveMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestSaveMap {
        static instance: ::protobuf::rt::LazyV2<RequestSaveMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestSaveMap::new)
    }
}

impl ::protobuf::Clear for RequestSaveMap {
    fn clear(&mut self) {
        self.map_path.clear();
        self.map_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestSaveMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestSaveMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseSaveMap {
    // message fields
    pub error: ::std::option::Option<ResponseSaveMap_Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseSaveMap {
    fn default() -> &'a ResponseSaveMap {
        <ResponseSaveMap as ::protobuf::Message>::default_instance()
    }
}

impl ResponseSaveMap {
    pub fn new() -> ResponseSaveMap {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseSaveMap.Error error = 1;


    pub fn get_error(&self) -> ResponseSaveMap_Error {
        self.error.unwrap_or(ResponseSaveMap_Error::InvalidMapData)
    }
    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ResponseSaveMap_Error) {
        self.error = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ResponseSaveMap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseSaveMap {
        ResponseSaveMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseSaveMap_Error>>(
                "error",
                |m: &ResponseSaveMap| { &m.error },
                |m: &mut ResponseSaveMap| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseSaveMap>(
                "ResponseSaveMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseSaveMap {
        static instance: ::protobuf::rt::LazyV2<ResponseSaveMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseSaveMap::new)
    }
}

impl ::protobuf::Clear for ResponseSaveMap {
    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseSaveMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseSaveMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseSaveMap_Error {
    InvalidMapData = 1,
}

impl ::protobuf::ProtobufEnum for ResponseSaveMap_Error {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseSaveMap_Error> {
        match value {
            1 => ::std::option::Option::Some(ResponseSaveMap_Error::InvalidMapData),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseSaveMap_Error] = &[
            ResponseSaveMap_Error::InvalidMapData,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseSaveMap_Error>("ResponseSaveMap.Error", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseSaveMap_Error {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ResponseSaveMap_Error {
    fn default() -> Self {
        ResponseSaveMap_Error::InvalidMapData
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseSaveMap_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestPing {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestPing {
    fn default() -> &'a RequestPing {
        <RequestPing as ::protobuf::Message>::default_instance()
    }
}

impl RequestPing {
    pub fn new() -> RequestPing {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RequestPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestPing {
        RequestPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestPing>(
                "RequestPing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestPing {
        static instance: ::protobuf::rt::LazyV2<RequestPing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestPing::new)
    }
}

impl ::protobuf::Clear for RequestPing {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponsePing {
    // message fields
    pub game_version: ::protobuf::SingularField<::std::string::String>,
    pub data_version: ::protobuf::SingularField<::std::string::String>,
    pub data_build: ::std::option::Option<u32>,
    pub base_build: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponsePing {
    fn default() -> &'a ResponsePing {
        <ResponsePing as ::protobuf::Message>::default_instance()
    }
}

impl ResponsePing {
    pub fn new() -> ResponsePing {
        ::std::default::Default::default()
    }

    // optional string game_version = 1;


    pub fn get_game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_version(&mut self) {
        self.game_version.clear();
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version.set_default();
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string data_version = 2;


    pub fn get_data_version(&self) -> &str {
        match self.data_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_data_version(&mut self) {
        self.data_version.clear();
    }

    pub fn has_data_version(&self) -> bool {
        self.data_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_version(&mut self, v: ::std::string::String) {
        self.data_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_version(&mut self) -> &mut ::std::string::String {
        if self.data_version.is_none() {
            self.data_version.set_default();
        }
        self.data_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_version(&mut self) -> ::std::string::String {
        self.data_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 data_build = 3;


    pub fn get_data_build(&self) -> u32 {
        self.data_build.unwrap_or(0)
    }
    pub fn clear_data_build(&mut self) {
        self.data_build = ::std::option::Option::None;
    }

    pub fn has_data_build(&self) -> bool {
        self.data_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_build(&mut self, v: u32) {
        self.data_build = ::std::option::Option::Some(v);
    }

    // optional uint32 base_build = 4;


    pub fn get_base_build(&self) -> u32 {
        self.base_build.unwrap_or(0)
    }
    pub fn clear_base_build(&mut self) {
        self.base_build = ::std::option::Option::None;
    }

    pub fn has_base_build(&self) -> bool {
        self.base_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_build(&mut self, v: u32) {
        self.base_build = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ResponsePing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.data_version)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_build = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_build = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.game_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.data_version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.data_build {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.base_build {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.game_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.data_version.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.data_build {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.base_build {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponsePing {
        ResponsePing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_version",
                |m: &ResponsePing| { &m.game_version },
                |m: &mut ResponsePing| { &mut m.game_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data_version",
                |m: &ResponsePing| { &m.data_version },
                |m: &mut ResponsePing| { &mut m.data_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_build",
                |m: &ResponsePing| { &m.data_build },
                |m: &mut ResponsePing| { &mut m.data_build },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "base_build",
                |m: &ResponsePing| { &m.base_build },
                |m: &mut ResponsePing| { &mut m.base_build },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponsePing>(
                "ResponsePing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponsePing {
        static instance: ::protobuf::rt::LazyV2<ResponsePing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponsePing::new)
    }
}

impl ::protobuf::Clear for ResponsePing {
    fn clear(&mut self) {
        self.game_version.clear();
        self.data_version.clear();
        self.data_build = ::std::option::Option::None;
        self.base_build = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponsePing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponsePing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestDebug {
    // message fields
    pub debug: ::protobuf::RepeatedField<super::debug::DebugCommand>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestDebug {
    fn default() -> &'a RequestDebug {
        <RequestDebug as ::protobuf::Message>::default_instance()
    }
}

impl RequestDebug {
    pub fn new() -> RequestDebug {
        ::std::default::Default::default()
    }

    // repeated .SC2APIProtocol.DebugCommand debug = 1;


    pub fn get_debug(&self) -> &[super::debug::DebugCommand] {
        &self.debug
    }
    pub fn clear_debug(&mut self) {
        self.debug.clear();
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ::protobuf::RepeatedField<super::debug::DebugCommand>) {
        self.debug = v;
    }

    // Mutable pointer to the field.
    pub fn mut_debug(&mut self) -> &mut ::protobuf::RepeatedField<super::debug::DebugCommand> {
        &mut self.debug
    }

    // Take field
    pub fn take_debug(&mut self) -> ::protobuf::RepeatedField<super::debug::DebugCommand> {
        ::std::mem::replace(&mut self.debug, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RequestDebug {
    fn is_initialized(&self) -> bool {
        for v in &self.debug {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.debug)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.debug {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.debug {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestDebug {
        RequestDebug::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::debug::DebugCommand>>(
                "debug",
                |m: &RequestDebug| { &m.debug },
                |m: &mut RequestDebug| { &mut m.debug },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestDebug>(
                "RequestDebug",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestDebug {
        static instance: ::protobuf::rt::LazyV2<RequestDebug> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestDebug::new)
    }
}

impl ::protobuf::Clear for RequestDebug {
    fn clear(&mut self) {
        self.debug.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestDebug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestDebug {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseDebug {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseDebug {
    fn default() -> &'a ResponseDebug {
        <ResponseDebug as ::protobuf::Message>::default_instance()
    }
}

impl ResponseDebug {
    pub fn new() -> ResponseDebug {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResponseDebug {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseDebug {
        ResponseDebug::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseDebug>(
                "ResponseDebug",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseDebug {
        static instance: ::protobuf::rt::LazyV2<ResponseDebug> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseDebug::new)
    }
}

impl ::protobuf::Clear for ResponseDebug {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseDebug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseDebug {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerSetup {
    // message fields
    pub field_type: ::std::option::Option<PlayerType>,
    pub race: ::std::option::Option<super::common::Race>,
    pub difficulty: ::std::option::Option<Difficulty>,
    pub player_name: ::protobuf::SingularField<::std::string::String>,
    pub ai_build: ::std::option::Option<AIBuild>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerSetup {
    fn default() -> &'a PlayerSetup {
        <PlayerSetup as ::protobuf::Message>::default_instance()
    }
}

impl PlayerSetup {
    pub fn new() -> PlayerSetup {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.PlayerType type = 1;


    pub fn get_field_type(&self) -> PlayerType {
        self.field_type.unwrap_or(PlayerType::Participant)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PlayerType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Race race = 2;


    pub fn get_race(&self) -> super::common::Race {
        self.race.unwrap_or(super::common::Race::NoRace)
    }
    pub fn clear_race(&mut self) {
        self.race = ::std::option::Option::None;
    }

    pub fn has_race(&self) -> bool {
        self.race.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race(&mut self, v: super::common::Race) {
        self.race = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Difficulty difficulty = 3;


    pub fn get_difficulty(&self) -> Difficulty {
        self.difficulty.unwrap_or(Difficulty::VeryEasy)
    }
    pub fn clear_difficulty(&mut self) {
        self.difficulty = ::std::option::Option::None;
    }

    pub fn has_difficulty(&self) -> bool {
        self.difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: Difficulty) {
        self.difficulty = ::std::option::Option::Some(v);
    }

    // optional string player_name = 4;


    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .SC2APIProtocol.AIBuild ai_build = 5;


    pub fn get_ai_build(&self) -> AIBuild {
        self.ai_build.unwrap_or(AIBuild::RandomBuild)
    }
    pub fn clear_ai_build(&mut self) {
        self.ai_build = ::std::option::Option::None;
    }

    pub fn has_ai_build(&self) -> bool {
        self.ai_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ai_build(&mut self, v: AIBuild) {
        self.ai_build = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerSetup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.race, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.difficulty, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.ai_build, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.race {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.difficulty {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.ai_build {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.race {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.difficulty {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.ai_build {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerSetup {
        PlayerSetup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PlayerType>>(
                "type",
                |m: &PlayerSetup| { &m.field_type },
                |m: &mut PlayerSetup| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::Race>>(
                "race",
                |m: &PlayerSetup| { &m.race },
                |m: &mut PlayerSetup| { &mut m.race },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Difficulty>>(
                "difficulty",
                |m: &PlayerSetup| { &m.difficulty },
                |m: &mut PlayerSetup| { &mut m.difficulty },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "player_name",
                |m: &PlayerSetup| { &m.player_name },
                |m: &mut PlayerSetup| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AIBuild>>(
                "ai_build",
                |m: &PlayerSetup| { &m.ai_build },
                |m: &mut PlayerSetup| { &mut m.ai_build },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerSetup>(
                "PlayerSetup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerSetup {
        static instance: ::protobuf::rt::LazyV2<PlayerSetup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerSetup::new)
    }
}

impl ::protobuf::Clear for PlayerSetup {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.race = ::std::option::Option::None;
        self.difficulty = ::std::option::Option::None;
        self.player_name.clear();
        self.ai_build = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerSetup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpatialCameraSetup {
    // message fields
    pub resolution: ::protobuf::SingularPtrField<super::common::Size2DI>,
    pub minimap_resolution: ::protobuf::SingularPtrField<super::common::Size2DI>,
    pub width: ::std::option::Option<f32>,
    pub crop_to_playable_area: ::std::option::Option<bool>,
    pub allow_cheating_layers: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpatialCameraSetup {
    fn default() -> &'a SpatialCameraSetup {
        <SpatialCameraSetup as ::protobuf::Message>::default_instance()
    }
}

impl SpatialCameraSetup {
    pub fn new() -> SpatialCameraSetup {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Size2DI resolution = 2;


    pub fn get_resolution(&self) -> &super::common::Size2DI {
        self.resolution.as_ref().unwrap_or_else(|| <super::common::Size2DI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resolution(&mut self) {
        self.resolution.clear();
    }

    pub fn has_resolution(&self) -> bool {
        self.resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolution(&mut self, v: super::common::Size2DI) {
        self.resolution = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resolution(&mut self) -> &mut super::common::Size2DI {
        if self.resolution.is_none() {
            self.resolution.set_default();
        }
        self.resolution.as_mut().unwrap()
    }

    // Take field
    pub fn take_resolution(&mut self) -> super::common::Size2DI {
        self.resolution.take().unwrap_or_else(|| super::common::Size2DI::new())
    }

    // optional .SC2APIProtocol.Size2DI minimap_resolution = 3;


    pub fn get_minimap_resolution(&self) -> &super::common::Size2DI {
        self.minimap_resolution.as_ref().unwrap_or_else(|| <super::common::Size2DI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_minimap_resolution(&mut self) {
        self.minimap_resolution.clear();
    }

    pub fn has_minimap_resolution(&self) -> bool {
        self.minimap_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimap_resolution(&mut self, v: super::common::Size2DI) {
        self.minimap_resolution = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimap_resolution(&mut self) -> &mut super::common::Size2DI {
        if self.minimap_resolution.is_none() {
            self.minimap_resolution.set_default();
        }
        self.minimap_resolution.as_mut().unwrap()
    }

    // Take field
    pub fn take_minimap_resolution(&mut self) -> super::common::Size2DI {
        self.minimap_resolution.take().unwrap_or_else(|| super::common::Size2DI::new())
    }

    // optional float width = 1;


    pub fn get_width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional bool crop_to_playable_area = 4;


    pub fn get_crop_to_playable_area(&self) -> bool {
        self.crop_to_playable_area.unwrap_or(false)
    }
    pub fn clear_crop_to_playable_area(&mut self) {
        self.crop_to_playable_area = ::std::option::Option::None;
    }

    pub fn has_crop_to_playable_area(&self) -> bool {
        self.crop_to_playable_area.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crop_to_playable_area(&mut self, v: bool) {
        self.crop_to_playable_area = ::std::option::Option::Some(v);
    }

    // optional bool allow_cheating_layers = 5;


    pub fn get_allow_cheating_layers(&self) -> bool {
        self.allow_cheating_layers.unwrap_or(false)
    }
    pub fn clear_allow_cheating_layers(&mut self) {
        self.allow_cheating_layers = ::std::option::Option::None;
    }

    pub fn has_allow_cheating_layers(&self) -> bool {
        self.allow_cheating_layers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheating_layers(&mut self, v: bool) {
        self.allow_cheating_layers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SpatialCameraSetup {
    fn is_initialized(&self) -> bool {
        for v in &self.resolution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.minimap_resolution {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resolution)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.minimap_resolution)?;
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.crop_to_playable_area = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_cheating_layers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resolution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.minimap_resolution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.width {
            my_size += 5;
        }
        if let Some(v) = self.crop_to_playable_area {
            my_size += 2;
        }
        if let Some(v) = self.allow_cheating_layers {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resolution.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.minimap_resolution.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.width {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.crop_to_playable_area {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.allow_cheating_layers {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpatialCameraSetup {
        SpatialCameraSetup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Size2DI>>(
                "resolution",
                |m: &SpatialCameraSetup| { &m.resolution },
                |m: &mut SpatialCameraSetup| { &mut m.resolution },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Size2DI>>(
                "minimap_resolution",
                |m: &SpatialCameraSetup| { &m.minimap_resolution },
                |m: &mut SpatialCameraSetup| { &mut m.minimap_resolution },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "width",
                |m: &SpatialCameraSetup| { &m.width },
                |m: &mut SpatialCameraSetup| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "crop_to_playable_area",
                |m: &SpatialCameraSetup| { &m.crop_to_playable_area },
                |m: &mut SpatialCameraSetup| { &mut m.crop_to_playable_area },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_cheating_layers",
                |m: &SpatialCameraSetup| { &m.allow_cheating_layers },
                |m: &mut SpatialCameraSetup| { &mut m.allow_cheating_layers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SpatialCameraSetup>(
                "SpatialCameraSetup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SpatialCameraSetup {
        static instance: ::protobuf::rt::LazyV2<SpatialCameraSetup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpatialCameraSetup::new)
    }
}

impl ::protobuf::Clear for SpatialCameraSetup {
    fn clear(&mut self) {
        self.resolution.clear();
        self.minimap_resolution.clear();
        self.width = ::std::option::Option::None;
        self.crop_to_playable_area = ::std::option::Option::None;
        self.allow_cheating_layers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpatialCameraSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpatialCameraSetup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InterfaceOptions {
    // message fields
    pub raw: ::std::option::Option<bool>,
    pub score: ::std::option::Option<bool>,
    pub feature_layer: ::protobuf::SingularPtrField<SpatialCameraSetup>,
    pub render: ::protobuf::SingularPtrField<SpatialCameraSetup>,
    pub show_cloaked: ::std::option::Option<bool>,
    pub show_burrowed_shadows: ::std::option::Option<bool>,
    pub show_placeholders: ::std::option::Option<bool>,
    pub raw_affects_selection: ::std::option::Option<bool>,
    pub raw_crop_to_playable_area: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterfaceOptions {
    fn default() -> &'a InterfaceOptions {
        <InterfaceOptions as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceOptions {
    pub fn new() -> InterfaceOptions {
        ::std::default::Default::default()
    }

    // optional bool raw = 1;


    pub fn get_raw(&self) -> bool {
        self.raw.unwrap_or(false)
    }
    pub fn clear_raw(&mut self) {
        self.raw = ::std::option::Option::None;
    }

    pub fn has_raw(&self) -> bool {
        self.raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw(&mut self, v: bool) {
        self.raw = ::std::option::Option::Some(v);
    }

    // optional bool score = 2;


    pub fn get_score(&self) -> bool {
        self.score.unwrap_or(false)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: bool) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.SpatialCameraSetup feature_layer = 3;


    pub fn get_feature_layer(&self) -> &SpatialCameraSetup {
        self.feature_layer.as_ref().unwrap_or_else(|| <SpatialCameraSetup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feature_layer(&mut self) {
        self.feature_layer.clear();
    }

    pub fn has_feature_layer(&self) -> bool {
        self.feature_layer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feature_layer(&mut self, v: SpatialCameraSetup) {
        self.feature_layer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feature_layer(&mut self) -> &mut SpatialCameraSetup {
        if self.feature_layer.is_none() {
            self.feature_layer.set_default();
        }
        self.feature_layer.as_mut().unwrap()
    }

    // Take field
    pub fn take_feature_layer(&mut self) -> SpatialCameraSetup {
        self.feature_layer.take().unwrap_or_else(|| SpatialCameraSetup::new())
    }

    // optional .SC2APIProtocol.SpatialCameraSetup render = 4;


    pub fn get_render(&self) -> &SpatialCameraSetup {
        self.render.as_ref().unwrap_or_else(|| <SpatialCameraSetup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_render(&mut self) {
        self.render.clear();
    }

    pub fn has_render(&self) -> bool {
        self.render.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render(&mut self, v: SpatialCameraSetup) {
        self.render = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_render(&mut self) -> &mut SpatialCameraSetup {
        if self.render.is_none() {
            self.render.set_default();
        }
        self.render.as_mut().unwrap()
    }

    // Take field
    pub fn take_render(&mut self) -> SpatialCameraSetup {
        self.render.take().unwrap_or_else(|| SpatialCameraSetup::new())
    }

    // optional bool show_cloaked = 5;


    pub fn get_show_cloaked(&self) -> bool {
        self.show_cloaked.unwrap_or(false)
    }
    pub fn clear_show_cloaked(&mut self) {
        self.show_cloaked = ::std::option::Option::None;
    }

    pub fn has_show_cloaked(&self) -> bool {
        self.show_cloaked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_cloaked(&mut self, v: bool) {
        self.show_cloaked = ::std::option::Option::Some(v);
    }

    // optional bool show_burrowed_shadows = 9;


    pub fn get_show_burrowed_shadows(&self) -> bool {
        self.show_burrowed_shadows.unwrap_or(false)
    }
    pub fn clear_show_burrowed_shadows(&mut self) {
        self.show_burrowed_shadows = ::std::option::Option::None;
    }

    pub fn has_show_burrowed_shadows(&self) -> bool {
        self.show_burrowed_shadows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_burrowed_shadows(&mut self, v: bool) {
        self.show_burrowed_shadows = ::std::option::Option::Some(v);
    }

    // optional bool show_placeholders = 8;


    pub fn get_show_placeholders(&self) -> bool {
        self.show_placeholders.unwrap_or(false)
    }
    pub fn clear_show_placeholders(&mut self) {
        self.show_placeholders = ::std::option::Option::None;
    }

    pub fn has_show_placeholders(&self) -> bool {
        self.show_placeholders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_placeholders(&mut self, v: bool) {
        self.show_placeholders = ::std::option::Option::Some(v);
    }

    // optional bool raw_affects_selection = 6;


    pub fn get_raw_affects_selection(&self) -> bool {
        self.raw_affects_selection.unwrap_or(false)
    }
    pub fn clear_raw_affects_selection(&mut self) {
        self.raw_affects_selection = ::std::option::Option::None;
    }

    pub fn has_raw_affects_selection(&self) -> bool {
        self.raw_affects_selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_affects_selection(&mut self, v: bool) {
        self.raw_affects_selection = ::std::option::Option::Some(v);
    }

    // optional bool raw_crop_to_playable_area = 7;


    pub fn get_raw_crop_to_playable_area(&self) -> bool {
        self.raw_crop_to_playable_area.unwrap_or(false)
    }
    pub fn clear_raw_crop_to_playable_area(&mut self) {
        self.raw_crop_to_playable_area = ::std::option::Option::None;
    }

    pub fn has_raw_crop_to_playable_area(&self) -> bool {
        self.raw_crop_to_playable_area.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_crop_to_playable_area(&mut self, v: bool) {
        self.raw_crop_to_playable_area = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for InterfaceOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.feature_layer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.render {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.raw = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feature_layer)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.render)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_cloaked = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_burrowed_shadows = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_placeholders = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.raw_affects_selection = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.raw_crop_to_playable_area = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.raw {
            my_size += 2;
        }
        if let Some(v) = self.score {
            my_size += 2;
        }
        if let Some(ref v) = self.feature_layer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.render.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.show_cloaked {
            my_size += 2;
        }
        if let Some(v) = self.show_burrowed_shadows {
            my_size += 2;
        }
        if let Some(v) = self.show_placeholders {
            my_size += 2;
        }
        if let Some(v) = self.raw_affects_selection {
            my_size += 2;
        }
        if let Some(v) = self.raw_crop_to_playable_area {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.raw {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.feature_layer.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.render.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.show_cloaked {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.show_burrowed_shadows {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.show_placeholders {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.raw_affects_selection {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.raw_crop_to_playable_area {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterfaceOptions {
        InterfaceOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "raw",
                |m: &InterfaceOptions| { &m.raw },
                |m: &mut InterfaceOptions| { &mut m.raw },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "score",
                |m: &InterfaceOptions| { &m.score },
                |m: &mut InterfaceOptions| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialCameraSetup>>(
                "feature_layer",
                |m: &InterfaceOptions| { &m.feature_layer },
                |m: &mut InterfaceOptions| { &mut m.feature_layer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpatialCameraSetup>>(
                "render",
                |m: &InterfaceOptions| { &m.render },
                |m: &mut InterfaceOptions| { &mut m.render },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_cloaked",
                |m: &InterfaceOptions| { &m.show_cloaked },
                |m: &mut InterfaceOptions| { &mut m.show_cloaked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_burrowed_shadows",
                |m: &InterfaceOptions| { &m.show_burrowed_shadows },
                |m: &mut InterfaceOptions| { &mut m.show_burrowed_shadows },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_placeholders",
                |m: &InterfaceOptions| { &m.show_placeholders },
                |m: &mut InterfaceOptions| { &mut m.show_placeholders },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "raw_affects_selection",
                |m: &InterfaceOptions| { &m.raw_affects_selection },
                |m: &mut InterfaceOptions| { &mut m.raw_affects_selection },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "raw_crop_to_playable_area",
                |m: &InterfaceOptions| { &m.raw_crop_to_playable_area },
                |m: &mut InterfaceOptions| { &mut m.raw_crop_to_playable_area },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterfaceOptions>(
                "InterfaceOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterfaceOptions {
        static instance: ::protobuf::rt::LazyV2<InterfaceOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterfaceOptions::new)
    }
}

impl ::protobuf::Clear for InterfaceOptions {
    fn clear(&mut self) {
        self.raw = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.feature_layer.clear();
        self.render.clear();
        self.show_cloaked = ::std::option::Option::None;
        self.show_burrowed_shadows = ::std::option::Option::None;
        self.show_placeholders = ::std::option::Option::None;
        self.raw_affects_selection = ::std::option::Option::None;
        self.raw_crop_to_playable_area = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterfaceOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerInfo {
    // message fields
    pub player_id: ::std::option::Option<u32>,
    pub field_type: ::std::option::Option<PlayerType>,
    pub race_requested: ::std::option::Option<super::common::Race>,
    pub race_actual: ::std::option::Option<super::common::Race>,
    pub difficulty: ::std::option::Option<Difficulty>,
    pub ai_build: ::std::option::Option<AIBuild>,
    pub player_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerInfo {
    fn default() -> &'a PlayerInfo {
        <PlayerInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerInfo {
    pub fn new() -> PlayerInfo {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;


    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.PlayerType type = 2;


    pub fn get_field_type(&self) -> PlayerType {
        self.field_type.unwrap_or(PlayerType::Participant)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PlayerType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Race race_requested = 3;


    pub fn get_race_requested(&self) -> super::common::Race {
        self.race_requested.unwrap_or(super::common::Race::NoRace)
    }
    pub fn clear_race_requested(&mut self) {
        self.race_requested = ::std::option::Option::None;
    }

    pub fn has_race_requested(&self) -> bool {
        self.race_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race_requested(&mut self, v: super::common::Race) {
        self.race_requested = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Race race_actual = 4;


    pub fn get_race_actual(&self) -> super::common::Race {
        self.race_actual.unwrap_or(super::common::Race::NoRace)
    }
    pub fn clear_race_actual(&mut self) {
        self.race_actual = ::std::option::Option::None;
    }

    pub fn has_race_actual(&self) -> bool {
        self.race_actual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race_actual(&mut self, v: super::common::Race) {
        self.race_actual = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Difficulty difficulty = 5;


    pub fn get_difficulty(&self) -> Difficulty {
        self.difficulty.unwrap_or(Difficulty::VeryEasy)
    }
    pub fn clear_difficulty(&mut self) {
        self.difficulty = ::std::option::Option::None;
    }

    pub fn has_difficulty(&self) -> bool {
        self.difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: Difficulty) {
        self.difficulty = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.AIBuild ai_build = 7;


    pub fn get_ai_build(&self) -> AIBuild {
        self.ai_build.unwrap_or(AIBuild::RandomBuild)
    }
    pub fn clear_ai_build(&mut self) {
        self.ai_build = ::std::option::Option::None;
    }

    pub fn has_ai_build(&self) -> bool {
        self.ai_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ai_build(&mut self, v: AIBuild) {
        self.ai_build = ::std::option::Option::Some(v);
    }

    // optional string player_name = 6;


    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PlayerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.race_requested, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.race_actual, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.difficulty, 5, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.ai_build, 7, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.race_requested {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.race_actual {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.difficulty {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.ai_build {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.race_requested {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.race_actual {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.difficulty {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.ai_build {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerInfo {
        PlayerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_id",
                |m: &PlayerInfo| { &m.player_id },
                |m: &mut PlayerInfo| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PlayerType>>(
                "type",
                |m: &PlayerInfo| { &m.field_type },
                |m: &mut PlayerInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::Race>>(
                "race_requested",
                |m: &PlayerInfo| { &m.race_requested },
                |m: &mut PlayerInfo| { &mut m.race_requested },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::Race>>(
                "race_actual",
                |m: &PlayerInfo| { &m.race_actual },
                |m: &mut PlayerInfo| { &mut m.race_actual },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Difficulty>>(
                "difficulty",
                |m: &PlayerInfo| { &m.difficulty },
                |m: &mut PlayerInfo| { &mut m.difficulty },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AIBuild>>(
                "ai_build",
                |m: &PlayerInfo| { &m.ai_build },
                |m: &mut PlayerInfo| { &mut m.ai_build },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "player_name",
                |m: &PlayerInfo| { &m.player_name },
                |m: &mut PlayerInfo| { &mut m.player_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerInfo>(
                "PlayerInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerInfo {
        static instance: ::protobuf::rt::LazyV2<PlayerInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerInfo::new)
    }
}

impl ::protobuf::Clear for PlayerInfo {
    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.race_requested = ::std::option::Option::None;
        self.race_actual = ::std::option::Option::None;
        self.difficulty = ::std::option::Option::None;
        self.ai_build = ::std::option::Option::None;
        self.player_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerCommon {
    // message fields
    pub player_id: ::std::option::Option<u32>,
    pub minerals: ::std::option::Option<u32>,
    pub vespene: ::std::option::Option<u32>,
    pub food_cap: ::std::option::Option<u32>,
    pub food_used: ::std::option::Option<u32>,
    pub food_army: ::std::option::Option<u32>,
    pub food_workers: ::std::option::Option<u32>,
    pub idle_worker_count: ::std::option::Option<u32>,
    pub army_count: ::std::option::Option<u32>,
    pub warp_gate_count: ::std::option::Option<u32>,
    pub larva_count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerCommon {
    fn default() -> &'a PlayerCommon {
        <PlayerCommon as ::protobuf::Message>::default_instance()
    }
}

impl PlayerCommon {
    pub fn new() -> PlayerCommon {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;


    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 minerals = 2;


    pub fn get_minerals(&self) -> u32 {
        self.minerals.unwrap_or(0)
    }
    pub fn clear_minerals(&mut self) {
        self.minerals = ::std::option::Option::None;
    }

    pub fn has_minerals(&self) -> bool {
        self.minerals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minerals(&mut self, v: u32) {
        self.minerals = ::std::option::Option::Some(v);
    }

    // optional uint32 vespene = 3;


    pub fn get_vespene(&self) -> u32 {
        self.vespene.unwrap_or(0)
    }
    pub fn clear_vespene(&mut self) {
        self.vespene = ::std::option::Option::None;
    }

    pub fn has_vespene(&self) -> bool {
        self.vespene.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vespene(&mut self, v: u32) {
        self.vespene = ::std::option::Option::Some(v);
    }

    // optional uint32 food_cap = 4;


    pub fn get_food_cap(&self) -> u32 {
        self.food_cap.unwrap_or(0)
    }
    pub fn clear_food_cap(&mut self) {
        self.food_cap = ::std::option::Option::None;
    }

    pub fn has_food_cap(&self) -> bool {
        self.food_cap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_cap(&mut self, v: u32) {
        self.food_cap = ::std::option::Option::Some(v);
    }

    // optional uint32 food_used = 5;


    pub fn get_food_used(&self) -> u32 {
        self.food_used.unwrap_or(0)
    }
    pub fn clear_food_used(&mut self) {
        self.food_used = ::std::option::Option::None;
    }

    pub fn has_food_used(&self) -> bool {
        self.food_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_used(&mut self, v: u32) {
        self.food_used = ::std::option::Option::Some(v);
    }

    // optional uint32 food_army = 6;


    pub fn get_food_army(&self) -> u32 {
        self.food_army.unwrap_or(0)
    }
    pub fn clear_food_army(&mut self) {
        self.food_army = ::std::option::Option::None;
    }

    pub fn has_food_army(&self) -> bool {
        self.food_army.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_army(&mut self, v: u32) {
        self.food_army = ::std::option::Option::Some(v);
    }

    // optional uint32 food_workers = 7;


    pub fn get_food_workers(&self) -> u32 {
        self.food_workers.unwrap_or(0)
    }
    pub fn clear_food_workers(&mut self) {
        self.food_workers = ::std::option::Option::None;
    }

    pub fn has_food_workers(&self) -> bool {
        self.food_workers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_workers(&mut self, v: u32) {
        self.food_workers = ::std::option::Option::Some(v);
    }

    // optional uint32 idle_worker_count = 8;


    pub fn get_idle_worker_count(&self) -> u32 {
        self.idle_worker_count.unwrap_or(0)
    }
    pub fn clear_idle_worker_count(&mut self) {
        self.idle_worker_count = ::std::option::Option::None;
    }

    pub fn has_idle_worker_count(&self) -> bool {
        self.idle_worker_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_worker_count(&mut self, v: u32) {
        self.idle_worker_count = ::std::option::Option::Some(v);
    }

    // optional uint32 army_count = 9;


    pub fn get_army_count(&self) -> u32 {
        self.army_count.unwrap_or(0)
    }
    pub fn clear_army_count(&mut self) {
        self.army_count = ::std::option::Option::None;
    }

    pub fn has_army_count(&self) -> bool {
        self.army_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_army_count(&mut self, v: u32) {
        self.army_count = ::std::option::Option::Some(v);
    }

    // optional uint32 warp_gate_count = 10;


    pub fn get_warp_gate_count(&self) -> u32 {
        self.warp_gate_count.unwrap_or(0)
    }
    pub fn clear_warp_gate_count(&mut self) {
        self.warp_gate_count = ::std::option::Option::None;
    }

    pub fn has_warp_gate_count(&self) -> bool {
        self.warp_gate_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warp_gate_count(&mut self, v: u32) {
        self.warp_gate_count = ::std::option::Option::Some(v);
    }

    // optional uint32 larva_count = 11;


    pub fn get_larva_count(&self) -> u32 {
        self.larva_count.unwrap_or(0)
    }
    pub fn clear_larva_count(&mut self) {
        self.larva_count = ::std::option::Option::None;
    }

    pub fn has_larva_count(&self) -> bool {
        self.larva_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_larva_count(&mut self, v: u32) {
        self.larva_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerCommon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minerals = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vespene = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.food_cap = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.food_used = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.food_army = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.food_workers = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.idle_worker_count = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.army_count = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.warp_gate_count = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.larva_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minerals {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vespene {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.food_cap {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.food_used {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.food_army {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.food_workers {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.idle_worker_count {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.army_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.warp_gate_count {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.larva_count {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.minerals {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.vespene {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.food_cap {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.food_used {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.food_army {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.food_workers {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.idle_worker_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.army_count {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.warp_gate_count {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.larva_count {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerCommon {
        PlayerCommon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_id",
                |m: &PlayerCommon| { &m.player_id },
                |m: &mut PlayerCommon| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minerals",
                |m: &PlayerCommon| { &m.minerals },
                |m: &mut PlayerCommon| { &mut m.minerals },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vespene",
                |m: &PlayerCommon| { &m.vespene },
                |m: &mut PlayerCommon| { &mut m.vespene },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "food_cap",
                |m: &PlayerCommon| { &m.food_cap },
                |m: &mut PlayerCommon| { &mut m.food_cap },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "food_used",
                |m: &PlayerCommon| { &m.food_used },
                |m: &mut PlayerCommon| { &mut m.food_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "food_army",
                |m: &PlayerCommon| { &m.food_army },
                |m: &mut PlayerCommon| { &mut m.food_army },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "food_workers",
                |m: &PlayerCommon| { &m.food_workers },
                |m: &mut PlayerCommon| { &mut m.food_workers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "idle_worker_count",
                |m: &PlayerCommon| { &m.idle_worker_count },
                |m: &mut PlayerCommon| { &mut m.idle_worker_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "army_count",
                |m: &PlayerCommon| { &m.army_count },
                |m: &mut PlayerCommon| { &mut m.army_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "warp_gate_count",
                |m: &PlayerCommon| { &m.warp_gate_count },
                |m: &mut PlayerCommon| { &mut m.warp_gate_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "larva_count",
                |m: &PlayerCommon| { &m.larva_count },
                |m: &mut PlayerCommon| { &mut m.larva_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerCommon>(
                "PlayerCommon",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerCommon {
        static instance: ::protobuf::rt::LazyV2<PlayerCommon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerCommon::new)
    }
}

impl ::protobuf::Clear for PlayerCommon {
    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.minerals = ::std::option::Option::None;
        self.vespene = ::std::option::Option::None;
        self.food_cap = ::std::option::Option::None;
        self.food_used = ::std::option::Option::None;
        self.food_army = ::std::option::Option::None;
        self.food_workers = ::std::option::Option::None;
        self.idle_worker_count = ::std::option::Option::None;
        self.army_count = ::std::option::Option::None;
        self.warp_gate_count = ::std::option::Option::None;
        self.larva_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerCommon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Observation {
    // message fields
    pub game_loop: ::std::option::Option<u32>,
    pub player_common: ::protobuf::SingularPtrField<PlayerCommon>,
    pub alerts: ::std::vec::Vec<Alert>,
    pub abilities: ::protobuf::RepeatedField<super::common::AvailableAbility>,
    pub score: ::protobuf::SingularPtrField<super::score::Score>,
    pub raw_data: ::protobuf::SingularPtrField<super::raw::ObservationRaw>,
    pub feature_layer_data: ::protobuf::SingularPtrField<super::spatial::ObservationFeatureLayer>,
    pub render_data: ::protobuf::SingularPtrField<super::spatial::ObservationRender>,
    pub ui_data: ::protobuf::SingularPtrField<super::ui::ObservationUI>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Observation {
    fn default() -> &'a Observation {
        <Observation as ::protobuf::Message>::default_instance()
    }
}

impl Observation {
    pub fn new() -> Observation {
        ::std::default::Default::default()
    }

    // optional uint32 game_loop = 9;


    pub fn get_game_loop(&self) -> u32 {
        self.game_loop.unwrap_or(0)
    }
    pub fn clear_game_loop(&mut self) {
        self.game_loop = ::std::option::Option::None;
    }

    pub fn has_game_loop(&self) -> bool {
        self.game_loop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_loop(&mut self, v: u32) {
        self.game_loop = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.PlayerCommon player_common = 1;


    pub fn get_player_common(&self) -> &PlayerCommon {
        self.player_common.as_ref().unwrap_or_else(|| <PlayerCommon as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_common(&mut self) {
        self.player_common.clear();
    }

    pub fn has_player_common(&self) -> bool {
        self.player_common.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_common(&mut self, v: PlayerCommon) {
        self.player_common = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_common(&mut self) -> &mut PlayerCommon {
        if self.player_common.is_none() {
            self.player_common.set_default();
        }
        self.player_common.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_common(&mut self) -> PlayerCommon {
        self.player_common.take().unwrap_or_else(|| PlayerCommon::new())
    }

    // repeated .SC2APIProtocol.Alert alerts = 10;


    pub fn get_alerts(&self) -> &[Alert] {
        &self.alerts
    }
    pub fn clear_alerts(&mut self) {
        self.alerts.clear();
    }

    // Param is passed by value, moved
    pub fn set_alerts(&mut self, v: ::std::vec::Vec<Alert>) {
        self.alerts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alerts(&mut self) -> &mut ::std::vec::Vec<Alert> {
        &mut self.alerts
    }

    // Take field
    pub fn take_alerts(&mut self) -> ::std::vec::Vec<Alert> {
        ::std::mem::replace(&mut self.alerts, ::std::vec::Vec::new())
    }

    // repeated .SC2APIProtocol.AvailableAbility abilities = 3;


    pub fn get_abilities(&self) -> &[super::common::AvailableAbility] {
        &self.abilities
    }
    pub fn clear_abilities(&mut self) {
        self.abilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_abilities(&mut self, v: ::protobuf::RepeatedField<super::common::AvailableAbility>) {
        self.abilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abilities(&mut self) -> &mut ::protobuf::RepeatedField<super::common::AvailableAbility> {
        &mut self.abilities
    }

    // Take field
    pub fn take_abilities(&mut self) -> ::protobuf::RepeatedField<super::common::AvailableAbility> {
        ::std::mem::replace(&mut self.abilities, ::protobuf::RepeatedField::new())
    }

    // optional .SC2APIProtocol.Score score = 4;


    pub fn get_score(&self) -> &super::score::Score {
        self.score.as_ref().unwrap_or_else(|| <super::score::Score as ::protobuf::Message>::default_instance())
    }
    pub fn clear_score(&mut self) {
        self.score.clear();
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: super::score::Score) {
        self.score = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_score(&mut self) -> &mut super::score::Score {
        if self.score.is_none() {
            self.score.set_default();
        }
        self.score.as_mut().unwrap()
    }

    // Take field
    pub fn take_score(&mut self) -> super::score::Score {
        self.score.take().unwrap_or_else(|| super::score::Score::new())
    }

    // optional .SC2APIProtocol.ObservationRaw raw_data = 5;


    pub fn get_raw_data(&self) -> &super::raw::ObservationRaw {
        self.raw_data.as_ref().unwrap_or_else(|| <super::raw::ObservationRaw as ::protobuf::Message>::default_instance())
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: super::raw::ObservationRaw) {
        self.raw_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut super::raw::ObservationRaw {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> super::raw::ObservationRaw {
        self.raw_data.take().unwrap_or_else(|| super::raw::ObservationRaw::new())
    }

    // optional .SC2APIProtocol.ObservationFeatureLayer feature_layer_data = 6;


    pub fn get_feature_layer_data(&self) -> &super::spatial::ObservationFeatureLayer {
        self.feature_layer_data.as_ref().unwrap_or_else(|| <super::spatial::ObservationFeatureLayer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_feature_layer_data(&mut self) {
        self.feature_layer_data.clear();
    }

    pub fn has_feature_layer_data(&self) -> bool {
        self.feature_layer_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feature_layer_data(&mut self, v: super::spatial::ObservationFeatureLayer) {
        self.feature_layer_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feature_layer_data(&mut self) -> &mut super::spatial::ObservationFeatureLayer {
        if self.feature_layer_data.is_none() {
            self.feature_layer_data.set_default();
        }
        self.feature_layer_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_feature_layer_data(&mut self) -> super::spatial::ObservationFeatureLayer {
        self.feature_layer_data.take().unwrap_or_else(|| super::spatial::ObservationFeatureLayer::new())
    }

    // optional .SC2APIProtocol.ObservationRender render_data = 7;


    pub fn get_render_data(&self) -> &super::spatial::ObservationRender {
        self.render_data.as_ref().unwrap_or_else(|| <super::spatial::ObservationRender as ::protobuf::Message>::default_instance())
    }
    pub fn clear_render_data(&mut self) {
        self.render_data.clear();
    }

    pub fn has_render_data(&self) -> bool {
        self.render_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_render_data(&mut self, v: super::spatial::ObservationRender) {
        self.render_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_render_data(&mut self) -> &mut super::spatial::ObservationRender {
        if self.render_data.is_none() {
            self.render_data.set_default();
        }
        self.render_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_render_data(&mut self) -> super::spatial::ObservationRender {
        self.render_data.take().unwrap_or_else(|| super::spatial::ObservationRender::new())
    }

    // optional .SC2APIProtocol.ObservationUI ui_data = 8;


    pub fn get_ui_data(&self) -> &super::ui::ObservationUI {
        self.ui_data.as_ref().unwrap_or_else(|| <super::ui::ObservationUI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ui_data(&mut self) {
        self.ui_data.clear();
    }

    pub fn has_ui_data(&self) -> bool {
        self.ui_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_data(&mut self, v: super::ui::ObservationUI) {
        self.ui_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ui_data(&mut self) -> &mut super::ui::ObservationUI {
        if self.ui_data.is_none() {
            self.ui_data.set_default();
        }
        self.ui_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_ui_data(&mut self) -> super::ui::ObservationUI {
        self.ui_data.take().unwrap_or_else(|| super::ui::ObservationUI::new())
    }
}

impl ::protobuf::Message for Observation {
    fn is_initialized(&self) -> bool {
        for v in &self.player_common {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.abilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.score {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.raw_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.feature_layer_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.render_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ui_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_loop = ::std::option::Option::Some(tmp);
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_common)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.alerts, 10, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.abilities)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.score)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feature_layer_data)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.render_data)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ui_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_loop {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.alerts {
            my_size += ::protobuf::rt::enum_size(10, *value);
        };
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.score.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.feature_layer_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.render_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ui_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_loop {
            os.write_uint32(9, v)?;
        }
        if let Some(ref v) = self.player_common.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.alerts {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.abilities {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.score.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.feature_layer_data.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.render_data.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ui_data.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Observation {
        Observation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_loop",
                |m: &Observation| { &m.game_loop },
                |m: &mut Observation| { &mut m.game_loop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerCommon>>(
                "player_common",
                |m: &Observation| { &m.player_common },
                |m: &mut Observation| { &mut m.player_common },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Alert>>(
                "alerts",
                |m: &Observation| { &m.alerts },
                |m: &mut Observation| { &mut m.alerts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::AvailableAbility>>(
                "abilities",
                |m: &Observation| { &m.abilities },
                |m: &mut Observation| { &mut m.abilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::score::Score>>(
                "score",
                |m: &Observation| { &m.score },
                |m: &mut Observation| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::raw::ObservationRaw>>(
                "raw_data",
                |m: &Observation| { &m.raw_data },
                |m: &mut Observation| { &mut m.raw_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::spatial::ObservationFeatureLayer>>(
                "feature_layer_data",
                |m: &Observation| { &m.feature_layer_data },
                |m: &mut Observation| { &mut m.feature_layer_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::spatial::ObservationRender>>(
                "render_data",
                |m: &Observation| { &m.render_data },
                |m: &mut Observation| { &mut m.render_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::ui::ObservationUI>>(
                "ui_data",
                |m: &Observation| { &m.ui_data },
                |m: &mut Observation| { &mut m.ui_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Observation>(
                "Observation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Observation {
        static instance: ::protobuf::rt::LazyV2<Observation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Observation::new)
    }
}

impl ::protobuf::Clear for Observation {
    fn clear(&mut self) {
        self.game_loop = ::std::option::Option::None;
        self.player_common.clear();
        self.alerts.clear();
        self.abilities.clear();
        self.score.clear();
        self.raw_data.clear();
        self.feature_layer_data.clear();
        self.render_data.clear();
        self.ui_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Observation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Observation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Action {
    // message fields
    pub action_raw: ::protobuf::SingularPtrField<super::raw::ActionRaw>,
    pub action_feature_layer: ::protobuf::SingularPtrField<super::spatial::ActionSpatial>,
    pub action_render: ::protobuf::SingularPtrField<super::spatial::ActionSpatial>,
    pub action_ui: ::protobuf::SingularPtrField<super::ui::ActionUI>,
    pub action_chat: ::protobuf::SingularPtrField<ActionChat>,
    pub game_loop: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Action {
    fn default() -> &'a Action {
        <Action as ::protobuf::Message>::default_instance()
    }
}

impl Action {
    pub fn new() -> Action {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionRaw action_raw = 1;


    pub fn get_action_raw(&self) -> &super::raw::ActionRaw {
        self.action_raw.as_ref().unwrap_or_else(|| <super::raw::ActionRaw as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action_raw(&mut self) {
        self.action_raw.clear();
    }

    pub fn has_action_raw(&self) -> bool {
        self.action_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_raw(&mut self, v: super::raw::ActionRaw) {
        self.action_raw = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_raw(&mut self) -> &mut super::raw::ActionRaw {
        if self.action_raw.is_none() {
            self.action_raw.set_default();
        }
        self.action_raw.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_raw(&mut self) -> super::raw::ActionRaw {
        self.action_raw.take().unwrap_or_else(|| super::raw::ActionRaw::new())
    }

    // optional .SC2APIProtocol.ActionSpatial action_feature_layer = 2;


    pub fn get_action_feature_layer(&self) -> &super::spatial::ActionSpatial {
        self.action_feature_layer.as_ref().unwrap_or_else(|| <super::spatial::ActionSpatial as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action_feature_layer(&mut self) {
        self.action_feature_layer.clear();
    }

    pub fn has_action_feature_layer(&self) -> bool {
        self.action_feature_layer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_feature_layer(&mut self, v: super::spatial::ActionSpatial) {
        self.action_feature_layer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_feature_layer(&mut self) -> &mut super::spatial::ActionSpatial {
        if self.action_feature_layer.is_none() {
            self.action_feature_layer.set_default();
        }
        self.action_feature_layer.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_feature_layer(&mut self) -> super::spatial::ActionSpatial {
        self.action_feature_layer.take().unwrap_or_else(|| super::spatial::ActionSpatial::new())
    }

    // optional .SC2APIProtocol.ActionSpatial action_render = 3;


    pub fn get_action_render(&self) -> &super::spatial::ActionSpatial {
        self.action_render.as_ref().unwrap_or_else(|| <super::spatial::ActionSpatial as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action_render(&mut self) {
        self.action_render.clear();
    }

    pub fn has_action_render(&self) -> bool {
        self.action_render.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_render(&mut self, v: super::spatial::ActionSpatial) {
        self.action_render = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_render(&mut self) -> &mut super::spatial::ActionSpatial {
        if self.action_render.is_none() {
            self.action_render.set_default();
        }
        self.action_render.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_render(&mut self) -> super::spatial::ActionSpatial {
        self.action_render.take().unwrap_or_else(|| super::spatial::ActionSpatial::new())
    }

    // optional .SC2APIProtocol.ActionUI action_ui = 4;


    pub fn get_action_ui(&self) -> &super::ui::ActionUI {
        self.action_ui.as_ref().unwrap_or_else(|| <super::ui::ActionUI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action_ui(&mut self) {
        self.action_ui.clear();
    }

    pub fn has_action_ui(&self) -> bool {
        self.action_ui.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_ui(&mut self, v: super::ui::ActionUI) {
        self.action_ui = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_ui(&mut self) -> &mut super::ui::ActionUI {
        if self.action_ui.is_none() {
            self.action_ui.set_default();
        }
        self.action_ui.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_ui(&mut self) -> super::ui::ActionUI {
        self.action_ui.take().unwrap_or_else(|| super::ui::ActionUI::new())
    }

    // optional .SC2APIProtocol.ActionChat action_chat = 6;


    pub fn get_action_chat(&self) -> &ActionChat {
        self.action_chat.as_ref().unwrap_or_else(|| <ActionChat as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action_chat(&mut self) {
        self.action_chat.clear();
    }

    pub fn has_action_chat(&self) -> bool {
        self.action_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_chat(&mut self, v: ActionChat) {
        self.action_chat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_chat(&mut self) -> &mut ActionChat {
        if self.action_chat.is_none() {
            self.action_chat.set_default();
        }
        self.action_chat.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_chat(&mut self) -> ActionChat {
        self.action_chat.take().unwrap_or_else(|| ActionChat::new())
    }

    // optional uint32 game_loop = 7;


    pub fn get_game_loop(&self) -> u32 {
        self.game_loop.unwrap_or(0)
    }
    pub fn clear_game_loop(&mut self) {
        self.game_loop = ::std::option::Option::None;
    }

    pub fn has_game_loop(&self) -> bool {
        self.game_loop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_loop(&mut self, v: u32) {
        self.game_loop = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Action {
    fn is_initialized(&self) -> bool {
        for v in &self.action_raw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_feature_layer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_render {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_ui {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_chat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action_raw)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action_feature_layer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action_render)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action_ui)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action_chat)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_loop = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.action_raw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.action_feature_layer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.action_render.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.action_ui.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.action_chat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.game_loop {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.action_raw.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.action_feature_layer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.action_render.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.action_ui.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.action_chat.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.game_loop {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Action {
        Action::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::raw::ActionRaw>>(
                "action_raw",
                |m: &Action| { &m.action_raw },
                |m: &mut Action| { &mut m.action_raw },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::spatial::ActionSpatial>>(
                "action_feature_layer",
                |m: &Action| { &m.action_feature_layer },
                |m: &mut Action| { &mut m.action_feature_layer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::spatial::ActionSpatial>>(
                "action_render",
                |m: &Action| { &m.action_render },
                |m: &mut Action| { &mut m.action_render },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::ui::ActionUI>>(
                "action_ui",
                |m: &Action| { &m.action_ui },
                |m: &mut Action| { &mut m.action_ui },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActionChat>>(
                "action_chat",
                |m: &Action| { &m.action_chat },
                |m: &mut Action| { &mut m.action_chat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_loop",
                |m: &Action| { &m.game_loop },
                |m: &mut Action| { &mut m.game_loop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Action>(
                "Action",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Action {
        static instance: ::protobuf::rt::LazyV2<Action> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Action::new)
    }
}

impl ::protobuf::Clear for Action {
    fn clear(&mut self) {
        self.action_raw.clear();
        self.action_feature_layer.clear();
        self.action_render.clear();
        self.action_ui.clear();
        self.action_chat.clear();
        self.game_loop = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionChat {
    // message fields
    pub channel: ::std::option::Option<ActionChat_Channel>,
    pub message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionChat {
    fn default() -> &'a ActionChat {
        <ActionChat as ::protobuf::Message>::default_instance()
    }
}

impl ActionChat {
    pub fn new() -> ActionChat {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionChat.Channel channel = 1;


    pub fn get_channel(&self) -> ActionChat_Channel {
        self.channel.unwrap_or(ActionChat_Channel::Broadcast)
    }
    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: ActionChat_Channel) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ActionChat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.channel, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionChat {
        ActionChat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionChat_Channel>>(
                "channel",
                |m: &ActionChat| { &m.channel },
                |m: &mut ActionChat| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ActionChat| { &m.message },
                |m: &mut ActionChat| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionChat>(
                "ActionChat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionChat {
        static instance: ::protobuf::rt::LazyV2<ActionChat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionChat::new)
    }
}

impl ::protobuf::Clear for ActionChat {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionChat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionChat_Channel {
    Broadcast = 1,
    Team = 2,
}

impl ::protobuf::ProtobufEnum for ActionChat_Channel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionChat_Channel> {
        match value {
            1 => ::std::option::Option::Some(ActionChat_Channel::Broadcast),
            2 => ::std::option::Option::Some(ActionChat_Channel::Team),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionChat_Channel] = &[
            ActionChat_Channel::Broadcast,
            ActionChat_Channel::Team,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ActionChat_Channel>("ActionChat.Channel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ActionChat_Channel {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ActionChat_Channel {
    fn default() -> Self {
        ActionChat_Channel::Broadcast
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionChat_Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionError {
    // message fields
    pub unit_tag: ::std::option::Option<u64>,
    pub ability_id: ::std::option::Option<u64>,
    pub result: ::std::option::Option<super::error::ActionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionError {
    fn default() -> &'a ActionError {
        <ActionError as ::protobuf::Message>::default_instance()
    }
}

impl ActionError {
    pub fn new() -> ActionError {
        ::std::default::Default::default()
    }

    // optional uint64 unit_tag = 1;


    pub fn get_unit_tag(&self) -> u64 {
        self.unit_tag.unwrap_or(0)
    }
    pub fn clear_unit_tag(&mut self) {
        self.unit_tag = ::std::option::Option::None;
    }

    pub fn has_unit_tag(&self) -> bool {
        self.unit_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_tag(&mut self, v: u64) {
        self.unit_tag = ::std::option::Option::Some(v);
    }

    // optional uint64 ability_id = 2;


    pub fn get_ability_id(&self) -> u64 {
        self.ability_id.unwrap_or(0)
    }
    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u64) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.ActionResult result = 3;


    pub fn get_result(&self) -> super::error::ActionResult {
        self.result.unwrap_or(super::error::ActionResult::Success)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::error::ActionResult) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.unit_tag = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit_tag {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit_tag {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionError {
        ActionError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "unit_tag",
                |m: &ActionError| { &m.unit_tag },
                |m: &mut ActionError| { &mut m.unit_tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ability_id",
                |m: &ActionError| { &m.ability_id },
                |m: &mut ActionError| { &mut m.ability_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::error::ActionResult>>(
                "result",
                |m: &ActionError| { &m.result },
                |m: &mut ActionError| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionError>(
                "ActionError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionError {
        static instance: ::protobuf::rt::LazyV2<ActionError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionError::new)
    }
}

impl ::protobuf::Clear for ActionError {
    fn clear(&mut self) {
        self.unit_tag = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObserverAction {
    // message oneof groups
    pub action: ::std::option::Option<ObserverAction_oneof_action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObserverAction {
    fn default() -> &'a ObserverAction {
        <ObserverAction as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ObserverAction_oneof_action {
    player_perspective(ActionObserverPlayerPerspective),
    camera_move(ActionObserverCameraMove),
    camera_follow_player(ActionObserverCameraFollowPlayer),
    camera_follow_units(ActionObserverCameraFollowUnits),
}

impl ObserverAction {
    pub fn new() -> ObserverAction {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionObserverPlayerPerspective player_perspective = 1;


    pub fn get_player_perspective(&self) -> &ActionObserverPlayerPerspective {
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::player_perspective(ref v)) => v,
            _ => <ActionObserverPlayerPerspective as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_player_perspective(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_player_perspective(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::player_perspective(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_player_perspective(&mut self, v: ActionObserverPlayerPerspective) {
        self.action = ::std::option::Option::Some(ObserverAction_oneof_action::player_perspective(v))
    }

    // Mutable pointer to the field.
    pub fn mut_player_perspective(&mut self) -> &mut ActionObserverPlayerPerspective {
        if let ::std::option::Option::Some(ObserverAction_oneof_action::player_perspective(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ObserverAction_oneof_action::player_perspective(ActionObserverPlayerPerspective::new()));
        }
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::player_perspective(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_player_perspective(&mut self) -> ActionObserverPlayerPerspective {
        if self.has_player_perspective() {
            match self.action.take() {
                ::std::option::Option::Some(ObserverAction_oneof_action::player_perspective(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionObserverPlayerPerspective::new()
        }
    }

    // optional .SC2APIProtocol.ActionObserverCameraMove camera_move = 2;


    pub fn get_camera_move(&self) -> &ActionObserverCameraMove {
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_move(ref v)) => v,
            _ => <ActionObserverCameraMove as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_camera_move(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_move(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_move(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_move(&mut self, v: ActionObserverCameraMove) {
        self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_move(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_move(&mut self) -> &mut ActionObserverCameraMove {
        if let ::std::option::Option::Some(ObserverAction_oneof_action::camera_move(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_move(ActionObserverCameraMove::new()));
        }
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_move(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_move(&mut self) -> ActionObserverCameraMove {
        if self.has_camera_move() {
            match self.action.take() {
                ::std::option::Option::Some(ObserverAction_oneof_action::camera_move(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionObserverCameraMove::new()
        }
    }

    // optional .SC2APIProtocol.ActionObserverCameraFollowPlayer camera_follow_player = 3;


    pub fn get_camera_follow_player(&self) -> &ActionObserverCameraFollowPlayer {
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_player(ref v)) => v,
            _ => <ActionObserverCameraFollowPlayer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_camera_follow_player(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_follow_player(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_player(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_follow_player(&mut self, v: ActionObserverCameraFollowPlayer) {
        self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_player(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_follow_player(&mut self) -> &mut ActionObserverCameraFollowPlayer {
        if let ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_player(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_player(ActionObserverCameraFollowPlayer::new()));
        }
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_player(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_follow_player(&mut self) -> ActionObserverCameraFollowPlayer {
        if self.has_camera_follow_player() {
            match self.action.take() {
                ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_player(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionObserverCameraFollowPlayer::new()
        }
    }

    // optional .SC2APIProtocol.ActionObserverCameraFollowUnits camera_follow_units = 4;


    pub fn get_camera_follow_units(&self) -> &ActionObserverCameraFollowUnits {
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_units(ref v)) => v,
            _ => <ActionObserverCameraFollowUnits as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_camera_follow_units(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_follow_units(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_units(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_follow_units(&mut self, v: ActionObserverCameraFollowUnits) {
        self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_units(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_follow_units(&mut self) -> &mut ActionObserverCameraFollowUnits {
        if let ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_units(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_units(ActionObserverCameraFollowUnits::new()));
        }
        match self.action {
            ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_units(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_follow_units(&mut self) -> ActionObserverCameraFollowUnits {
        if self.has_camera_follow_units() {
            match self.action.take() {
                ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_units(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionObserverCameraFollowUnits::new()
        }
    }
}

impl ::protobuf::Message for ObserverAction {
    fn is_initialized(&self) -> bool {
        if let Some(ObserverAction_oneof_action::player_perspective(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ObserverAction_oneof_action::camera_move(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ObserverAction_oneof_action::camera_follow_player(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ObserverAction_oneof_action::camera_follow_units(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ObserverAction_oneof_action::player_perspective(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_move(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_player(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(ObserverAction_oneof_action::camera_follow_units(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &ObserverAction_oneof_action::player_perspective(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ObserverAction_oneof_action::camera_move(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ObserverAction_oneof_action::camera_follow_player(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ObserverAction_oneof_action::camera_follow_units(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &ObserverAction_oneof_action::player_perspective(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ObserverAction_oneof_action::camera_move(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ObserverAction_oneof_action::camera_follow_player(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ObserverAction_oneof_action::camera_follow_units(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObserverAction {
        ObserverAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionObserverPlayerPerspective>(
                "player_perspective",
                ObserverAction::has_player_perspective,
                ObserverAction::get_player_perspective,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionObserverCameraMove>(
                "camera_move",
                ObserverAction::has_camera_move,
                ObserverAction::get_camera_move,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionObserverCameraFollowPlayer>(
                "camera_follow_player",
                ObserverAction::has_camera_follow_player,
                ObserverAction::get_camera_follow_player,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActionObserverCameraFollowUnits>(
                "camera_follow_units",
                ObserverAction::has_camera_follow_units,
                ObserverAction::get_camera_follow_units,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObserverAction>(
                "ObserverAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObserverAction {
        static instance: ::protobuf::rt::LazyV2<ObserverAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObserverAction::new)
    }
}

impl ::protobuf::Clear for ObserverAction {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObserverAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObserverAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionObserverPlayerPerspective {
    // message fields
    pub player_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionObserverPlayerPerspective {
    fn default() -> &'a ActionObserverPlayerPerspective {
        <ActionObserverPlayerPerspective as ::protobuf::Message>::default_instance()
    }
}

impl ActionObserverPlayerPerspective {
    pub fn new() -> ActionObserverPlayerPerspective {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;


    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionObserverPlayerPerspective {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionObserverPlayerPerspective {
        ActionObserverPlayerPerspective::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_id",
                |m: &ActionObserverPlayerPerspective| { &m.player_id },
                |m: &mut ActionObserverPlayerPerspective| { &mut m.player_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionObserverPlayerPerspective>(
                "ActionObserverPlayerPerspective",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionObserverPlayerPerspective {
        static instance: ::protobuf::rt::LazyV2<ActionObserverPlayerPerspective> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionObserverPlayerPerspective::new)
    }
}

impl ::protobuf::Clear for ActionObserverPlayerPerspective {
    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionObserverPlayerPerspective {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionObserverPlayerPerspective {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionObserverCameraMove {
    // message fields
    pub world_pos: ::protobuf::SingularPtrField<super::common::Point2D>,
    pub distance: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionObserverCameraMove {
    fn default() -> &'a ActionObserverCameraMove {
        <ActionObserverCameraMove as ::protobuf::Message>::default_instance()
    }
}

impl ActionObserverCameraMove {
    pub fn new() -> ActionObserverCameraMove {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Point2D world_pos = 1;


    pub fn get_world_pos(&self) -> &super::common::Point2D {
        self.world_pos.as_ref().unwrap_or_else(|| <super::common::Point2D as ::protobuf::Message>::default_instance())
    }
    pub fn clear_world_pos(&mut self) {
        self.world_pos.clear();
    }

    pub fn has_world_pos(&self) -> bool {
        self.world_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_pos(&mut self, v: super::common::Point2D) {
        self.world_pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_pos(&mut self) -> &mut super::common::Point2D {
        if self.world_pos.is_none() {
            self.world_pos.set_default();
        }
        self.world_pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_world_pos(&mut self) -> super::common::Point2D {
        self.world_pos.take().unwrap_or_else(|| super::common::Point2D::new())
    }

    // optional float distance = 2;


    pub fn get_distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }
    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionObserverCameraMove {
    fn is_initialized(&self) -> bool {
        for v in &self.world_pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.world_pos)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.distance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.distance {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.world_pos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.distance {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionObserverCameraMove {
        ActionObserverCameraMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Point2D>>(
                "world_pos",
                |m: &ActionObserverCameraMove| { &m.world_pos },
                |m: &mut ActionObserverCameraMove| { &mut m.world_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "distance",
                |m: &ActionObserverCameraMove| { &m.distance },
                |m: &mut ActionObserverCameraMove| { &mut m.distance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionObserverCameraMove>(
                "ActionObserverCameraMove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionObserverCameraMove {
        static instance: ::protobuf::rt::LazyV2<ActionObserverCameraMove> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionObserverCameraMove::new)
    }
}

impl ::protobuf::Clear for ActionObserverCameraMove {
    fn clear(&mut self) {
        self.world_pos.clear();
        self.distance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionObserverCameraMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionObserverCameraMove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionObserverCameraFollowPlayer {
    // message fields
    pub player_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionObserverCameraFollowPlayer {
    fn default() -> &'a ActionObserverCameraFollowPlayer {
        <ActionObserverCameraFollowPlayer as ::protobuf::Message>::default_instance()
    }
}

impl ActionObserverCameraFollowPlayer {
    pub fn new() -> ActionObserverCameraFollowPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;


    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ActionObserverCameraFollowPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionObserverCameraFollowPlayer {
        ActionObserverCameraFollowPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_id",
                |m: &ActionObserverCameraFollowPlayer| { &m.player_id },
                |m: &mut ActionObserverCameraFollowPlayer| { &mut m.player_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionObserverCameraFollowPlayer>(
                "ActionObserverCameraFollowPlayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionObserverCameraFollowPlayer {
        static instance: ::protobuf::rt::LazyV2<ActionObserverCameraFollowPlayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionObserverCameraFollowPlayer::new)
    }
}

impl ::protobuf::Clear for ActionObserverCameraFollowPlayer {
    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionObserverCameraFollowPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionObserverCameraFollowPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionObserverCameraFollowUnits {
    // message fields
    pub unit_tags: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionObserverCameraFollowUnits {
    fn default() -> &'a ActionObserverCameraFollowUnits {
        <ActionObserverCameraFollowUnits as ::protobuf::Message>::default_instance()
    }
}

impl ActionObserverCameraFollowUnits {
    pub fn new() -> ActionObserverCameraFollowUnits {
        ::std::default::Default::default()
    }

    // repeated uint64 unit_tags = 1;


    pub fn get_unit_tags(&self) -> &[u64] {
        &self.unit_tags
    }
    pub fn clear_unit_tags(&mut self) {
        self.unit_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_tags(&mut self, v: ::std::vec::Vec<u64>) {
        self.unit_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_tags(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.unit_tags
    }

    // Take field
    pub fn take_unit_tags(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.unit_tags, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActionObserverCameraFollowUnits {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.unit_tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.unit_tags {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.unit_tags {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionObserverCameraFollowUnits {
        ActionObserverCameraFollowUnits::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "unit_tags",
                |m: &ActionObserverCameraFollowUnits| { &m.unit_tags },
                |m: &mut ActionObserverCameraFollowUnits| { &mut m.unit_tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionObserverCameraFollowUnits>(
                "ActionObserverCameraFollowUnits",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionObserverCameraFollowUnits {
        static instance: ::protobuf::rt::LazyV2<ActionObserverCameraFollowUnits> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionObserverCameraFollowUnits::new)
    }
}

impl ::protobuf::Clear for ActionObserverCameraFollowUnits {
    fn clear(&mut self) {
        self.unit_tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionObserverCameraFollowUnits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionObserverCameraFollowUnits {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerResult {
    // message fields
    pub player_id: ::std::option::Option<u32>,
    pub result: ::std::option::Option<Result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerResult {
    fn default() -> &'a PlayerResult {
        <PlayerResult as ::protobuf::Message>::default_instance()
    }
}

impl PlayerResult {
    pub fn new() -> PlayerResult {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;


    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Result result = 2;


    pub fn get_result(&self) -> Result {
        self.result.unwrap_or(Result::Victory)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerResult {
        PlayerResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_id",
                |m: &PlayerResult| { &m.player_id },
                |m: &mut PlayerResult| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Result>>(
                "result",
                |m: &PlayerResult| { &m.result },
                |m: &mut PlayerResult| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerResult>(
                "PlayerResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerResult {
        static instance: ::protobuf::rt::LazyV2<PlayerResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerResult::new)
    }
}

impl ::protobuf::Clear for PlayerResult {
    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    launched = 1,
    init_game = 2,
    in_game = 3,
    in_replay = 4,
    ended = 5,
    quit = 6,
    unknown = 99,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            1 => ::std::option::Option::Some(Status::launched),
            2 => ::std::option::Option::Some(Status::init_game),
            3 => ::std::option::Option::Some(Status::in_game),
            4 => ::std::option::Option::Some(Status::in_replay),
            5 => ::std::option::Option::Some(Status::ended),
            6 => ::std::option::Option::Some(Status::quit),
            99 => ::std::option::Option::Some(Status::unknown),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::launched,
            Status::init_game,
            Status::in_game,
            Status::in_replay,
            Status::ended,
            Status::quit,
            Status::unknown,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Status>("Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Status {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Status {
    fn default() -> Self {
        Status::launched
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Difficulty {
    VeryEasy = 1,
    Easy = 2,
    Medium = 3,
    MediumHard = 4,
    Hard = 5,
    Harder = 6,
    VeryHard = 7,
    CheatVision = 8,
    CheatMoney = 9,
    CheatInsane = 10,
}

impl ::protobuf::ProtobufEnum for Difficulty {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Difficulty> {
        match value {
            1 => ::std::option::Option::Some(Difficulty::VeryEasy),
            2 => ::std::option::Option::Some(Difficulty::Easy),
            3 => ::std::option::Option::Some(Difficulty::Medium),
            4 => ::std::option::Option::Some(Difficulty::MediumHard),
            5 => ::std::option::Option::Some(Difficulty::Hard),
            6 => ::std::option::Option::Some(Difficulty::Harder),
            7 => ::std::option::Option::Some(Difficulty::VeryHard),
            8 => ::std::option::Option::Some(Difficulty::CheatVision),
            9 => ::std::option::Option::Some(Difficulty::CheatMoney),
            10 => ::std::option::Option::Some(Difficulty::CheatInsane),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Difficulty] = &[
            Difficulty::VeryEasy,
            Difficulty::Easy,
            Difficulty::Medium,
            Difficulty::MediumHard,
            Difficulty::Hard,
            Difficulty::Harder,
            Difficulty::VeryHard,
            Difficulty::CheatVision,
            Difficulty::CheatMoney,
            Difficulty::CheatInsane,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Difficulty>("Difficulty", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Difficulty {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Difficulty {
    fn default() -> Self {
        Difficulty::VeryEasy
    }
}

impl ::protobuf::reflect::ProtobufValue for Difficulty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PlayerType {
    Participant = 1,
    Computer = 2,
    Observer = 3,
}

impl ::protobuf::ProtobufEnum for PlayerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PlayerType> {
        match value {
            1 => ::std::option::Option::Some(PlayerType::Participant),
            2 => ::std::option::Option::Some(PlayerType::Computer),
            3 => ::std::option::Option::Some(PlayerType::Observer),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PlayerType] = &[
            PlayerType::Participant,
            PlayerType::Computer,
            PlayerType::Observer,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PlayerType>("PlayerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PlayerType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PlayerType {
    fn default() -> Self {
        PlayerType::Participant
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AIBuild {
    RandomBuild = 1,
    Rush = 2,
    Timing = 3,
    Power = 4,
    Macro = 5,
    Air = 6,
}

impl ::protobuf::ProtobufEnum for AIBuild {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AIBuild> {
        match value {
            1 => ::std::option::Option::Some(AIBuild::RandomBuild),
            2 => ::std::option::Option::Some(AIBuild::Rush),
            3 => ::std::option::Option::Some(AIBuild::Timing),
            4 => ::std::option::Option::Some(AIBuild::Power),
            5 => ::std::option::Option::Some(AIBuild::Macro),
            6 => ::std::option::Option::Some(AIBuild::Air),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AIBuild] = &[
            AIBuild::RandomBuild,
            AIBuild::Rush,
            AIBuild::Timing,
            AIBuild::Power,
            AIBuild::Macro,
            AIBuild::Air,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AIBuild>("AIBuild", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AIBuild {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AIBuild {
    fn default() -> Self {
        AIBuild::RandomBuild
    }
}

impl ::protobuf::reflect::ProtobufValue for AIBuild {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Alert {
    AlertError = 3,
    AddOnComplete = 4,
    BuildingComplete = 5,
    BuildingUnderAttack = 6,
    LarvaHatched = 7,
    MergeComplete = 8,
    MineralsExhausted = 9,
    MorphComplete = 10,
    MothershipComplete = 11,
    MULEExpired = 12,
    NuclearLaunchDetected = 1,
    NukeComplete = 13,
    NydusWormDetected = 2,
    ResearchComplete = 14,
    TrainError = 15,
    TrainUnitComplete = 16,
    TrainWorkerComplete = 17,
    TransformationComplete = 18,
    UnitUnderAttack = 19,
    UpgradeComplete = 20,
    VespeneExhausted = 21,
    WarpInComplete = 22,
}

impl ::protobuf::ProtobufEnum for Alert {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Alert> {
        match value {
            3 => ::std::option::Option::Some(Alert::AlertError),
            4 => ::std::option::Option::Some(Alert::AddOnComplete),
            5 => ::std::option::Option::Some(Alert::BuildingComplete),
            6 => ::std::option::Option::Some(Alert::BuildingUnderAttack),
            7 => ::std::option::Option::Some(Alert::LarvaHatched),
            8 => ::std::option::Option::Some(Alert::MergeComplete),
            9 => ::std::option::Option::Some(Alert::MineralsExhausted),
            10 => ::std::option::Option::Some(Alert::MorphComplete),
            11 => ::std::option::Option::Some(Alert::MothershipComplete),
            12 => ::std::option::Option::Some(Alert::MULEExpired),
            1 => ::std::option::Option::Some(Alert::NuclearLaunchDetected),
            13 => ::std::option::Option::Some(Alert::NukeComplete),
            2 => ::std::option::Option::Some(Alert::NydusWormDetected),
            14 => ::std::option::Option::Some(Alert::ResearchComplete),
            15 => ::std::option::Option::Some(Alert::TrainError),
            16 => ::std::option::Option::Some(Alert::TrainUnitComplete),
            17 => ::std::option::Option::Some(Alert::TrainWorkerComplete),
            18 => ::std::option::Option::Some(Alert::TransformationComplete),
            19 => ::std::option::Option::Some(Alert::UnitUnderAttack),
            20 => ::std::option::Option::Some(Alert::UpgradeComplete),
            21 => ::std::option::Option::Some(Alert::VespeneExhausted),
            22 => ::std::option::Option::Some(Alert::WarpInComplete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Alert] = &[
            Alert::AlertError,
            Alert::AddOnComplete,
            Alert::BuildingComplete,
            Alert::BuildingUnderAttack,
            Alert::LarvaHatched,
            Alert::MergeComplete,
            Alert::MineralsExhausted,
            Alert::MorphComplete,
            Alert::MothershipComplete,
            Alert::MULEExpired,
            Alert::NuclearLaunchDetected,
            Alert::NukeComplete,
            Alert::NydusWormDetected,
            Alert::ResearchComplete,
            Alert::TrainError,
            Alert::TrainUnitComplete,
            Alert::TrainWorkerComplete,
            Alert::TransformationComplete,
            Alert::UnitUnderAttack,
            Alert::UpgradeComplete,
            Alert::VespeneExhausted,
            Alert::WarpInComplete,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Alert>("Alert", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Alert {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Alert {
    fn default() -> Self {
        Alert::AlertError
    }
}

impl ::protobuf::reflect::ProtobufValue for Alert {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Result {
    Victory = 1,
    Defeat = 2,
    Tie = 3,
    Undecided = 4,
}

impl ::protobuf::ProtobufEnum for Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Result> {
        match value {
            1 => ::std::option::Option::Some(Result::Victory),
            2 => ::std::option::Option::Some(Result::Defeat),
            3 => ::std::option::Option::Some(Result::Tie),
            4 => ::std::option::Option::Some(Result::Undecided),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Result] = &[
            Result::Victory,
            Result::Defeat,
            Result::Tie,
            Result::Undecided,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Result>("Result", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Result {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Result {
    fn default() -> Self {
        Result::Victory
    }
}

impl ::protobuf::reflect::ProtobufValue for Result {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ds2clientprotocol/sc2api.proto\x12\x0eSC2APIProtocol\x1a\x1ds2clien\
    tprotocol/common.proto\x1a\x1bs2clientprotocol/data.proto\x1a\x1cs2clien\
    tprotocol/debug.proto\x1a\x1cs2clientprotocol/error.proto\x1a\x1cs2clien\
    tprotocol/query.proto\x1a\x1as2clientprotocol/raw.proto\x1a\x1cs2clientp\
    rotocol/score.proto\x1a\x1es2clientprotocol/spatial.proto\x1a\x19s2clien\
    tprotocol/ui.proto\"\xa4\x0b\n\x07Request\x12D\n\x0bcreate_game\x18\x01\
    \x20\x01(\x0b2!.SC2APIProtocol.RequestCreateGameH\0R\ncreateGame\x12>\n\
    \tjoin_game\x18\x02\x20\x01(\x0b2\x1f.SC2APIProtocol.RequestJoinGameH\0R\
    \x08joinGame\x12G\n\x0crestart_game\x18\x03\x20\x01(\x0b2\".SC2APIProtoc\
    ol.RequestRestartGameH\0R\x0brestartGame\x12G\n\x0cstart_replay\x18\x04\
    \x20\x01(\x0b2\".SC2APIProtocol.RequestStartReplayH\0R\x0bstartReplay\
    \x12A\n\nleave_game\x18\x05\x20\x01(\x0b2\x20.SC2APIProtocol.RequestLeav\
    eGameH\0R\tleaveGame\x12A\n\nquick_save\x18\x06\x20\x01(\x0b2\x20.SC2API\
    Protocol.RequestQuickSaveH\0R\tquickSave\x12A\n\nquick_load\x18\x07\x20\
    \x01(\x0b2\x20.SC2APIProtocol.RequestQuickLoadH\0R\tquickLoad\x121\n\x04\
    quit\x18\x08\x20\x01(\x0b2\x1b.SC2APIProtocol.RequestQuitH\0R\x04quit\
    \x12>\n\tgame_info\x18\t\x20\x01(\x0b2\x1f.SC2APIProtocol.RequestGameInf\
    oH\0R\x08gameInfo\x12F\n\x0bobservation\x18\n\x20\x01(\x0b2\".SC2APIProt\
    ocol.RequestObservationH\0R\x0bobservation\x127\n\x06action\x18\x0b\x20\
    \x01(\x0b2\x1d.SC2APIProtocol.RequestActionH\0R\x06action\x12F\n\nobs_ac\
    tion\x18\x15\x20\x01(\x0b2%.SC2APIProtocol.RequestObserverActionH\0R\tob\
    sAction\x121\n\x04step\x18\x0c\x20\x01(\x0b2\x1b.SC2APIProtocol.RequestS\
    tepH\0R\x04step\x121\n\x04data\x18\r\x20\x01(\x0b2\x1b.SC2APIProtocol.Re\
    questDataH\0R\x04data\x124\n\x05query\x18\x0e\x20\x01(\x0b2\x1c.SC2APIPr\
    otocol.RequestQueryH\0R\x05query\x12D\n\x0bsave_replay\x18\x0f\x20\x01(\
    \x0b2!.SC2APIProtocol.RequestSaveReplayH\0R\nsaveReplay\x12D\n\x0bmap_co\
    mmand\x18\x16\x20\x01(\x0b2!.SC2APIProtocol.RequestMapCommandH\0R\nmapCo\
    mmand\x12D\n\x0breplay_info\x18\x10\x20\x01(\x0b2!.SC2APIProtocol.Reques\
    tReplayInfoH\0R\nreplayInfo\x12M\n\x0eavailable_maps\x18\x11\x20\x01(\
    \x0b2$.SC2APIProtocol.RequestAvailableMapsH\0R\ravailableMaps\x12;\n\x08\
    save_map\x18\x12\x20\x01(\x0b2\x1e.SC2APIProtocol.RequestSaveMapH\0R\x07\
    saveMap\x121\n\x04ping\x18\x13\x20\x01(\x0b2\x1b.SC2APIProtocol.RequestP\
    ingH\0R\x04ping\x124\n\x05debug\x18\x14\x20\x01(\x0b2\x1c.SC2APIProtocol\
    .RequestDebugH\0R\x05debug\x12\x0e\n\x02id\x18a\x20\x01(\rR\x02idB\t\n\
    \x07request\"\x82\x0c\n\x08Response\x12E\n\x0bcreate_game\x18\x01\x20\
    \x01(\x0b2\".SC2APIProtocol.ResponseCreateGameH\0R\ncreateGame\x12?\n\tj\
    oin_game\x18\x02\x20\x01(\x0b2\x20.SC2APIProtocol.ResponseJoinGameH\0R\
    \x08joinGame\x12H\n\x0crestart_game\x18\x03\x20\x01(\x0b2#.SC2APIProtoco\
    l.ResponseRestartGameH\0R\x0brestartGame\x12H\n\x0cstart_replay\x18\x04\
    \x20\x01(\x0b2#.SC2APIProtocol.ResponseStartReplayH\0R\x0bstartReplay\
    \x12B\n\nleave_game\x18\x05\x20\x01(\x0b2!.SC2APIProtocol.ResponseLeaveG\
    ameH\0R\tleaveGame\x12B\n\nquick_save\x18\x06\x20\x01(\x0b2!.SC2APIProto\
    col.ResponseQuickSaveH\0R\tquickSave\x12B\n\nquick_load\x18\x07\x20\x01(\
    \x0b2!.SC2APIProtocol.ResponseQuickLoadH\0R\tquickLoad\x122\n\x04quit\
    \x18\x08\x20\x01(\x0b2\x1c.SC2APIProtocol.ResponseQuitH\0R\x04quit\x12?\
    \n\tgame_info\x18\t\x20\x01(\x0b2\x20.SC2APIProtocol.ResponseGameInfoH\0\
    R\x08gameInfo\x12G\n\x0bobservation\x18\n\x20\x01(\x0b2#.SC2APIProtocol.\
    ResponseObservationH\0R\x0bobservation\x128\n\x06action\x18\x0b\x20\x01(\
    \x0b2\x1e.SC2APIProtocol.ResponseActionH\0R\x06action\x12G\n\nobs_action\
    \x18\x15\x20\x01(\x0b2&.SC2APIProtocol.ResponseObserverActionH\0R\tobsAc\
    tion\x122\n\x04step\x18\x0c\x20\x01(\x0b2\x1c.SC2APIProtocol.ResponseSte\
    pH\0R\x04step\x122\n\x04data\x18\r\x20\x01(\x0b2\x1c.SC2APIProtocol.Resp\
    onseDataH\0R\x04data\x125\n\x05query\x18\x0e\x20\x01(\x0b2\x1d.SC2APIPro\
    tocol.ResponseQueryH\0R\x05query\x12E\n\x0bsave_replay\x18\x0f\x20\x01(\
    \x0b2\".SC2APIProtocol.ResponseSaveReplayH\0R\nsaveReplay\x12E\n\x0brepl\
    ay_info\x18\x10\x20\x01(\x0b2\".SC2APIProtocol.ResponseReplayInfoH\0R\nr\
    eplayInfo\x12N\n\x0eavailable_maps\x18\x11\x20\x01(\x0b2%.SC2APIProtocol\
    .ResponseAvailableMapsH\0R\ravailableMaps\x12<\n\x08save_map\x18\x12\x20\
    \x01(\x0b2\x1f.SC2APIProtocol.ResponseSaveMapH\0R\x07saveMap\x12E\n\x0bm\
    ap_command\x18\x16\x20\x01(\x0b2\".SC2APIProtocol.ResponseMapCommandH\0R\
    \nmapCommand\x122\n\x04ping\x18\x13\x20\x01(\x0b2\x1c.SC2APIProtocol.Res\
    ponsePingH\0R\x04ping\x125\n\x05debug\x18\x14\x20\x01(\x0b2\x1d.SC2APIPr\
    otocol.ResponseDebugH\0R\x05debug\x12\x0e\n\x02id\x18a\x20\x01(\rR\x02id\
    \x12\x14\n\x05error\x18b\x20\x03(\tR\x05error\x12.\n\x06status\x18c\x20\
    \x01(\x0e2\x16.SC2APIProtocol.StatusR\x06statusB\n\n\x08response\"\xa1\
    \x02\n\x11RequestCreateGame\x127\n\tlocal_map\x18\x01\x20\x01(\x0b2\x18.\
    SC2APIProtocol.LocalMapH\0R\x08localMap\x12.\n\x12battlenet_map_name\x18\
    \x02\x20\x01(\tH\0R\x10battlenetMapName\x12>\n\x0cplayer_setup\x18\x03\
    \x20\x03(\x0b2\x1b.SC2APIProtocol.PlayerSetupR\x0bplayerSetup\x12\x1f\n\
    \x0bdisable_fog\x18\x04\x20\x01(\x08R\ndisableFog\x12\x1f\n\x0brandom_se\
    ed\x18\x05\x20\x01(\rR\nrandomSeed\x12\x1a\n\x08realtime\x18\x06\x20\x01\
    (\x08R\x08realtimeB\x05\n\x03Map\"@\n\x08LocalMap\x12\x19\n\x08map_path\
    \x18\x01\x20\x01(\tR\x07mapPath\x12\x19\n\x08map_data\x18\x07\x20\x01(\
    \x0cR\x07mapData\"\xb1\x02\n\x12ResponseCreateGame\x12>\n\x05error\x18\
    \x01\x20\x01(\x0e2(.SC2APIProtocol.ResponseCreateGame.ErrorR\x05error\
    \x12#\n\rerror_details\x18\x02\x20\x01(\tR\x0cerrorDetails\"\xb5\x01\n\
    \x05Error\x12\x0e\n\nMissingMap\x10\x01\x12\x12\n\x0eInvalidMapPath\x10\
    \x02\x12\x12\n\x0eInvalidMapData\x10\x03\x12\x12\n\x0eInvalidMapName\x10\
    \x04\x12\x14\n\x10InvalidMapHandle\x10\x05\x12\x16\n\x12MissingPlayerSet\
    up\x10\x06\x12\x16\n\x12InvalidPlayerSetup\x10\x07\x12\x1a\n\x16Multipla\
    yerUnsupported\x10\x08\"\x8d\x03\n\x0fRequestJoinGame\x12*\n\x04race\x18\
    \x01\x20\x01(\x0e2\x14.SC2APIProtocol.RaceH\0R\x04race\x12.\n\x12observe\
    d_player_id\x18\x02\x20\x01(\rH\0R\x10observedPlayerId\x12:\n\x07options\
    \x18\x03\x20\x01(\x0b2\x20.SC2APIProtocol.InterfaceOptionsR\x07options\
    \x12:\n\x0cserver_ports\x18\x04\x20\x01(\x0b2\x17.SC2APIProtocol.PortSet\
    R\x0bserverPorts\x12:\n\x0cclient_ports\x18\x05\x20\x03(\x0b2\x17.SC2API\
    Protocol.PortSetR\x0bclientPorts\x12\x1f\n\x0bshared_port\x18\x06\x20\
    \x01(\x05R\nsharedPort\x12\x1f\n\x0bplayer_name\x18\x07\x20\x01(\tR\npla\
    yerName\x12\x17\n\x07host_ip\x18\x08\x20\x01(\tR\x06hostIpB\x0f\n\rparti\
    cipation\"C\n\x07PortSet\x12\x1b\n\tgame_port\x18\x01\x20\x01(\x05R\x08g\
    amePort\x12\x1b\n\tbase_port\x18\x02\x20\x01(\x05R\x08basePort\"\xa1\x03\
    \n\x10ResponseJoinGame\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playe\
    rId\x12<\n\x05error\x18\x02\x20\x01(\x0e2&.SC2APIProtocol.ResponseJoinGa\
    me.ErrorR\x05error\x12#\n\rerror_details\x18\x03\x20\x01(\tR\x0cerrorDet\
    ails\"\x8c\x02\n\x05Error\x12\x18\n\x14MissingParticipation\x10\x01\x12\
    \x1b\n\x17InvalidObservedPlayerId\x10\x02\x12\x12\n\x0eMissingOptions\
    \x10\x03\x12\x10\n\x0cMissingPorts\x10\x04\x12\x0c\n\x08GameFull\x10\x05\
    \x12\x0f\n\x0bLaunchError\x10\x06\x12\x16\n\x12FeatureUnsupported\x10\
    \x07\x12\x12\n\x0eNoSpaceForUser\x10\x08\x12\x13\n\x0fMapDoesNotExist\
    \x10\t\x12\x11\n\rCannotOpenMap\x10\n\x12\x11\n\rChecksumError\x10\x0b\
    \x12\x10\n\x0cNetworkError\x10\x0c\x12\x0e\n\nOtherError\x10\r\"\x14\n\
    \x12RequestRestartGame\"\xbd\x01\n\x13ResponseRestartGame\x12?\n\x05erro\
    r\x18\x01\x20\x01(\x0e2).SC2APIProtocol.ResponseRestartGame.ErrorR\x05er\
    ror\x12#\n\rerror_details\x18\x02\x20\x01(\tR\x0cerrorDetails\x12&\n\x0f\
    need_hard_reset\x18\x03\x20\x01(\x08R\rneedHardReset\"\x18\n\x05Error\
    \x12\x0f\n\x0bLaunchError\x10\x01\"\xcb\x02\n\x12RequestStartReplay\x12!\
    \n\x0breplay_path\x18\x01\x20\x01(\tH\0R\nreplayPath\x12!\n\x0breplay_da\
    ta\x18\x05\x20\x01(\x0cH\0R\nreplayData\x12\x19\n\x08map_data\x18\x06\
    \x20\x01(\x0cR\x07mapData\x12,\n\x12observed_player_id\x18\x02\x20\x01(\
    \x05R\x10observedPlayerId\x12:\n\x07options\x18\x03\x20\x01(\x0b2\x20.SC\
    2APIProtocol.InterfaceOptionsR\x07options\x12\x1f\n\x0bdisable_fog\x18\
    \x04\x20\x01(\x08R\ndisableFog\x12\x1a\n\x08realtime\x18\x07\x20\x01(\
    \x08R\x08realtime\x12#\n\rrecord_replay\x18\x08\x20\x01(\x08R\x0crecordR\
    eplayB\x08\n\x06replay\"\x9c\x02\n\x13ResponseStartReplay\x12?\n\x05erro\
    r\x18\x01\x20\x01(\x0e2).SC2APIProtocol.ResponseStartReplay.ErrorR\x05er\
    ror\x12#\n\rerror_details\x18\x02\x20\x01(\tR\x0cerrorDetails\"\x9e\x01\
    \n\x05Error\x12\x11\n\rMissingReplay\x10\x01\x12\x15\n\x11InvalidReplayP\
    ath\x10\x02\x12\x15\n\x11InvalidReplayData\x10\x03\x12\x12\n\x0eInvalidM\
    apData\x10\x04\x12\x1b\n\x17InvalidObservedPlayerId\x10\x05\x12\x12\n\
    \x0eMissingOptions\x10\x06\x12\x0f\n\x0bLaunchError\x10\x07\"4\n\x11Requ\
    estMapCommand\x12\x1f\n\x0btrigger_cmd\x18\x01\x20\x01(\tR\ntriggerCmd\"\
    \x96\x01\n\x12ResponseMapCommand\x12>\n\x05error\x18\x01\x20\x01(\x0e2(.\
    SC2APIProtocol.ResponseMapCommand.ErrorR\x05error\x12#\n\rerror_details\
    \x18\x02\x20\x01(\tR\x0cerrorDetails\"\x1b\n\x05Error\x12\x12\n\x0eNoTri\
    ggerError\x10\x01\"\x12\n\x10RequestLeaveGame\"\x13\n\x11ResponseLeaveGa\
    me\"\x12\n\x10RequestQuickSave\"\x13\n\x11ResponseQuickSave\"\x12\n\x10R\
    equestQuickLoad\"\x13\n\x11ResponseQuickLoad\"\r\n\x0bRequestQuit\"\x0e\
    \n\x0cResponseQuit\"\x11\n\x0fRequestGameInfo\"\xa0\x02\n\x10ResponseGam\
    eInfo\x12\x19\n\x08map_name\x18\x01\x20\x01(\tR\x07mapName\x12\x1b\n\tmo\
    d_names\x18\x06\x20\x03(\tR\x08modNames\x12$\n\x0elocal_map_path\x18\x02\
    \x20\x01(\tR\x0clocalMapPath\x12;\n\x0bplayer_info\x18\x03\x20\x03(\x0b2\
    \x1a.SC2APIProtocol.PlayerInfoR\nplayerInfo\x125\n\tstart_raw\x18\x04\
    \x20\x01(\x0b2\x18.SC2APIProtocol.StartRawR\x08startRaw\x12:\n\x07option\
    s\x18\x05\x20\x01(\x0b2\x20.SC2APIProtocol.InterfaceOptionsR\x07options\
    \"R\n\x12RequestObservation\x12\x1f\n\x0bdisable_fog\x18\x01\x20\x01(\
    \x08R\ndisableFog\x12\x1b\n\tgame_loop\x18\x02\x20\x01(\rR\x08gameLoop\"\
    \xbd\x02\n\x13ResponseObservation\x120\n\x07actions\x18\x01\x20\x03(\x0b\
    2\x16.SC2APIProtocol.ActionR\x07actions\x12@\n\raction_errors\x18\x02\
    \x20\x03(\x0b2\x1b.SC2APIProtocol.ActionErrorR\x0cactionErrors\x12=\n\
    \x0bobservation\x18\x03\x20\x01(\x0b2\x1b.SC2APIProtocol.ObservationR\
    \x0bobservation\x12A\n\rplayer_result\x18\x04\x20\x03(\x0b2\x1c.SC2APIPr\
    otocol.PlayerResultR\x0cplayerResult\x120\n\x04chat\x18\x05\x20\x03(\x0b\
    2\x1c.SC2APIProtocol.ChatReceivedR\x04chat\"E\n\x0cChatReceived\x12\x1b\
    \n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\"A\n\rRequestAction\x120\n\x07actions\x18\
    \x01\x20\x03(\x0b2\x16.SC2APIProtocol.ActionR\x07actions\"F\n\x0eRespons\
    eAction\x124\n\x06result\x18\x01\x20\x03(\x0e2\x1c.SC2APIProtocol.Action\
    ResultR\x06result\"Q\n\x15RequestObserverAction\x128\n\x07actions\x18\
    \x01\x20\x03(\x0b2\x1e.SC2APIProtocol.ObserverActionR\x07actions\"\x18\n\
    \x16ResponseObserverAction\"#\n\x0bRequestStep\x12\x14\n\x05count\x18\
    \x01\x20\x01(\rR\x05count\"7\n\x0cResponseStep\x12'\n\x0fsimulation_loop\
    \x18\x01\x20\x01(\rR\x0esimulationLoop\"\xa3\x01\n\x0bRequestData\x12\
    \x1d\n\nability_id\x18\x01\x20\x01(\x08R\tabilityId\x12\x20\n\x0cunit_ty\
    pe_id\x18\x02\x20\x01(\x08R\nunitTypeId\x12\x1d\n\nupgrade_id\x18\x03\
    \x20\x01(\x08R\tupgradeId\x12\x17\n\x07buff_id\x18\x04\x20\x01(\x08R\x06\
    buffId\x12\x1b\n\teffect_id\x18\x05\x20\x01(\x08R\x08effectId\"\x9c\x02\
    \n\x0cResponseData\x129\n\tabilities\x18\x01\x20\x03(\x0b2\x1b.SC2APIPro\
    tocol.AbilityDataR\tabilities\x122\n\x05units\x18\x02\x20\x03(\x0b2\x1c.\
    SC2APIProtocol.UnitTypeDataR\x05units\x127\n\x08upgrades\x18\x03\x20\x03\
    (\x0b2\x1b.SC2APIProtocol.UpgradeDataR\x08upgrades\x12.\n\x05buffs\x18\
    \x04\x20\x03(\x0b2\x18.SC2APIProtocol.BuffDataR\x05buffs\x124\n\x07effec\
    ts\x18\x05\x20\x03(\x0b2\x1a.SC2APIProtocol.EffectDataR\x07effects\"\x13\
    \n\x11RequestSaveReplay\"(\n\x12ResponseSaveReplay\x12\x12\n\x04data\x18\
    \x01\x20\x01(\x0cR\x04data\"\x88\x01\n\x11RequestReplayInfo\x12!\n\x0bre\
    play_path\x18\x01\x20\x01(\tH\0R\nreplayPath\x12!\n\x0breplay_data\x18\
    \x02\x20\x01(\x0cH\0R\nreplayData\x12#\n\rdownload_data\x18\x03\x20\x01(\
    \x08R\x0cdownloadDataB\x08\n\x06replay\"\xcf\x01\n\x0fPlayerInfoExtra\
    \x12;\n\x0bplayer_info\x18\x01\x20\x01(\x0b2\x1a.SC2APIProtocol.PlayerIn\
    foR\nplayerInfo\x12A\n\rplayer_result\x18\x02\x20\x01(\x0b2\x1c.SC2APIPr\
    otocol.PlayerResultR\x0cplayerResult\x12\x1d\n\nplayer_mmr\x18\x03\x20\
    \x01(\x05R\tplayerMmr\x12\x1d\n\nplayer_apm\x18\x04\x20\x01(\x05R\tplaye\
    rApm\"\xd3\x04\n\x12ResponseReplayInfo\x12\x19\n\x08map_name\x18\x01\x20\
    \x01(\tR\x07mapName\x12$\n\x0elocal_map_path\x18\x02\x20\x01(\tR\x0cloca\
    lMapPath\x12@\n\x0bplayer_info\x18\x03\x20\x03(\x0b2\x1f.SC2APIProtocol.\
    PlayerInfoExtraR\nplayerInfo\x12.\n\x13game_duration_loops\x18\x04\x20\
    \x01(\rR\x11gameDurationLoops\x122\n\x15game_duration_seconds\x18\x05\
    \x20\x01(\x02R\x13gameDurationSeconds\x12!\n\x0cgame_version\x18\x06\x20\
    \x01(\tR\x0bgameVersion\x12!\n\x0cdata_version\x18\x0b\x20\x01(\tR\x0bda\
    taVersion\x12\x1d\n\ndata_build\x18\x07\x20\x01(\rR\tdataBuild\x12\x1d\n\
    \nbase_build\x18\x08\x20\x01(\rR\tbaseBuild\x12>\n\x05error\x18\t\x20\
    \x01(\x0e2(.SC2APIProtocol.ResponseReplayInfo.ErrorR\x05error\x12#\n\rer\
    ror_details\x18\n\x20\x01(\tR\x0cerrorDetails\"m\n\x05Error\x12\x11\n\rM\
    issingReplay\x10\x01\x12\x15\n\x11InvalidReplayPath\x10\x02\x12\x15\n\
    \x11InvalidReplayData\x10\x03\x12\x10\n\x0cParsingError\x10\x04\x12\x11\
    \n\rDownloadError\x10\x05\"\x16\n\x14RequestAvailableMaps\"o\n\x15Respon\
    seAvailableMaps\x12&\n\x0flocal_map_paths\x18\x01\x20\x03(\tR\rlocalMapP\
    aths\x12.\n\x13battlenet_map_names\x18\x02\x20\x03(\tR\x11battlenetMapNa\
    mes\"F\n\x0eRequestSaveMap\x12\x19\n\x08map_path\x18\x01\x20\x01(\tR\x07\
    mapPath\x12\x19\n\x08map_data\x18\x02\x20\x01(\x0cR\x07mapData\"k\n\x0fR\
    esponseSaveMap\x12;\n\x05error\x18\x01\x20\x01(\x0e2%.SC2APIProtocol.Res\
    ponseSaveMap.ErrorR\x05error\"\x1b\n\x05Error\x12\x12\n\x0eInvalidMapDat\
    a\x10\x01\"\r\n\x0bRequestPing\"\x92\x01\n\x0cResponsePing\x12!\n\x0cgam\
    e_version\x18\x01\x20\x01(\tR\x0bgameVersion\x12!\n\x0cdata_version\x18\
    \x02\x20\x01(\tR\x0bdataVersion\x12\x1d\n\ndata_build\x18\x03\x20\x01(\r\
    R\tdataBuild\x12\x1d\n\nbase_build\x18\x04\x20\x01(\rR\tbaseBuild\"B\n\
    \x0cRequestDebug\x122\n\x05debug\x18\x01\x20\x03(\x0b2\x1c.SC2APIProtoco\
    l.DebugCommandR\x05debug\"\x0f\n\rResponseDebug\"\xf8\x01\n\x0bPlayerSet\
    up\x12.\n\x04type\x18\x01\x20\x01(\x0e2\x1a.SC2APIProtocol.PlayerTypeR\
    \x04type\x12(\n\x04race\x18\x02\x20\x01(\x0e2\x14.SC2APIProtocol.RaceR\
    \x04race\x12:\n\ndifficulty\x18\x03\x20\x01(\x0e2\x1a.SC2APIProtocol.Dif\
    ficultyR\ndifficulty\x12\x1f\n\x0bplayer_name\x18\x04\x20\x01(\tR\nplaye\
    rName\x122\n\x08ai_build\x18\x05\x20\x01(\x0e2\x17.SC2APIProtocol.AIBuil\
    dR\x07aiBuild\"\x92\x02\n\x12SpatialCameraSetup\x127\n\nresolution\x18\
    \x02\x20\x01(\x0b2\x17.SC2APIProtocol.Size2DIR\nresolution\x12F\n\x12min\
    imap_resolution\x18\x03\x20\x01(\x0b2\x17.SC2APIProtocol.Size2DIR\x11min\
    imapResolution\x12\x14\n\x05width\x18\x01\x20\x01(\x02R\x05width\x121\n\
    \x15crop_to_playable_area\x18\x04\x20\x01(\x08R\x12cropToPlayableArea\
    \x122\n\x15allow_cheating_layers\x18\x05\x20\x01(\x08R\x13allowCheatingL\
    ayers\"\xb1\x03\n\x10InterfaceOptions\x12\x10\n\x03raw\x18\x01\x20\x01(\
    \x08R\x03raw\x12\x14\n\x05score\x18\x02\x20\x01(\x08R\x05score\x12G\n\rf\
    eature_layer\x18\x03\x20\x01(\x0b2\".SC2APIProtocol.SpatialCameraSetupR\
    \x0cfeatureLayer\x12:\n\x06render\x18\x04\x20\x01(\x0b2\".SC2APIProtocol\
    .SpatialCameraSetupR\x06render\x12!\n\x0cshow_cloaked\x18\x05\x20\x01(\
    \x08R\x0bshowCloaked\x122\n\x15show_burrowed_shadows\x18\t\x20\x01(\x08R\
    \x13showBurrowedShadows\x12+\n\x11show_placeholders\x18\x08\x20\x01(\x08\
    R\x10showPlaceholders\x122\n\x15raw_affects_selection\x18\x06\x20\x01(\
    \x08R\x13rawAffectsSelection\x128\n\x19raw_crop_to_playable_area\x18\x07\
    \x20\x01(\x08R\x15rawCropToPlayableArea\"\xde\x02\n\nPlayerInfo\x12\x1b\
    \n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12.\n\x04type\x18\x02\x20\
    \x01(\x0e2\x1a.SC2APIProtocol.PlayerTypeR\x04type\x12;\n\x0erace_request\
    ed\x18\x03\x20\x01(\x0e2\x14.SC2APIProtocol.RaceR\rraceRequested\x125\n\
    \x0brace_actual\x18\x04\x20\x01(\x0e2\x14.SC2APIProtocol.RaceR\nraceActu\
    al\x12:\n\ndifficulty\x18\x05\x20\x01(\x0e2\x1a.SC2APIProtocol.Difficult\
    yR\ndifficulty\x122\n\x08ai_build\x18\x07\x20\x01(\x0e2\x17.SC2APIProtoc\
    ol.AIBuildR\x07aiBuild\x12\x1f\n\x0bplayer_name\x18\x06\x20\x01(\tR\npla\
    yerName\"\xed\x02\n\x0cPlayerCommon\x12\x1b\n\tplayer_id\x18\x01\x20\x01\
    (\rR\x08playerId\x12\x1a\n\x08minerals\x18\x02\x20\x01(\rR\x08minerals\
    \x12\x18\n\x07vespene\x18\x03\x20\x01(\rR\x07vespene\x12\x19\n\x08food_c\
    ap\x18\x04\x20\x01(\rR\x07foodCap\x12\x1b\n\tfood_used\x18\x05\x20\x01(\
    \rR\x08foodUsed\x12\x1b\n\tfood_army\x18\x06\x20\x01(\rR\x08foodArmy\x12\
    !\n\x0cfood_workers\x18\x07\x20\x01(\rR\x0bfoodWorkers\x12*\n\x11idle_wo\
    rker_count\x18\x08\x20\x01(\rR\x0fidleWorkerCount\x12\x1d\n\narmy_count\
    \x18\t\x20\x01(\rR\tarmyCount\x12&\n\x0fwarp_gate_count\x18\n\x20\x01(\r\
    R\rwarpGateCount\x12\x1f\n\x0blarva_count\x18\x0b\x20\x01(\rR\nlarvaCoun\
    t\"\x97\x04\n\x0bObservation\x12\x1b\n\tgame_loop\x18\t\x20\x01(\rR\x08g\
    ameLoop\x12A\n\rplayer_common\x18\x01\x20\x01(\x0b2\x1c.SC2APIProtocol.P\
    layerCommonR\x0cplayerCommon\x12-\n\x06alerts\x18\n\x20\x03(\x0e2\x15.SC\
    2APIProtocol.AlertR\x06alerts\x12>\n\tabilities\x18\x03\x20\x03(\x0b2\
    \x20.SC2APIProtocol.AvailableAbilityR\tabilities\x12+\n\x05score\x18\x04\
    \x20\x01(\x0b2\x15.SC2APIProtocol.ScoreR\x05score\x129\n\x08raw_data\x18\
    \x05\x20\x01(\x0b2\x1e.SC2APIProtocol.ObservationRawR\x07rawData\x12U\n\
    \x12feature_layer_data\x18\x06\x20\x01(\x0b2'.SC2APIProtocol.Observation\
    FeatureLayerR\x10featureLayerData\x12B\n\x0brender_data\x18\x07\x20\x01(\
    \x0b2!.SC2APIProtocol.ObservationRenderR\nrenderData\x126\n\x07ui_data\
    \x18\x08\x20\x01(\x0b2\x1d.SC2APIProtocol.ObservationUIR\x06uiData\"\xe8\
    \x02\n\x06Action\x128\n\naction_raw\x18\x01\x20\x01(\x0b2\x19.SC2APIProt\
    ocol.ActionRawR\tactionRaw\x12O\n\x14action_feature_layer\x18\x02\x20\
    \x01(\x0b2\x1d.SC2APIProtocol.ActionSpatialR\x12actionFeatureLayer\x12B\
    \n\raction_render\x18\x03\x20\x01(\x0b2\x1d.SC2APIProtocol.ActionSpatial\
    R\x0cactionRender\x125\n\taction_ui\x18\x04\x20\x01(\x0b2\x18.SC2APIProt\
    ocol.ActionUIR\x08actionUi\x12;\n\x0baction_chat\x18\x06\x20\x01(\x0b2\
    \x1a.SC2APIProtocol.ActionChatR\nactionChat\x12\x1b\n\tgame_loop\x18\x07\
    \x20\x01(\rR\x08gameLoop\"\x88\x01\n\nActionChat\x12<\n\x07channel\x18\
    \x01\x20\x01(\x0e2\".SC2APIProtocol.ActionChat.ChannelR\x07channel\x12\
    \x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\"\n\x07Channel\x12\r\
    \n\tBroadcast\x10\x01\x12\x08\n\x04Team\x10\x02\"}\n\x0bActionError\x12\
    \x19\n\x08unit_tag\x18\x01\x20\x01(\x04R\x07unitTag\x12\x1d\n\nability_i\
    d\x18\x02\x20\x01(\x04R\tabilityId\x124\n\x06result\x18\x03\x20\x01(\x0e\
    2\x1c.SC2APIProtocol.ActionResultR\x06result\"\x92\x03\n\x0eObserverActi\
    on\x12`\n\x12player_perspective\x18\x01\x20\x01(\x0b2/.SC2APIProtocol.Ac\
    tionObserverPlayerPerspectiveH\0R\x11playerPerspective\x12K\n\x0bcamera_\
    move\x18\x02\x20\x01(\x0b2(.SC2APIProtocol.ActionObserverCameraMoveH\0R\
    \ncameraMove\x12d\n\x14camera_follow_player\x18\x03\x20\x01(\x0b20.SC2AP\
    IProtocol.ActionObserverCameraFollowPlayerH\0R\x12cameraFollowPlayer\x12\
    a\n\x13camera_follow_units\x18\x04\x20\x01(\x0b2/.SC2APIProtocol.ActionO\
    bserverCameraFollowUnitsH\0R\x11cameraFollowUnitsB\x08\n\x06action\">\n\
    \x1fActionObserverPlayerPerspective\x12\x1b\n\tplayer_id\x18\x01\x20\x01\
    (\rR\x08playerId\"l\n\x18ActionObserverCameraMove\x124\n\tworld_pos\x18\
    \x01\x20\x01(\x0b2\x17.SC2APIProtocol.Point2DR\x08worldPos\x12\x1a\n\x08\
    distance\x18\x02\x20\x01(\x02R\x08distance\"?\n\x20ActionObserverCameraF\
    ollowPlayer\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\">\n\
    \x1fActionObserverCameraFollowUnits\x12\x1b\n\tunit_tags\x18\x01\x20\x03\
    (\x04R\x08unitTags\"[\n\x0cPlayerResult\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x01(\rR\x08playerId\x12.\n\x06result\x18\x02\x20\x01(\x0e2\x16.SC2APIPr\
    otocol.ResultR\x06result*c\n\x06Status\x12\x0c\n\x08launched\x10\x01\x12\
    \r\n\tinit_game\x10\x02\x12\x0b\n\x07in_game\x10\x03\x12\r\n\tin_replay\
    \x10\x04\x12\t\n\x05ended\x10\x05\x12\x08\n\x04quit\x10\x06\x12\x0b\n\
    \x07unknown\x10c*\x96\x01\n\nDifficulty\x12\x0c\n\x08VeryEasy\x10\x01\
    \x12\x08\n\x04Easy\x10\x02\x12\n\n\x06Medium\x10\x03\x12\x0e\n\nMediumHa\
    rd\x10\x04\x12\x08\n\x04Hard\x10\x05\x12\n\n\x06Harder\x10\x06\x12\x0c\n\
    \x08VeryHard\x10\x07\x12\x0f\n\x0bCheatVision\x10\x08\x12\x0e\n\nCheatMo\
    ney\x10\t\x12\x0f\n\x0bCheatInsane\x10\n*9\n\nPlayerType\x12\x0f\n\x0bPa\
    rticipant\x10\x01\x12\x0c\n\x08Computer\x10\x02\x12\x0c\n\x08Observer\
    \x10\x03*O\n\x07AIBuild\x12\x0f\n\x0bRandomBuild\x10\x01\x12\x08\n\x04Ru\
    sh\x10\x02\x12\n\n\x06Timing\x10\x03\x12\t\n\x05Power\x10\x04\x12\t\n\
    \x05Macro\x10\x05\x12\x07\n\x03Air\x10\x06*\xdb\x03\n\x05Alert\x12\x0e\n\
    \nAlertError\x10\x03\x12\x11\n\rAddOnComplete\x10\x04\x12\x14\n\x10Build\
    ingComplete\x10\x05\x12\x17\n\x13BuildingUnderAttack\x10\x06\x12\x10\n\
    \x0cLarvaHatched\x10\x07\x12\x11\n\rMergeComplete\x10\x08\x12\x15\n\x11M\
    ineralsExhausted\x10\t\x12\x11\n\rMorphComplete\x10\n\x12\x16\n\x12Mothe\
    rshipComplete\x10\x0b\x12\x0f\n\x0bMULEExpired\x10\x0c\x12\x19\n\x15Nucl\
    earLaunchDetected\x10\x01\x12\x10\n\x0cNukeComplete\x10\r\x12\x15\n\x11N\
    ydusWormDetected\x10\x02\x12\x14\n\x10ResearchComplete\x10\x0e\x12\x0e\n\
    \nTrainError\x10\x0f\x12\x15\n\x11TrainUnitComplete\x10\x10\x12\x17\n\
    \x13TrainWorkerComplete\x10\x11\x12\x1a\n\x16TransformationComplete\x10\
    \x12\x12\x13\n\x0fUnitUnderAttack\x10\x13\x12\x13\n\x0fUpgradeComplete\
    \x10\x14\x12\x14\n\x10VespeneExhausted\x10\x15\x12\x12\n\x0eWarpInComple\
    te\x10\x16*9\n\x06Result\x12\x0b\n\x07Victory\x10\x01\x12\n\n\x06Defeat\
    \x10\x02\x12\x07\n\x03Tie\x10\x03\x12\r\n\tUndecided\x10\x04\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
